import "./chunk-V6TY7KAL.js";

// node_modules/@cosmograph/cosmos/dist/index.js
var Yo = "http://www.w3.org/1999/xhtml";
var Rf = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Yo,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Vi(e3) {
  var t = e3 += "", n = t.indexOf(":");
  return n >= 0 && (t = e3.slice(0, n)) !== "xmlns" && (e3 = e3.slice(n + 1)), Rf.hasOwnProperty(t) ? { space: Rf[t], local: e3 } : e3;
}
function Sd(e3) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Yo && t.documentElement.namespaceURI === Yo ? t.createElement(e3) : t.createElementNS(n, e3);
  };
}
function wd(e3) {
  return function() {
    return this.ownerDocument.createElementNS(e3.space, e3.local);
  };
}
function hu(e3) {
  var t = Vi(e3);
  return (t.local ? wd : Sd)(t);
}
function Td() {
}
function ha(e3) {
  return e3 == null ? Td : function() {
    return this.querySelector(e3);
  };
}
function Ad(e3) {
  typeof e3 != "function" && (e3 = ha(e3));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], f = o.length, s = r[i] = new Array(f), u, l, v = 0; v < f; ++v)
      (u = o[v]) && (l = e3.call(u, u.__data__, v, o)) && ("__data__" in u && (l.__data__ = u.__data__), s[v] = l);
  return new Nt(r, this._parents);
}
function Ed(e3) {
  return e3 == null ? [] : Array.isArray(e3) ? e3 : Array.from(e3);
}
function Pd() {
  return [];
}
function du(e3) {
  return e3 == null ? Pd : function() {
    return this.querySelectorAll(e3);
  };
}
function Cd(e3) {
  return function() {
    return Ed(e3.apply(this, arguments));
  };
}
function kd(e3) {
  typeof e3 == "function" ? e3 = Cd(e3) : e3 = du(e3);
  for (var t = this._groups, n = t.length, r = [], i = [], o = 0; o < n; ++o)
    for (var f = t[o], s = f.length, u, l = 0; l < s; ++l)
      (u = f[l]) && (r.push(e3.call(u, u.__data__, l, f)), i.push(u));
  return new Nt(r, i);
}
function mu(e3) {
  return function() {
    return this.matches(e3);
  };
}
function pu(e3) {
  return function(t) {
    return t.matches(e3);
  };
}
var Fd = Array.prototype.find;
function Ld(e3) {
  return function() {
    return Fd.call(this.children, e3);
  };
}
function zd() {
  return this.firstElementChild;
}
function Id(e3) {
  return this.select(e3 == null ? zd : Ld(typeof e3 == "function" ? e3 : pu(e3)));
}
var Rd = Array.prototype.filter;
function Dd() {
  return Array.from(this.children);
}
function Md(e3) {
  return function() {
    return Rd.call(this.children, e3);
  };
}
function Od(e3) {
  return this.selectAll(e3 == null ? Dd : Md(typeof e3 == "function" ? e3 : pu(e3)));
}
function Nd(e3) {
  typeof e3 != "function" && (e3 = mu(e3));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], f = o.length, s = r[i] = [], u, l = 0; l < f; ++l)
      (u = o[l]) && e3.call(u, u.__data__, l, o) && s.push(u);
  return new Nt(r, this._parents);
}
function vu(e3) {
  return new Array(e3.length);
}
function Gd() {
  return new Nt(this._enter || this._groups.map(vu), this._parents);
}
function zi(e3, t) {
  this.ownerDocument = e3.ownerDocument, this.namespaceURI = e3.namespaceURI, this._next = null, this._parent = e3, this.__data__ = t;
}
zi.prototype = {
  constructor: zi,
  appendChild: function(e3) {
    return this._parent.insertBefore(e3, this._next);
  },
  insertBefore: function(e3, t) {
    return this._parent.insertBefore(e3, t);
  },
  querySelector: function(e3) {
    return this._parent.querySelector(e3);
  },
  querySelectorAll: function(e3) {
    return this._parent.querySelectorAll(e3);
  }
};
function Bd(e3) {
  return function() {
    return e3;
  };
}
function Vd(e3, t, n, r, i, o) {
  for (var f = 0, s, u = t.length, l = o.length; f < l; ++f)
    (s = t[f]) ? (s.__data__ = o[f], r[f] = s) : n[f] = new zi(e3, o[f]);
  for (; f < u; ++f)
    (s = t[f]) && (i[f] = s);
}
function $d(e3, t, n, r, i, o, f) {
  var s, u, l = /* @__PURE__ */ new Map(), v = t.length, b = o.length, S = new Array(v), M;
  for (s = 0; s < v; ++s)
    (u = t[s]) && (S[s] = M = f.call(u, u.__data__, s, t) + "", l.has(M) ? i[s] = u : l.set(M, u));
  for (s = 0; s < b; ++s)
    M = f.call(e3, o[s], s, o) + "", (u = l.get(M)) ? (r[s] = u, u.__data__ = o[s], l.delete(M)) : n[s] = new zi(e3, o[s]);
  for (s = 0; s < v; ++s)
    (u = t[s]) && l.get(S[s]) === u && (i[s] = u);
}
function jd(e3) {
  return e3.__data__;
}
function Ud(e3, t) {
  if (!arguments.length) return Array.from(this, jd);
  var n = t ? $d : Vd, r = this._parents, i = this._groups;
  typeof e3 != "function" && (e3 = Bd(e3));
  for (var o = i.length, f = new Array(o), s = new Array(o), u = new Array(o), l = 0; l < o; ++l) {
    var v = r[l], b = i[l], S = b.length, M = Xd(e3.call(v, v && v.__data__, l, r)), K = M.length, we = s[l] = new Array(K), ke = f[l] = new Array(K), ae = u[l] = new Array(S);
    n(v, b, we, ke, ae, M, t);
    for (var Ne = 0, je = 0, q, pe; Ne < K; ++Ne)
      if (q = we[Ne]) {
        for (Ne >= je && (je = Ne + 1); !(pe = ke[je]) && ++je < K; ) ;
        q._next = pe || null;
      }
  }
  return f = new Nt(f, r), f._enter = s, f._exit = u, f;
}
function Xd(e3) {
  return typeof e3 == "object" && "length" in e3 ? e3 : Array.from(e3);
}
function Hd() {
  return new Nt(this._exit || this._groups.map(vu), this._parents);
}
function Wd(e3, t, n) {
  var r = this.enter(), i = this, o = this.exit();
  return typeof e3 == "function" ? (r = e3(r), r && (r = r.selection())) : r = r.append(e3 + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? o.remove() : n(o), r && i ? r.merge(i).order() : i;
}
function qd(e3) {
  for (var t = e3.selection ? e3.selection() : e3, n = this._groups, r = t._groups, i = n.length, o = r.length, f = Math.min(i, o), s = new Array(i), u = 0; u < f; ++u)
    for (var l = n[u], v = r[u], b = l.length, S = s[u] = new Array(b), M, K = 0; K < b; ++K)
      (M = l[K] || v[K]) && (S[K] = M);
  for (; u < i; ++u)
    s[u] = n[u];
  return new Nt(s, this._parents);
}
function Yd() {
  for (var e3 = this._groups, t = -1, n = e3.length; ++t < n; )
    for (var r = e3[t], i = r.length - 1, o = r[i], f; --i >= 0; )
      (f = r[i]) && (o && f.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(f, o), o = f);
  return this;
}
function Zd(e3) {
  e3 || (e3 = Qd);
  function t(b, S) {
    return b && S ? e3(b.__data__, S.__data__) : !b - !S;
  }
  for (var n = this._groups, r = n.length, i = new Array(r), o = 0; o < r; ++o) {
    for (var f = n[o], s = f.length, u = i[o] = new Array(s), l, v = 0; v < s; ++v)
      (l = f[v]) && (u[v] = l);
    u.sort(t);
  }
  return new Nt(i, this._parents).order();
}
function Qd(e3, t) {
  return e3 < t ? -1 : e3 > t ? 1 : e3 >= t ? 0 : NaN;
}
function Kd() {
  var e3 = arguments[0];
  return arguments[0] = this, e3.apply(null, arguments), this;
}
function Jd() {
  return Array.from(this);
}
function em() {
  for (var e3 = this._groups, t = 0, n = e3.length; t < n; ++t)
    for (var r = e3[t], i = 0, o = r.length; i < o; ++i) {
      var f = r[i];
      if (f) return f;
    }
  return null;
}
function tm() {
  let e3 = 0;
  for (const t of this) ++e3;
  return e3;
}
function nm() {
  return !this.node();
}
function rm(e3) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var i = t[n], o = 0, f = i.length, s; o < f; ++o)
      (s = i[o]) && e3.call(s, s.__data__, o, i);
  return this;
}
function im(e3) {
  return function() {
    this.removeAttribute(e3);
  };
}
function om(e3) {
  return function() {
    this.removeAttributeNS(e3.space, e3.local);
  };
}
function am(e3, t) {
  return function() {
    this.setAttribute(e3, t);
  };
}
function sm(e3, t) {
  return function() {
    this.setAttributeNS(e3.space, e3.local, t);
  };
}
function fm(e3, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e3) : this.setAttribute(e3, n);
  };
}
function um(e3, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e3.space, e3.local) : this.setAttributeNS(e3.space, e3.local, n);
  };
}
function cm(e3, t) {
  var n = Vi(e3);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? om : im : typeof t == "function" ? n.local ? um : fm : n.local ? sm : am)(n, t));
}
function gu(e3) {
  return e3.ownerDocument && e3.ownerDocument.defaultView || e3.document && e3 || e3.defaultView;
}
function lm(e3) {
  return function() {
    this.style.removeProperty(e3);
  };
}
function hm(e3, t, n) {
  return function() {
    this.style.setProperty(e3, t, n);
  };
}
function dm(e3, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e3) : this.style.setProperty(e3, r, n);
  };
}
function mm(e3, t, n) {
  return arguments.length > 1 ? this.each((t == null ? lm : typeof t == "function" ? dm : hm)(e3, t, n ?? "")) : sr(this.node(), e3);
}
function sr(e3, t) {
  return e3.style.getPropertyValue(t) || gu(e3).getComputedStyle(e3, null).getPropertyValue(t);
}
function pm(e3) {
  return function() {
    delete this[e3];
  };
}
function vm(e3, t) {
  return function() {
    this[e3] = t;
  };
}
function gm(e3, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e3] : this[e3] = n;
  };
}
function xm(e3, t) {
  return arguments.length > 1 ? this.each((t == null ? pm : typeof t == "function" ? gm : vm)(e3, t)) : this.node()[e3];
}
function xu(e3) {
  return e3.trim().split(/^|\s+/);
}
function da(e3) {
  return e3.classList || new yu(e3);
}
function yu(e3) {
  this._node = e3, this._names = xu(e3.getAttribute("class") || "");
}
yu.prototype = {
  add: function(e3) {
    var t = this._names.indexOf(e3);
    t < 0 && (this._names.push(e3), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e3) {
    var t = this._names.indexOf(e3);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e3) {
    return this._names.indexOf(e3) >= 0;
  }
};
function bu(e3, t) {
  for (var n = da(e3), r = -1, i = t.length; ++r < i; ) n.add(t[r]);
}
function _u(e3, t) {
  for (var n = da(e3), r = -1, i = t.length; ++r < i; ) n.remove(t[r]);
}
function ym(e3) {
  return function() {
    bu(this, e3);
  };
}
function bm(e3) {
  return function() {
    _u(this, e3);
  };
}
function _m(e3, t) {
  return function() {
    (t.apply(this, arguments) ? bu : _u)(this, e3);
  };
}
function Sm(e3, t) {
  var n = xu(e3 + "");
  if (arguments.length < 2) {
    for (var r = da(this.node()), i = -1, o = n.length; ++i < o; ) if (!r.contains(n[i])) return false;
    return true;
  }
  return this.each((typeof t == "function" ? _m : t ? ym : bm)(n, t));
}
function wm() {
  this.textContent = "";
}
function Tm(e3) {
  return function() {
    this.textContent = e3;
  };
}
function Am(e3) {
  return function() {
    var t = e3.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function Em(e3) {
  return arguments.length ? this.each(e3 == null ? wm : (typeof e3 == "function" ? Am : Tm)(e3)) : this.node().textContent;
}
function Pm() {
  this.innerHTML = "";
}
function Cm(e3) {
  return function() {
    this.innerHTML = e3;
  };
}
function km(e3) {
  return function() {
    var t = e3.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function Fm(e3) {
  return arguments.length ? this.each(e3 == null ? Pm : (typeof e3 == "function" ? km : Cm)(e3)) : this.node().innerHTML;
}
function Lm() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function zm() {
  return this.each(Lm);
}
function Im() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function Rm() {
  return this.each(Im);
}
function Dm(e3) {
  var t = typeof e3 == "function" ? e3 : hu(e3);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function Mm() {
  return null;
}
function Om(e3, t) {
  var n = typeof e3 == "function" ? e3 : hu(e3), r = t == null ? Mm : typeof t == "function" ? t : ha(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function Nm() {
  var e3 = this.parentNode;
  e3 && e3.removeChild(this);
}
function Gm() {
  return this.each(Nm);
}
function Bm() {
  var e3 = this.cloneNode(false), t = this.parentNode;
  return t ? t.insertBefore(e3, this.nextSibling) : e3;
}
function Vm() {
  var e3 = this.cloneNode(true), t = this.parentNode;
  return t ? t.insertBefore(e3, this.nextSibling) : e3;
}
function $m(e3) {
  return this.select(e3 ? Vm : Bm);
}
function jm(e3) {
  return arguments.length ? this.property("__data__", e3) : this.node().__data__;
}
function Um(e3) {
  return function(t) {
    e3.call(this, t, this.__data__);
  };
}
function Xm(e3) {
  return e3.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function Hm(e3) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, i = t.length, o; n < i; ++n)
        o = t[n], (!e3.type || o.type === e3.type) && o.name === e3.name ? this.removeEventListener(o.type, o.listener, o.options) : t[++r] = o;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function Wm(e3, t, n) {
  return function() {
    var r = this.__on, i, o = Um(t);
    if (r) {
      for (var f = 0, s = r.length; f < s; ++f)
        if ((i = r[f]).type === e3.type && i.name === e3.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = o, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e3.type, o, n), i = { type: e3.type, name: e3.name, value: t, listener: o, options: n }, r ? r.push(i) : this.__on = [i];
  };
}
function qm(e3, t, n) {
  var r = Xm(e3 + ""), i, o = r.length, f;
  if (arguments.length < 2) {
    var s = this.node().__on;
    if (s) {
      for (var u = 0, l = s.length, v; u < l; ++u)
        for (i = 0, v = s[u]; i < o; ++i)
          if ((f = r[i]).type === v.type && f.name === v.name)
            return v.value;
    }
    return;
  }
  for (s = t ? Wm : Hm, i = 0; i < o; ++i) this.each(s(r[i], t, n));
  return this;
}
function Su(e3, t, n) {
  var r = gu(e3), i = r.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = r.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, false, false)), e3.dispatchEvent(i);
}
function Ym(e3, t) {
  return function() {
    return Su(this, e3, t);
  };
}
function Zm(e3, t) {
  return function() {
    return Su(this, e3, t.apply(this, arguments));
  };
}
function Qm(e3, t) {
  return this.each((typeof t == "function" ? Zm : Ym)(e3, t));
}
function* Km() {
  for (var e3 = this._groups, t = 0, n = e3.length; t < n; ++t)
    for (var r = e3[t], i = 0, o = r.length, f; i < o; ++i)
      (f = r[i]) && (yield f);
}
var wu = [null];
function Nt(e3, t) {
  this._groups = e3, this._parents = t;
}
function Gr() {
  return new Nt([[document.documentElement]], wu);
}
function Jm() {
  return this;
}
Nt.prototype = Gr.prototype = {
  constructor: Nt,
  select: Ad,
  selectAll: kd,
  selectChild: Id,
  selectChildren: Od,
  filter: Nd,
  data: Ud,
  enter: Gd,
  exit: Hd,
  join: Wd,
  merge: qd,
  selection: Jm,
  order: Yd,
  sort: Zd,
  call: Kd,
  nodes: Jd,
  node: em,
  size: tm,
  empty: nm,
  each: rm,
  attr: cm,
  style: mm,
  property: xm,
  classed: Sm,
  text: Em,
  html: Fm,
  raise: zm,
  lower: Rm,
  append: Dm,
  insert: Om,
  remove: Gm,
  clone: $m,
  datum: jm,
  on: qm,
  dispatch: Qm,
  [Symbol.iterator]: Km
};
function St(e3) {
  return typeof e3 == "string" ? new Nt([[document.querySelector(e3)]], [document.documentElement]) : new Nt([[e3]], wu);
}
function ep(e3) {
  let t;
  for (; t = e3.sourceEvent; ) e3 = t;
  return e3;
}
function un(e3, t) {
  if (e3 = ep(e3), t === void 0 && (t = e3.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e3.clientX, r.y = e3.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect();
      return [e3.clientX - i.left - t.clientLeft, e3.clientY - i.top - t.clientTop];
    }
  }
  return [e3.pageX, e3.pageY];
}
var tp = { value: () => {
} };
function $i() {
  for (var e3 = 0, t = arguments.length, n = {}, r; e3 < t; ++e3) {
    if (!(r = arguments[e3] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new Pi(n);
}
function Pi(e3) {
  this._ = e3;
}
function np(e3, t) {
  return e3.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
Pi.prototype = $i.prototype = {
  constructor: Pi,
  on: function(e3, t) {
    var n = this._, r = np(e3 + "", n), i, o = -1, f = r.length;
    if (arguments.length < 2) {
      for (; ++o < f; ) if ((i = (e3 = r[o]).type) && (i = rp(n[i], e3.name))) return i;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++o < f; )
      if (i = (e3 = r[o]).type) n[i] = Df(n[i], e3.name, t);
      else if (t == null) for (i in n) n[i] = Df(n[i], e3.name, null);
    return this;
  },
  copy: function() {
    var e3 = {}, t = this._;
    for (var n in t) e3[n] = t[n].slice();
    return new Pi(e3);
  },
  call: function(e3, t) {
    if ((i = arguments.length - 2) > 0) for (var n = new Array(i), r = 0, i, o; r < i; ++r) n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e3)) throw new Error("unknown type: " + e3);
    for (o = this._[e3], r = 0, i = o.length; r < i; ++r) o[r].value.apply(t, n);
  },
  apply: function(e3, t, n) {
    if (!this._.hasOwnProperty(e3)) throw new Error("unknown type: " + e3);
    for (var r = this._[e3], i = 0, o = r.length; i < o; ++i) r[i].value.apply(t, n);
  }
};
function rp(e3, t) {
  for (var n = 0, r = e3.length, i; n < r; ++n)
    if ((i = e3[n]).name === t)
      return i.value;
}
function Df(e3, t, n) {
  for (var r = 0, i = e3.length; r < i; ++r)
    if (e3[r].name === t) {
      e3[r] = tp, e3 = e3.slice(0, r).concat(e3.slice(r + 1));
      break;
    }
  return n != null && e3.push({ name: t, value: n }), e3;
}
var fr = 0;
var zr = 0;
var Fr = 0;
var Tu = 1e3;
var Ii;
var Ir;
var Ri = 0;
var Vn = 0;
var ji = 0;
var Dr = typeof performance == "object" && performance.now ? performance : Date;
var Au = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e3) {
  setTimeout(e3, 17);
};
function ma() {
  return Vn || (Au(ip), Vn = Dr.now() + ji);
}
function ip() {
  Vn = 0;
}
function Di() {
  this._call = this._time = this._next = null;
}
Di.prototype = Eu.prototype = {
  constructor: Di,
  restart: function(e3, t, n) {
    if (typeof e3 != "function") throw new TypeError("callback is not a function");
    n = (n == null ? ma() : +n) + (t == null ? 0 : +t), !this._next && Ir !== this && (Ir ? Ir._next = this : Ii = this, Ir = this), this._call = e3, this._time = n, Zo();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Zo());
  }
};
function Eu(e3, t, n) {
  var r = new Di();
  return r.restart(e3, t, n), r;
}
function op() {
  ma(), ++fr;
  for (var e3 = Ii, t; e3; )
    (t = Vn - e3._time) >= 0 && e3._call.call(null, t), e3 = e3._next;
  --fr;
}
function Mf() {
  Vn = (Ri = Dr.now()) + ji, fr = zr = 0;
  try {
    op();
  } finally {
    fr = 0, sp(), Vn = 0;
  }
}
function ap() {
  var e3 = Dr.now(), t = e3 - Ri;
  t > Tu && (ji -= t, Ri = e3);
}
function sp() {
  for (var e3, t = Ii, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e3 = t, t = t._next) : (n = t._next, t._next = null, t = e3 ? e3._next = n : Ii = n);
  Ir = e3, Zo(r);
}
function Zo(e3) {
  if (!fr) {
    zr && (zr = clearTimeout(zr));
    var t = e3 - Vn;
    t > 24 ? (e3 < 1 / 0 && (zr = setTimeout(Mf, e3 - Dr.now() - ji)), Fr && (Fr = clearInterval(Fr))) : (Fr || (Ri = Dr.now(), Fr = setInterval(ap, Tu)), fr = 1, Au(Mf));
  }
}
function Of(e3, t, n) {
  var r = new Di();
  return t = t == null ? 0 : +t, r.restart((i) => {
    r.stop(), e3(i + t);
  }, t, n), r;
}
var fp = $i("start", "end", "cancel", "interrupt");
var up = [];
var Pu = 0;
var Nf = 1;
var Qo = 2;
var Ci = 3;
var Gf = 4;
var Ko = 5;
var ki = 6;
function Ui(e3, t, n, r, i, o) {
  var f = e3.__transition;
  if (!f) e3.__transition = {};
  else if (n in f) return;
  cp(e3, n, {
    name: t,
    index: r,
    // For context during callback.
    group: i,
    // For context during callback.
    on: fp,
    tween: up,
    time: o.time,
    delay: o.delay,
    duration: o.duration,
    ease: o.ease,
    timer: null,
    state: Pu
  });
}
function pa(e3, t) {
  var n = Yt(e3, t);
  if (n.state > Pu) throw new Error("too late; already scheduled");
  return n;
}
function rn(e3, t) {
  var n = Yt(e3, t);
  if (n.state > Ci) throw new Error("too late; already running");
  return n;
}
function Yt(e3, t) {
  var n = e3.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function cp(e3, t, n) {
  var r = e3.__transition, i;
  r[t] = n, n.timer = Eu(o, 0, n.time);
  function o(l) {
    n.state = Nf, n.timer.restart(f, n.delay, n.time), n.delay <= l && f(l - n.delay);
  }
  function f(l) {
    var v, b, S, M;
    if (n.state !== Nf) return u();
    for (v in r)
      if (M = r[v], M.name === n.name) {
        if (M.state === Ci) return Of(f);
        M.state === Gf ? (M.state = ki, M.timer.stop(), M.on.call("interrupt", e3, e3.__data__, M.index, M.group), delete r[v]) : +v < t && (M.state = ki, M.timer.stop(), M.on.call("cancel", e3, e3.__data__, M.index, M.group), delete r[v]);
      }
    if (Of(function() {
      n.state === Ci && (n.state = Gf, n.timer.restart(s, n.delay, n.time), s(l));
    }), n.state = Qo, n.on.call("start", e3, e3.__data__, n.index, n.group), n.state === Qo) {
      for (n.state = Ci, i = new Array(S = n.tween.length), v = 0, b = -1; v < S; ++v)
        (M = n.tween[v].value.call(e3, e3.__data__, n.index, n.group)) && (i[++b] = M);
      i.length = b + 1;
    }
  }
  function s(l) {
    for (var v = l < n.duration ? n.ease.call(null, l / n.duration) : (n.timer.restart(u), n.state = Ko, 1), b = -1, S = i.length; ++b < S; )
      i[b].call(e3, v);
    n.state === Ko && (n.on.call("end", e3, e3.__data__, n.index, n.group), u());
  }
  function u() {
    n.state = ki, n.timer.stop(), delete r[t];
    for (var l in r) return;
    delete e3.__transition;
  }
}
function Fi(e3, t) {
  var n = e3.__transition, r, i, o = true, f;
  if (n) {
    t = t == null ? null : t + "";
    for (f in n) {
      if ((r = n[f]).name !== t) {
        o = false;
        continue;
      }
      i = r.state > Qo && r.state < Ko, r.state = ki, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", e3, e3.__data__, r.index, r.group), delete n[f];
    }
    o && delete e3.__transition;
  }
}
function lp(e3) {
  return this.each(function() {
    Fi(this, e3);
  });
}
function va(e3, t, n) {
  e3.prototype = t.prototype = n, n.constructor = e3;
}
function Cu(e3, t) {
  var n = Object.create(e3.prototype);
  for (var r in t) n[r] = t[r];
  return n;
}
function Br() {
}
var Mr = 0.7;
var Mi = 1 / Mr;
var or = "\\s*([+-]?\\d+)\\s*";
var Or = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var nn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var hp = /^#([0-9a-f]{3,8})$/;
var dp = new RegExp(`^rgb\\(${or},${or},${or}\\)$`);
var mp = new RegExp(`^rgb\\(${nn},${nn},${nn}\\)$`);
var pp = new RegExp(`^rgba\\(${or},${or},${or},${Or}\\)$`);
var vp = new RegExp(`^rgba\\(${nn},${nn},${nn},${Or}\\)$`);
var gp = new RegExp(`^hsl\\(${Or},${nn},${nn}\\)$`);
var xp = new RegExp(`^hsla\\(${Or},${nn},${nn},${Or}\\)$`);
var Bf = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
va(Br, Sn, {
  copy(e3) {
    return Object.assign(new this.constructor(), this, e3);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Vf,
  // Deprecated! Use color.formatHex.
  formatHex: Vf,
  formatHex8: yp,
  formatHsl: bp,
  formatRgb: $f,
  toString: $f
});
function Vf() {
  return this.rgb().formatHex();
}
function yp() {
  return this.rgb().formatHex8();
}
function bp() {
  return ku(this).formatHsl();
}
function $f() {
  return this.rgb().formatRgb();
}
function Sn(e3) {
  var t, n;
  return e3 = (e3 + "").trim().toLowerCase(), (t = hp.exec(e3)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? jf(t) : n === 3 ? new Ft(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? bi(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? bi(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = dp.exec(e3)) ? new Ft(t[1], t[2], t[3], 1) : (t = mp.exec(e3)) ? new Ft(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = pp.exec(e3)) ? bi(t[1], t[2], t[3], t[4]) : (t = vp.exec(e3)) ? bi(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = gp.exec(e3)) ? Hf(t[1], t[2] / 100, t[3] / 100, 1) : (t = xp.exec(e3)) ? Hf(t[1], t[2] / 100, t[3] / 100, t[4]) : Bf.hasOwnProperty(e3) ? jf(Bf[e3]) : e3 === "transparent" ? new Ft(NaN, NaN, NaN, 0) : null;
}
function jf(e3) {
  return new Ft(e3 >> 16 & 255, e3 >> 8 & 255, e3 & 255, 1);
}
function bi(e3, t, n, r) {
  return r <= 0 && (e3 = t = n = NaN), new Ft(e3, t, n, r);
}
function _p(e3) {
  return e3 instanceof Br || (e3 = Sn(e3)), e3 ? (e3 = e3.rgb(), new Ft(e3.r, e3.g, e3.b, e3.opacity)) : new Ft();
}
function Jo(e3, t, n, r) {
  return arguments.length === 1 ? _p(e3) : new Ft(e3, t, n, r ?? 1);
}
function Ft(e3, t, n, r) {
  this.r = +e3, this.g = +t, this.b = +n, this.opacity = +r;
}
va(Ft, Jo, Cu(Br, {
  brighter(e3) {
    return e3 = e3 == null ? Mi : Math.pow(Mi, e3), new Ft(this.r * e3, this.g * e3, this.b * e3, this.opacity);
  },
  darker(e3) {
    return e3 = e3 == null ? Mr : Math.pow(Mr, e3), new Ft(this.r * e3, this.g * e3, this.b * e3, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Ft(Gn(this.r), Gn(this.g), Gn(this.b), Oi(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Uf,
  // Deprecated! Use color.formatHex.
  formatHex: Uf,
  formatHex8: Sp,
  formatRgb: Xf,
  toString: Xf
}));
function Uf() {
  return `#${Nn(this.r)}${Nn(this.g)}${Nn(this.b)}`;
}
function Sp() {
  return `#${Nn(this.r)}${Nn(this.g)}${Nn(this.b)}${Nn((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Xf() {
  const e3 = Oi(this.opacity);
  return `${e3 === 1 ? "rgb(" : "rgba("}${Gn(this.r)}, ${Gn(this.g)}, ${Gn(this.b)}${e3 === 1 ? ")" : `, ${e3})`}`;
}
function Oi(e3) {
  return isNaN(e3) ? 1 : Math.max(0, Math.min(1, e3));
}
function Gn(e3) {
  return Math.max(0, Math.min(255, Math.round(e3) || 0));
}
function Nn(e3) {
  return e3 = Gn(e3), (e3 < 16 ? "0" : "") + e3.toString(16);
}
function Hf(e3, t, n, r) {
  return r <= 0 ? e3 = t = n = NaN : n <= 0 || n >= 1 ? e3 = t = NaN : t <= 0 && (e3 = NaN), new Wt(e3, t, n, r);
}
function ku(e3) {
  if (e3 instanceof Wt) return new Wt(e3.h, e3.s, e3.l, e3.opacity);
  if (e3 instanceof Br || (e3 = Sn(e3)), !e3) return new Wt();
  if (e3 instanceof Wt) return e3;
  e3 = e3.rgb();
  var t = e3.r / 255, n = e3.g / 255, r = e3.b / 255, i = Math.min(t, n, r), o = Math.max(t, n, r), f = NaN, s = o - i, u = (o + i) / 2;
  return s ? (t === o ? f = (n - r) / s + (n < r) * 6 : n === o ? f = (r - t) / s + 2 : f = (t - n) / s + 4, s /= u < 0.5 ? o + i : 2 - o - i, f *= 60) : s = u > 0 && u < 1 ? 0 : f, new Wt(f, s, u, e3.opacity);
}
function wp(e3, t, n, r) {
  return arguments.length === 1 ? ku(e3) : new Wt(e3, t, n, r ?? 1);
}
function Wt(e3, t, n, r) {
  this.h = +e3, this.s = +t, this.l = +n, this.opacity = +r;
}
va(Wt, wp, Cu(Br, {
  brighter(e3) {
    return e3 = e3 == null ? Mi : Math.pow(Mi, e3), new Wt(this.h, this.s, this.l * e3, this.opacity);
  },
  darker(e3) {
    return e3 = e3 == null ? Mr : Math.pow(Mr, e3), new Wt(this.h, this.s, this.l * e3, this.opacity);
  },
  rgb() {
    var e3 = this.h % 360 + (this.h < 0) * 360, t = isNaN(e3) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;
    return new Ft(
      Uo(e3 >= 240 ? e3 - 240 : e3 + 120, i, r),
      Uo(e3, i, r),
      Uo(e3 < 120 ? e3 + 240 : e3 - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new Wt(Wf(this.h), _i(this.s), _i(this.l), Oi(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e3 = Oi(this.opacity);
    return `${e3 === 1 ? "hsl(" : "hsla("}${Wf(this.h)}, ${_i(this.s) * 100}%, ${_i(this.l) * 100}%${e3 === 1 ? ")" : `, ${e3})`}`;
  }
}));
function Wf(e3) {
  return e3 = (e3 || 0) % 360, e3 < 0 ? e3 + 360 : e3;
}
function _i(e3) {
  return Math.max(0, Math.min(1, e3 || 0));
}
function Uo(e3, t, n) {
  return (e3 < 60 ? t + (n - t) * e3 / 60 : e3 < 180 ? n : e3 < 240 ? t + (n - t) * (240 - e3) / 60 : t) * 255;
}
var ga = (e3) => () => e3;
function Tp(e3, t) {
  return function(n) {
    return e3 + n * t;
  };
}
function Ap(e3, t, n) {
  return e3 = Math.pow(e3, n), t = Math.pow(t, n) - e3, n = 1 / n, function(r) {
    return Math.pow(e3 + r * t, n);
  };
}
function Ep(e3) {
  return (e3 = +e3) == 1 ? Fu : function(t, n) {
    return n - t ? Ap(t, n, e3) : ga(isNaN(t) ? n : t);
  };
}
function Fu(e3, t) {
  var n = t - e3;
  return n ? Tp(e3, n) : ga(isNaN(e3) ? t : e3);
}
var Ni = function e(t) {
  var n = Ep(t);
  function r(i, o) {
    var f = n((i = Jo(i)).r, (o = Jo(o)).r), s = n(i.g, o.g), u = n(i.b, o.b), l = Fu(i.opacity, o.opacity);
    return function(v) {
      return i.r = f(v), i.g = s(v), i.b = u(v), i.opacity = l(v), i + "";
    };
  }
  return r.gamma = e, r;
}(1);
function Pp(e3, t) {
  t || (t = []);
  var n = e3 ? Math.min(t.length, e3.length) : 0, r = t.slice(), i;
  return function(o) {
    for (i = 0; i < n; ++i) r[i] = e3[i] * (1 - o) + t[i] * o;
    return r;
  };
}
function Cp(e3) {
  return ArrayBuffer.isView(e3) && !(e3 instanceof DataView);
}
function kp(e3, t) {
  var n = t ? t.length : 0, r = e3 ? Math.min(n, e3.length) : 0, i = new Array(r), o = new Array(n), f;
  for (f = 0; f < r; ++f) i[f] = xa(e3[f], t[f]);
  for (; f < n; ++f) o[f] = t[f];
  return function(s) {
    for (f = 0; f < r; ++f) o[f] = i[f](s);
    return o;
  };
}
function Fp(e3, t) {
  var n = /* @__PURE__ */ new Date();
  return e3 = +e3, t = +t, function(r) {
    return n.setTime(e3 * (1 - r) + t * r), n;
  };
}
function Ht(e3, t) {
  return e3 = +e3, t = +t, function(n) {
    return e3 * (1 - n) + t * n;
  };
}
function Lp(e3, t) {
  var n = {}, r = {}, i;
  (e3 === null || typeof e3 != "object") && (e3 = {}), (t === null || typeof t != "object") && (t = {});
  for (i in t)
    i in e3 ? n[i] = xa(e3[i], t[i]) : r[i] = t[i];
  return function(o) {
    for (i in n) r[i] = n[i](o);
    return r;
  };
}
var ea = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var Xo = new RegExp(ea.source, "g");
function zp(e3) {
  return function() {
    return e3;
  };
}
function Ip(e3) {
  return function(t) {
    return e3(t) + "";
  };
}
function Lu(e3, t) {
  var n = ea.lastIndex = Xo.lastIndex = 0, r, i, o, f = -1, s = [], u = [];
  for (e3 = e3 + "", t = t + ""; (r = ea.exec(e3)) && (i = Xo.exec(t)); )
    (o = i.index) > n && (o = t.slice(n, o), s[f] ? s[f] += o : s[++f] = o), (r = r[0]) === (i = i[0]) ? s[f] ? s[f] += i : s[++f] = i : (s[++f] = null, u.push({ i: f, x: Ht(r, i) })), n = Xo.lastIndex;
  return n < t.length && (o = t.slice(n), s[f] ? s[f] += o : s[++f] = o), s.length < 2 ? u[0] ? Ip(u[0].x) : zp(t) : (t = u.length, function(l) {
    for (var v = 0, b; v < t; ++v) s[(b = u[v]).i] = b.x(l);
    return s.join("");
  });
}
function xa(e3, t) {
  var n = typeof t, r;
  return t == null || n === "boolean" ? ga(t) : (n === "number" ? Ht : n === "string" ? (r = Sn(t)) ? (t = r, Ni) : Lu : t instanceof Sn ? Ni : t instanceof Date ? Fp : Cp(t) ? Pp : Array.isArray(t) ? kp : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? Lp : Ht)(e3, t);
}
function Rp(e3, t) {
  return e3 = +e3, t = +t, function(n) {
    return Math.round(e3 * (1 - n) + t * n);
  };
}
var qf = 180 / Math.PI;
var ta = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function zu(e3, t, n, r, i, o) {
  var f, s, u;
  return (f = Math.sqrt(e3 * e3 + t * t)) && (e3 /= f, t /= f), (u = e3 * n + t * r) && (n -= e3 * u, r -= t * u), (s = Math.sqrt(n * n + r * r)) && (n /= s, r /= s, u /= s), e3 * r < t * n && (e3 = -e3, t = -t, u = -u, f = -f), {
    translateX: i,
    translateY: o,
    rotate: Math.atan2(t, e3) * qf,
    skewX: Math.atan(u) * qf,
    scaleX: f,
    scaleY: s
  };
}
var Si;
function Dp(e3) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e3 + "");
  return t.isIdentity ? ta : zu(t.a, t.b, t.c, t.d, t.e, t.f);
}
function Mp(e3) {
  return e3 == null || (Si || (Si = document.createElementNS("http://www.w3.org/2000/svg", "g")), Si.setAttribute("transform", e3), !(e3 = Si.transform.baseVal.consolidate())) ? ta : (e3 = e3.matrix, zu(e3.a, e3.b, e3.c, e3.d, e3.e, e3.f));
}
function Iu(e3, t, n, r) {
  function i(l) {
    return l.length ? l.pop() + " " : "";
  }
  function o(l, v, b, S, M, K) {
    if (l !== b || v !== S) {
      var we = M.push("translate(", null, t, null, n);
      K.push({ i: we - 4, x: Ht(l, b) }, { i: we - 2, x: Ht(v, S) });
    } else (b || S) && M.push("translate(" + b + t + S + n);
  }
  function f(l, v, b, S) {
    l !== v ? (l - v > 180 ? v += 360 : v - l > 180 && (l += 360), S.push({ i: b.push(i(b) + "rotate(", null, r) - 2, x: Ht(l, v) })) : v && b.push(i(b) + "rotate(" + v + r);
  }
  function s(l, v, b, S) {
    l !== v ? S.push({ i: b.push(i(b) + "skewX(", null, r) - 2, x: Ht(l, v) }) : v && b.push(i(b) + "skewX(" + v + r);
  }
  function u(l, v, b, S, M, K) {
    if (l !== b || v !== S) {
      var we = M.push(i(M) + "scale(", null, ",", null, ")");
      K.push({ i: we - 4, x: Ht(l, b) }, { i: we - 2, x: Ht(v, S) });
    } else (b !== 1 || S !== 1) && M.push(i(M) + "scale(" + b + "," + S + ")");
  }
  return function(l, v) {
    var b = [], S = [];
    return l = e3(l), v = e3(v), o(l.translateX, l.translateY, v.translateX, v.translateY, b, S), f(l.rotate, v.rotate, b, S), s(l.skewX, v.skewX, b, S), u(l.scaleX, l.scaleY, v.scaleX, v.scaleY, b, S), l = v = null, function(M) {
      for (var K = -1, we = S.length, ke; ++K < we; ) b[(ke = S[K]).i] = ke.x(M);
      return b.join("");
    };
  };
}
var Op = Iu(Dp, "px, ", "px)", "deg)");
var Np = Iu(Mp, ", ", ")", ")");
var Gp = 1e-12;
function Yf(e3) {
  return ((e3 = Math.exp(e3)) + 1 / e3) / 2;
}
function Bp(e3) {
  return ((e3 = Math.exp(e3)) - 1 / e3) / 2;
}
function Vp(e3) {
  return ((e3 = Math.exp(2 * e3)) - 1) / (e3 + 1);
}
var $p = function e2(t, n, r) {
  function i(o, f) {
    var s = o[0], u = o[1], l = o[2], v = f[0], b = f[1], S = f[2], M = v - s, K = b - u, we = M * M + K * K, ke, ae;
    if (we < Gp)
      ae = Math.log(S / l) / t, ke = function(Ge) {
        return [
          s + Ge * M,
          u + Ge * K,
          l * Math.exp(t * Ge * ae)
        ];
      };
    else {
      var Ne = Math.sqrt(we), je = (S * S - l * l + r * we) / (2 * l * n * Ne), q = (S * S - l * l - r * we) / (2 * S * n * Ne), pe = Math.log(Math.sqrt(je * je + 1) - je), De = Math.log(Math.sqrt(q * q + 1) - q);
      ae = (De - pe) / t, ke = function(Ge) {
        var qe = Ge * ae, et = Yf(pe), rt = l / (n * Ne) * (et * Vp(t * qe + pe) - Bp(pe));
        return [
          s + rt * M,
          u + rt * K,
          l * et / Yf(t * qe + pe)
        ];
      };
    }
    return ke.duration = ae * 1e3 * t / Math.SQRT2, ke;
  }
  return i.rho = function(o) {
    var f = Math.max(1e-3, +o), s = f * f, u = s * s;
    return e2(f, s, u);
  }, i;
}(Math.SQRT2, 2, 4);
function jp(e3, t) {
  var n, r;
  return function() {
    var i = rn(this, e3), o = i.tween;
    if (o !== n) {
      r = n = o;
      for (var f = 0, s = r.length; f < s; ++f)
        if (r[f].name === t) {
          r = r.slice(), r.splice(f, 1);
          break;
        }
    }
    i.tween = r;
  };
}
function Up(e3, t, n) {
  var r, i;
  if (typeof n != "function") throw new Error();
  return function() {
    var o = rn(this, e3), f = o.tween;
    if (f !== r) {
      i = (r = f).slice();
      for (var s = { name: t, value: n }, u = 0, l = i.length; u < l; ++u)
        if (i[u].name === t) {
          i[u] = s;
          break;
        }
      u === l && i.push(s);
    }
    o.tween = i;
  };
}
function Xp(e3, t) {
  var n = this._id;
  if (e3 += "", arguments.length < 2) {
    for (var r = Yt(this.node(), n).tween, i = 0, o = r.length, f; i < o; ++i)
      if ((f = r[i]).name === e3)
        return f.value;
    return null;
  }
  return this.each((t == null ? jp : Up)(n, e3, t));
}
function ya(e3, t, n) {
  var r = e3._id;
  return e3.each(function() {
    var i = rn(this, r);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return Yt(i, r).value[t];
  };
}
function Ru(e3, t) {
  var n;
  return (typeof t == "number" ? Ht : t instanceof Sn ? Ni : (n = Sn(t)) ? (t = n, Ni) : Lu)(e3, t);
}
function Hp(e3) {
  return function() {
    this.removeAttribute(e3);
  };
}
function Wp(e3) {
  return function() {
    this.removeAttributeNS(e3.space, e3.local);
  };
}
function qp(e3, t, n) {
  var r, i = n + "", o;
  return function() {
    var f = this.getAttribute(e3);
    return f === i ? null : f === r ? o : o = t(r = f, n);
  };
}
function Yp(e3, t, n) {
  var r, i = n + "", o;
  return function() {
    var f = this.getAttributeNS(e3.space, e3.local);
    return f === i ? null : f === r ? o : o = t(r = f, n);
  };
}
function Zp(e3, t, n) {
  var r, i, o;
  return function() {
    var f, s = n(this), u;
    return s == null ? void this.removeAttribute(e3) : (f = this.getAttribute(e3), u = s + "", f === u ? null : f === r && u === i ? o : (i = u, o = t(r = f, s)));
  };
}
function Qp(e3, t, n) {
  var r, i, o;
  return function() {
    var f, s = n(this), u;
    return s == null ? void this.removeAttributeNS(e3.space, e3.local) : (f = this.getAttributeNS(e3.space, e3.local), u = s + "", f === u ? null : f === r && u === i ? o : (i = u, o = t(r = f, s)));
  };
}
function Kp(e3, t) {
  var n = Vi(e3), r = n === "transform" ? Np : Ru;
  return this.attrTween(e3, typeof t == "function" ? (n.local ? Qp : Zp)(n, r, ya(this, "attr." + e3, t)) : t == null ? (n.local ? Wp : Hp)(n) : (n.local ? Yp : qp)(n, r, t));
}
function Jp(e3, t) {
  return function(n) {
    this.setAttribute(e3, t.call(this, n));
  };
}
function e0(e3, t) {
  return function(n) {
    this.setAttributeNS(e3.space, e3.local, t.call(this, n));
  };
}
function t0(e3, t) {
  var n, r;
  function i() {
    var o = t.apply(this, arguments);
    return o !== r && (n = (r = o) && e0(e3, o)), n;
  }
  return i._value = t, i;
}
function n0(e3, t) {
  var n, r;
  function i() {
    var o = t.apply(this, arguments);
    return o !== r && (n = (r = o) && Jp(e3, o)), n;
  }
  return i._value = t, i;
}
function r0(e3, t) {
  var n = "attr." + e3;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var r = Vi(e3);
  return this.tween(n, (r.local ? t0 : n0)(r, t));
}
function i0(e3, t) {
  return function() {
    pa(this, e3).delay = +t.apply(this, arguments);
  };
}
function o0(e3, t) {
  return t = +t, function() {
    pa(this, e3).delay = t;
  };
}
function a0(e3) {
  var t = this._id;
  return arguments.length ? this.each((typeof e3 == "function" ? i0 : o0)(t, e3)) : Yt(this.node(), t).delay;
}
function s0(e3, t) {
  return function() {
    rn(this, e3).duration = +t.apply(this, arguments);
  };
}
function f0(e3, t) {
  return t = +t, function() {
    rn(this, e3).duration = t;
  };
}
function u0(e3) {
  var t = this._id;
  return arguments.length ? this.each((typeof e3 == "function" ? s0 : f0)(t, e3)) : Yt(this.node(), t).duration;
}
function c0(e3, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    rn(this, e3).ease = t;
  };
}
function l0(e3) {
  var t = this._id;
  return arguments.length ? this.each(c0(t, e3)) : Yt(this.node(), t).ease;
}
function h0(e3, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    rn(this, e3).ease = n;
  };
}
function d0(e3) {
  if (typeof e3 != "function") throw new Error();
  return this.each(h0(this._id, e3));
}
function m0(e3) {
  typeof e3 != "function" && (e3 = mu(e3));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], f = o.length, s = r[i] = [], u, l = 0; l < f; ++l)
      (u = o[l]) && e3.call(u, u.__data__, l, o) && s.push(u);
  return new ln(r, this._parents, this._name, this._id);
}
function p0(e3) {
  if (e3._id !== this._id) throw new Error();
  for (var t = this._groups, n = e3._groups, r = t.length, i = n.length, o = Math.min(r, i), f = new Array(r), s = 0; s < o; ++s)
    for (var u = t[s], l = n[s], v = u.length, b = f[s] = new Array(v), S, M = 0; M < v; ++M)
      (S = u[M] || l[M]) && (b[M] = S);
  for (; s < r; ++s)
    f[s] = t[s];
  return new ln(f, this._parents, this._name, this._id);
}
function v0(e3) {
  return (e3 + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function g0(e3, t, n) {
  var r, i, o = v0(t) ? pa : rn;
  return function() {
    var f = o(this, e3), s = f.on;
    s !== r && (i = (r = s).copy()).on(t, n), f.on = i;
  };
}
function x0(e3, t) {
  var n = this._id;
  return arguments.length < 2 ? Yt(this.node(), n).on.on(e3) : this.each(g0(n, e3, t));
}
function y0(e3) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e3) return;
    t && t.removeChild(this);
  };
}
function b0() {
  return this.on("end.remove", y0(this._id));
}
function _0(e3) {
  var t = this._name, n = this._id;
  typeof e3 != "function" && (e3 = ha(e3));
  for (var r = this._groups, i = r.length, o = new Array(i), f = 0; f < i; ++f)
    for (var s = r[f], u = s.length, l = o[f] = new Array(u), v, b, S = 0; S < u; ++S)
      (v = s[S]) && (b = e3.call(v, v.__data__, S, s)) && ("__data__" in v && (b.__data__ = v.__data__), l[S] = b, Ui(l[S], t, n, S, l, Yt(v, n)));
  return new ln(o, this._parents, t, n);
}
function S0(e3) {
  var t = this._name, n = this._id;
  typeof e3 != "function" && (e3 = du(e3));
  for (var r = this._groups, i = r.length, o = [], f = [], s = 0; s < i; ++s)
    for (var u = r[s], l = u.length, v, b = 0; b < l; ++b)
      if (v = u[b]) {
        for (var S = e3.call(v, v.__data__, b, u), M, K = Yt(v, n), we = 0, ke = S.length; we < ke; ++we)
          (M = S[we]) && Ui(M, t, n, we, S, K);
        o.push(S), f.push(v);
      }
  return new ln(o, f, t, n);
}
var w0 = Gr.prototype.constructor;
function T0() {
  return new w0(this._groups, this._parents);
}
function A0(e3, t) {
  var n, r, i;
  return function() {
    var o = sr(this, e3), f = (this.style.removeProperty(e3), sr(this, e3));
    return o === f ? null : o === n && f === r ? i : i = t(n = o, r = f);
  };
}
function Du(e3) {
  return function() {
    this.style.removeProperty(e3);
  };
}
function E0(e3, t, n) {
  var r, i = n + "", o;
  return function() {
    var f = sr(this, e3);
    return f === i ? null : f === r ? o : o = t(r = f, n);
  };
}
function P0(e3, t, n) {
  var r, i, o;
  return function() {
    var f = sr(this, e3), s = n(this), u = s + "";
    return s == null && (u = s = (this.style.removeProperty(e3), sr(this, e3))), f === u ? null : f === r && u === i ? o : (i = u, o = t(r = f, s));
  };
}
function C0(e3, t) {
  var n, r, i, o = "style." + t, f = "end." + o, s;
  return function() {
    var u = rn(this, e3), l = u.on, v = u.value[o] == null ? s || (s = Du(t)) : void 0;
    (l !== n || i !== v) && (r = (n = l).copy()).on(f, i = v), u.on = r;
  };
}
function k0(e3, t, n) {
  var r = (e3 += "") == "transform" ? Op : Ru;
  return t == null ? this.styleTween(e3, A0(e3, r)).on("end.style." + e3, Du(e3)) : typeof t == "function" ? this.styleTween(e3, P0(e3, r, ya(this, "style." + e3, t))).each(C0(this._id, e3)) : this.styleTween(e3, E0(e3, r, t), n).on("end.style." + e3, null);
}
function F0(e3, t, n) {
  return function(r) {
    this.style.setProperty(e3, t.call(this, r), n);
  };
}
function L0(e3, t, n) {
  var r, i;
  function o() {
    var f = t.apply(this, arguments);
    return f !== i && (r = (i = f) && F0(e3, f, n)), r;
  }
  return o._value = t, o;
}
function z0(e3, t, n) {
  var r = "style." + (e3 += "");
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (t == null) return this.tween(r, null);
  if (typeof t != "function") throw new Error();
  return this.tween(r, L0(e3, t, n ?? ""));
}
function I0(e3) {
  return function() {
    this.textContent = e3;
  };
}
function R0(e3) {
  return function() {
    var t = e3(this);
    this.textContent = t ?? "";
  };
}
function D0(e3) {
  return this.tween("text", typeof e3 == "function" ? R0(ya(this, "text", e3)) : I0(e3 == null ? "" : e3 + ""));
}
function M0(e3) {
  return function(t) {
    this.textContent = e3.call(this, t);
  };
}
function O0(e3) {
  var t, n;
  function r() {
    var i = e3.apply(this, arguments);
    return i !== n && (t = (n = i) && M0(i)), t;
  }
  return r._value = e3, r;
}
function N0(e3) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e3 == null) return this.tween(t, null);
  if (typeof e3 != "function") throw new Error();
  return this.tween(t, O0(e3));
}
function G0() {
  for (var e3 = this._name, t = this._id, n = Mu(), r = this._groups, i = r.length, o = 0; o < i; ++o)
    for (var f = r[o], s = f.length, u, l = 0; l < s; ++l)
      if (u = f[l]) {
        var v = Yt(u, t);
        Ui(u, e3, n, l, f, {
          time: v.time + v.delay + v.duration,
          delay: 0,
          duration: v.duration,
          ease: v.ease
        });
      }
  return new ln(r, this._parents, e3, n);
}
function B0() {
  var e3, t, n = this, r = n._id, i = n.size();
  return new Promise(function(o, f) {
    var s = { value: f }, u = { value: function() {
      --i === 0 && o();
    } };
    n.each(function() {
      var l = rn(this, r), v = l.on;
      v !== e3 && (t = (e3 = v).copy(), t._.cancel.push(s), t._.interrupt.push(s), t._.end.push(u)), l.on = t;
    }), i === 0 && o();
  });
}
var V0 = 0;
function ln(e3, t, n, r) {
  this._groups = e3, this._parents = t, this._name = n, this._id = r;
}
function Mu() {
  return ++V0;
}
var fn = Gr.prototype;
ln.prototype = {
  constructor: ln,
  select: _0,
  selectAll: S0,
  selectChild: fn.selectChild,
  selectChildren: fn.selectChildren,
  filter: m0,
  merge: p0,
  selection: T0,
  transition: G0,
  call: fn.call,
  nodes: fn.nodes,
  node: fn.node,
  size: fn.size,
  empty: fn.empty,
  each: fn.each,
  on: x0,
  attr: Kp,
  attrTween: r0,
  style: k0,
  styleTween: z0,
  text: D0,
  textTween: N0,
  remove: b0,
  tween: Xp,
  delay: a0,
  duration: u0,
  ease: l0,
  easeVarying: d0,
  end: B0,
  [Symbol.iterator]: fn[Symbol.iterator]
};
function $0(e3) {
  return e3 * e3;
}
function j0(e3) {
  return e3 * (2 - e3);
}
function U0(e3) {
  return ((e3 *= 2) <= 1 ? e3 * e3 : --e3 * (2 - e3) + 1) / 2;
}
function X0(e3) {
  return ((e3 *= 2) <= 1 ? e3 * e3 * e3 : (e3 -= 2) * e3 * e3 + 2) / 2;
}
var H0 = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: X0
};
function W0(e3, t) {
  for (var n; !(n = e3.__transition) || !(n = n[t]); )
    if (!(e3 = e3.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function q0(e3) {
  var t, n;
  e3 instanceof ln ? (t = e3._id, e3 = e3._name) : (t = Mu(), (n = H0).time = ma(), e3 = e3 == null ? null : e3 + "");
  for (var r = this._groups, i = r.length, o = 0; o < i; ++o)
    for (var f = r[o], s = f.length, u, l = 0; l < s; ++l)
      (u = f[l]) && Ui(u, e3, t, l, f, n || W0(u, t));
  return new ln(r, this._parents, e3, t);
}
Gr.prototype.interrupt = lp;
Gr.prototype.transition = q0;
var hn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ba(e3) {
  return e3 && e3.__esModule && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
}
function Y0(e3) {
  if (e3.__esModule) return e3;
  var t = e3.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: true }), Object.keys(e3).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e3, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: true,
      get: function() {
        return e3[r];
      }
    });
  }), n;
}
var Ou = { exports: {} };
(function(e3, t) {
  (function(n, r) {
    e3.exports = r();
  })(hn, function() {
    var n = function(a) {
      return a instanceof Uint8Array || a instanceof Uint16Array || a instanceof Uint32Array || a instanceof Int8Array || a instanceof Int16Array || a instanceof Int32Array || a instanceof Float32Array || a instanceof Float64Array || a instanceof Uint8ClampedArray;
    }, r = function(a, h) {
      for (var _ = Object.keys(h), R = 0; R < _.length; ++R)
        a[_[R]] = h[_[R]];
      return a;
    }, i = `
`;
    function o(a) {
      return typeof atob < "u" ? atob(a) : "base64:" + a;
    }
    function f(a) {
      var h = new Error("(regl) " + a);
      throw console.error(h), h;
    }
    function s(a, h) {
      a || f(h);
    }
    function u(a) {
      return a ? ": " + a : "";
    }
    function l(a, h, _) {
      a in h || f("unknown parameter (" + a + ")" + u(_) + ". possible values: " + Object.keys(h).join());
    }
    function v(a, h) {
      n(a) || f(
        "invalid parameter type" + u(h) + ". must be a typed array"
      );
    }
    function b(a, h) {
      switch (h) {
        case "number":
          return typeof a == "number";
        case "object":
          return typeof a == "object";
        case "string":
          return typeof a == "string";
        case "boolean":
          return typeof a == "boolean";
        case "function":
          return typeof a == "function";
        case "undefined":
          return typeof a > "u";
        case "symbol":
          return typeof a == "symbol";
      }
    }
    function S(a, h, _) {
      b(a, h) || f(
        "invalid parameter type" + u(_) + ". expected " + h + ", got " + typeof a
      );
    }
    function M(a, h) {
      a >= 0 && (a | 0) === a || f("invalid parameter type, (" + a + ")" + u(h) + ". must be a nonnegative integer");
    }
    function K(a, h, _) {
      h.indexOf(a) < 0 && f("invalid value" + u(_) + ". must be one of: " + h);
    }
    var we = [
      "gl",
      "canvas",
      "container",
      "attributes",
      "pixelRatio",
      "extensions",
      "optionalExtensions",
      "profile",
      "onDone"
    ];
    function ke(a) {
      Object.keys(a).forEach(function(h) {
        we.indexOf(h) < 0 && f('invalid regl constructor argument "' + h + '". must be one of ' + we);
      });
    }
    function ae(a, h) {
      for (a = a + ""; a.length < h; )
        a = " " + a;
      return a;
    }
    function Ne() {
      this.name = "unknown", this.lines = [], this.index = {}, this.hasErrors = false;
    }
    function je(a, h) {
      this.number = a, this.line = h, this.errors = [];
    }
    function q(a, h, _) {
      this.file = a, this.line = h, this.message = _;
    }
    function pe() {
      var a = new Error(), h = (a.stack || a).toString(), _ = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(h);
      if (_)
        return _[1];
      var R = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(h);
      return R ? R[1] : "unknown";
    }
    function De() {
      var a = new Error(), h = (a.stack || a).toString(), _ = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(h);
      if (_)
        return _[1];
      var R = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(h);
      return R ? R[1] : "unknown";
    }
    function Ge(a, h) {
      var _ = a.split(`
`), R = 1, j = 0, I = {
        unknown: new Ne(),
        0: new Ne()
      };
      I.unknown.name = I[0].name = h || pe(), I.unknown.lines.push(new je(0, ""));
      for (var G = 0; G < _.length; ++G) {
        var Z = _[G], Y = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(Z);
        if (Y)
          switch (Y[1]) {
            case "line":
              var ne = /(\d+)(\s+\d+)?/.exec(Y[2]);
              ne && (R = ne[1] | 0, ne[2] && (j = ne[2] | 0, j in I || (I[j] = new Ne())));
              break;
            case "define":
              var ie = /SHADER_NAME(_B64)?\s+(.*)$/.exec(Y[2]);
              ie && (I[j].name = ie[1] ? o(ie[2]) : ie[2]);
              break;
          }
        I[j].lines.push(new je(R++, Z));
      }
      return Object.keys(I).forEach(function(re) {
        var fe = I[re];
        fe.lines.forEach(function(Q) {
          fe.index[Q.number] = Q;
        });
      }), I;
    }
    function qe(a) {
      var h = [];
      return a.split(`
`).forEach(function(_) {
        if (!(_.length < 5)) {
          var R = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(_);
          R ? h.push(new q(
            R[1] | 0,
            R[2] | 0,
            R[3].trim()
          )) : _.length > 0 && h.push(new q("unknown", 0, _));
        }
      }), h;
    }
    function et(a, h) {
      h.forEach(function(_) {
        var R = a[_.file];
        if (R) {
          var j = R.index[_.line];
          if (j) {
            j.errors.push(_), R.hasErrors = true;
            return;
          }
        }
        a.unknown.hasErrors = true, a.unknown.lines[0].errors.push(_);
      });
    }
    function rt(a, h, _, R, j) {
      if (!a.getShaderParameter(h, a.COMPILE_STATUS)) {
        var I = a.getShaderInfoLog(h), G = R === a.FRAGMENT_SHADER ? "fragment" : "vertex";
        Pe(_, "string", G + " shader source must be a string", j);
        var Z = Ge(_, j), Y = qe(I);
        et(Z, Y), Object.keys(Z).forEach(function(ne) {
          var ie = Z[ne];
          if (!ie.hasErrors)
            return;
          var re = [""], fe = [""];
          function Q(te, C) {
            re.push(te), fe.push(C || "");
          }
          Q("file number " + ne + ": " + ie.name + `
`, "color:red;text-decoration:underline;font-weight:bold"), ie.lines.forEach(function(te) {
            if (te.errors.length > 0) {
              Q(ae(te.number, 4) + "|  ", "background-color:yellow; font-weight:bold"), Q(te.line + i, "color:red; background-color:yellow; font-weight:bold");
              var C = 0;
              te.errors.forEach(function(O) {
                var ee = O.message, ge = /^\s*'(.*)'\s*:\s*(.*)$/.exec(ee);
                if (ge) {
                  var W = ge[1];
                  switch (ee = ge[2], W) {
                    case "assign":
                      W = "=";
                      break;
                  }
                  C = Math.max(te.line.indexOf(W, C), 0);
                } else
                  C = 0;
                Q(ae("| ", 6)), Q(ae("^^^", C + 3) + i, "font-weight:bold"), Q(ae("| ", 6)), Q(ee + i, "font-weight:bold");
              }), Q(ae("| ", 6) + i);
            } else
              Q(ae(te.number, 4) + "|  "), Q(te.line + i, "color:red");
          }), typeof document < "u" && !window.chrome ? (fe[0] = re.join("%c"), console.log.apply(console, fe)) : console.log(re.join(""));
        }), s.raise("Error compiling " + G + " shader, " + Z[0].name);
      }
    }
    function ze(a, h, _, R, j) {
      if (!a.getProgramParameter(h, a.LINK_STATUS)) {
        var I = a.getProgramInfoLog(h), G = Ge(_, j), Z = Ge(R, j), Y = 'Error linking program with vertex shader, "' + Z[0].name + '", and fragment shader "' + G[0].name + '"';
        typeof document < "u" ? console.log(
          "%c" + Y + i + "%c" + I,
          "color:red;text-decoration:underline;font-weight:bold",
          "color:red"
        ) : console.log(Y + i + I), s.raise(Y);
      }
    }
    function st(a) {
      a._commandRef = pe();
    }
    function tt(a, h, _, R) {
      st(a);
      function j(Y) {
        return Y ? R.id(Y) : 0;
      }
      a._fragId = j(a.static.frag), a._vertId = j(a.static.vert);
      function I(Y, ne) {
        Object.keys(ne).forEach(function(ie) {
          Y[R.id(ie)] = true;
        });
      }
      var G = a._uniformSet = {};
      I(G, h.static), I(G, h.dynamic);
      var Z = a._attributeSet = {};
      I(Z, _.static), I(Z, _.dynamic), a._hasCount = "count" in a.static || "count" in a.dynamic || "elements" in a.static || "elements" in a.dynamic;
    }
    function N(a, h) {
      var _ = De();
      f(a + " in command " + (h || pe()) + (_ === "unknown" ? "" : " called from " + _));
    }
    function Te(a, h, _) {
      a || N(h, _ || pe());
    }
    function oe(a, h, _, R) {
      a in h || N(
        "unknown parameter (" + a + ")" + u(_) + ". possible values: " + Object.keys(h).join(),
        R || pe()
      );
    }
    function Pe(a, h, _, R) {
      b(a, h) || N(
        "invalid parameter type" + u(_) + ". expected " + h + ", got " + typeof a,
        R || pe()
      );
    }
    function $e(a) {
      a();
    }
    function Be(a, h, _) {
      a.texture ? K(
        a.texture._texture.internalformat,
        h,
        "unsupported texture format for attachment"
      ) : K(
        a.renderbuffer._renderbuffer.format,
        _,
        "unsupported renderbuffer format for attachment"
      );
    }
    var Ye = 33071, nt = 9728, ut = 9984, Gt = 9985, bt = 9986, Lt = 9987, $t = 5120, zt = 5121, jt = 5122, lr = 5123, rc = 5124, ic = 5125, ka = 5126, Fa = 32819, La = 32820, za = 33635, Ia = 34042, oc = 36193, It = {};
    It[$t] = It[zt] = 1, It[jt] = It[lr] = It[oc] = It[za] = It[Fa] = It[La] = 2, It[rc] = It[ic] = It[ka] = It[Ia] = 4;
    function Ra(a, h) {
      return a === La || a === Fa || a === za ? 2 : a === Ia ? 4 : It[a] * h;
    }
    function Vr(a) {
      return !(a & a - 1) && !!a;
    }
    function ac(a, h, _) {
      var R, j = h.width, I = h.height, G = h.channels;
      s(
        j > 0 && j <= _.maxTextureSize && I > 0 && I <= _.maxTextureSize,
        "invalid texture shape"
      ), (a.wrapS !== Ye || a.wrapT !== Ye) && s(
        Vr(j) && Vr(I),
        "incompatible wrap mode for texture, both width and height must be power of 2"
      ), h.mipmask === 1 ? j !== 1 && I !== 1 && s(
        a.minFilter !== ut && a.minFilter !== bt && a.minFilter !== Gt && a.minFilter !== Lt,
        "min filter requires mipmap"
      ) : (s(
        Vr(j) && Vr(I),
        "texture must be a square power of 2 to support mipmapping"
      ), s(
        h.mipmask === (j << 1) - 1,
        "missing or incomplete mipmap data"
      )), h.type === ka && (_.extensions.indexOf("oes_texture_float_linear") < 0 && s(
        a.minFilter === nt && a.magFilter === nt,
        "filter not supported, must enable oes_texture_float_linear"
      ), s(
        !a.genMipmaps,
        "mipmap generation not supported with float textures"
      ));
      var Z = h.images;
      for (R = 0; R < 16; ++R)
        if (Z[R]) {
          var Y = j >> R, ne = I >> R;
          s(h.mipmask & 1 << R, "missing mipmap data");
          var ie = Z[R];
          if (s(
            ie.width === Y && ie.height === ne,
            "invalid shape for mip images"
          ), s(
            ie.format === h.format && ie.internalformat === h.internalformat && ie.type === h.type,
            "incompatible type for mip image"
          ), !ie.compressed) if (ie.data) {
            var re = Math.ceil(Ra(ie.type, G) * Y / ie.unpackAlignment) * ie.unpackAlignment;
            s(
              ie.data.byteLength === re * ne,
              "invalid data for image, buffer size is inconsistent with image format"
            );
          } else ie.element || ie.copy;
        } else a.genMipmaps || s((h.mipmask & 1 << R) === 0, "extra mipmap data");
      h.compressed && s(
        !a.genMipmaps,
        "mipmap generation for compressed images not supported"
      );
    }
    function sc(a, h, _, R) {
      var j = a.width, I = a.height, G = a.channels;
      s(
        j > 0 && j <= R.maxTextureSize && I > 0 && I <= R.maxTextureSize,
        "invalid texture shape"
      ), s(
        j === I,
        "cube map must be square"
      ), s(
        h.wrapS === Ye && h.wrapT === Ye,
        "wrap mode not supported by cube map"
      );
      for (var Z = 0; Z < _.length; ++Z) {
        var Y = _[Z];
        s(
          Y.width === j && Y.height === I,
          "inconsistent cube map face shape"
        ), h.genMipmaps && (s(
          !Y.compressed,
          "can not generate mipmap for compressed textures"
        ), s(
          Y.mipmask === 1,
          "can not specify mipmaps and generate mipmaps"
        ));
        for (var ne = Y.images, ie = 0; ie < 16; ++ie) {
          var re = ne[ie];
          if (re) {
            var fe = j >> ie, Q = I >> ie;
            s(Y.mipmask & 1 << ie, "missing mipmap data"), s(
              re.width === fe && re.height === Q,
              "invalid shape for mip images"
            ), s(
              re.format === a.format && re.internalformat === a.internalformat && re.type === a.type,
              "incompatible type for mip image"
            ), re.compressed || (re.data ? s(
              re.data.byteLength === fe * Q * Math.max(Ra(re.type, G), re.unpackAlignment),
              "invalid data for image, buffer size is inconsistent with image format"
            ) : re.element || re.copy);
          }
        }
      }
    }
    var d = r(s, {
      optional: $e,
      raise: f,
      commandRaise: N,
      command: Te,
      parameter: l,
      commandParameter: oe,
      constructor: ke,
      type: S,
      commandType: Pe,
      isTypedArray: v,
      nni: M,
      oneOf: K,
      shaderError: rt,
      linkError: ze,
      callSite: De,
      saveCommandRef: st,
      saveDrawInfo: tt,
      framebufferFormat: Be,
      guessCommand: pe,
      texture2D: ac,
      textureCube: sc
    }), fc = 0, uc = 0, cc = 5, lc = 6;
    function wn(a, h) {
      this.id = fc++, this.type = a, this.data = h;
    }
    function Da(a) {
      return a.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    }
    function hr(a) {
      if (a.length === 0)
        return [];
      var h = a.charAt(0), _ = a.charAt(a.length - 1);
      if (a.length > 1 && h === _ && (h === '"' || h === "'"))
        return ['"' + Da(a.substr(1, a.length - 2)) + '"'];
      var R = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(a);
      if (R)
        return hr(a.substr(0, R.index)).concat(hr(R[1])).concat(hr(a.substr(R.index + R[0].length)));
      var j = a.split(".");
      if (j.length === 1)
        return ['"' + Da(a) + '"'];
      for (var I = [], G = 0; G < j.length; ++G)
        I = I.concat(hr(j[G]));
      return I;
    }
    function Ma(a) {
      return "[" + hr(a).join("][") + "]";
    }
    function hc(a, h) {
      return new wn(a, Ma(h + ""));
    }
    function dc(a) {
      return typeof a == "function" && !a._reglType || a instanceof wn;
    }
    function Oa(a, h) {
      if (typeof a == "function")
        return new wn(uc, a);
      if (typeof a == "number" || typeof a == "boolean")
        return new wn(cc, a);
      if (Array.isArray(a))
        return new wn(lc, a.map(function(_, R) {
          return Oa(_, h + "[" + R + "]");
        }));
      if (a instanceof wn)
        return a;
      d(false, "invalid option type in uniform " + h);
    }
    var Rt = {
      DynamicVariable: wn,
      define: hc,
      isDynamic: dc,
      unbox: Oa,
      accessor: Ma
    }, Hi = {
      next: typeof requestAnimationFrame == "function" ? function(a) {
        return requestAnimationFrame(a);
      } : function(a) {
        return setTimeout(a, 16);
      },
      cancel: typeof cancelAnimationFrame == "function" ? function(a) {
        return cancelAnimationFrame(a);
      } : clearTimeout
    }, Na = typeof performance < "u" && performance.now ? function() {
      return performance.now();
    } : function() {
      return +/* @__PURE__ */ new Date();
    };
    function mc() {
      var a = { "": 0 }, h = [""];
      return {
        id: function(_) {
          var R = a[_];
          return R || (R = a[_] = h.length, h.push(_), R);
        },
        str: function(_) {
          return h[_];
        }
      };
    }
    function pc(a, h, _) {
      var R = document.createElement("canvas");
      r(R.style, {
        border: 0,
        margin: 0,
        padding: 0,
        top: 0,
        left: 0,
        width: "100%",
        height: "100%"
      }), a.appendChild(R), a === document.body && (R.style.position = "absolute", r(a.style, {
        margin: 0,
        padding: 0
      }));
      function j() {
        var Z = window.innerWidth, Y = window.innerHeight;
        if (a !== document.body) {
          var ne = R.getBoundingClientRect();
          Z = ne.right - ne.left, Y = ne.bottom - ne.top;
        }
        R.width = _ * Z, R.height = _ * Y;
      }
      var I;
      a !== document.body && typeof ResizeObserver == "function" ? (I = new ResizeObserver(function() {
        setTimeout(j);
      }), I.observe(a)) : window.addEventListener("resize", j, false);
      function G() {
        I ? I.disconnect() : window.removeEventListener("resize", j), a.removeChild(R);
      }
      return j(), {
        canvas: R,
        onDestroy: G
      };
    }
    function vc(a, h) {
      function _(R) {
        try {
          return a.getContext(R, h);
        } catch {
          return null;
        }
      }
      return _("webgl") || _("experimental-webgl") || _("webgl-experimental");
    }
    function gc(a) {
      return typeof a.nodeName == "string" && typeof a.appendChild == "function" && typeof a.getBoundingClientRect == "function";
    }
    function xc(a) {
      return typeof a.drawArrays == "function" || typeof a.drawElements == "function";
    }
    function Ga(a) {
      return typeof a == "string" ? a.split() : (d(Array.isArray(a), "invalid extension array"), a);
    }
    function Ba(a) {
      return typeof a == "string" ? (d(typeof document < "u", "not supported outside of DOM"), document.querySelector(a)) : a;
    }
    function yc(a) {
      var h = a || {}, _, R, j, I, G = {}, Z = [], Y = [], ne = typeof window > "u" ? 1 : window.devicePixelRatio, ie = false, re = function(te) {
        te && d.raise(te);
      }, fe = function() {
      };
      if (typeof h == "string" ? (d(
        typeof document < "u",
        "selector queries only supported in DOM enviroments"
      ), _ = document.querySelector(h), d(_, "invalid query string for element")) : typeof h == "object" ? gc(h) ? _ = h : xc(h) ? (I = h, j = I.canvas) : (d.constructor(h), "gl" in h ? I = h.gl : "canvas" in h ? j = Ba(h.canvas) : "container" in h && (R = Ba(h.container)), "attributes" in h && (G = h.attributes, d.type(G, "object", "invalid context attributes")), "extensions" in h && (Z = Ga(h.extensions)), "optionalExtensions" in h && (Y = Ga(h.optionalExtensions)), "onDone" in h && (d.type(
        h.onDone,
        "function",
        "invalid or missing onDone callback"
      ), re = h.onDone), "profile" in h && (ie = !!h.profile), "pixelRatio" in h && (ne = +h.pixelRatio, d(ne > 0, "invalid pixel ratio"))) : d.raise("invalid arguments to regl"), _ && (_.nodeName.toLowerCase() === "canvas" ? j = _ : R = _), !I) {
        if (!j) {
          d(
            typeof document < "u",
            "must manually specify webgl context outside of DOM environments"
          );
          var Q = pc(R || document.body, re, ne);
          if (!Q)
            return null;
          j = Q.canvas, fe = Q.onDestroy;
        }
        G.premultipliedAlpha === void 0 && (G.premultipliedAlpha = true), I = vc(j, G);
      }
      return I ? {
        gl: I,
        canvas: j,
        container: R,
        extensions: Z,
        optionalExtensions: Y,
        pixelRatio: ne,
        profile: ie,
        onDone: re,
        onDestroy: fe
      } : (fe(), re("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org"), null);
    }
    function bc(a, h) {
      var _ = {};
      function R(G) {
        d.type(G, "string", "extension name must be string");
        var Z = G.toLowerCase(), Y;
        try {
          Y = _[Z] = a.getExtension(Z);
        } catch {
        }
        return !!Y;
      }
      for (var j = 0; j < h.extensions.length; ++j) {
        var I = h.extensions[j];
        if (!R(I))
          return h.onDestroy(), h.onDone('"' + I + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser'), null;
      }
      return h.optionalExtensions.forEach(R), {
        extensions: _,
        restore: function() {
          Object.keys(_).forEach(function(G) {
            if (_[G] && !R(G))
              throw new Error("(regl): error restoring extension " + G);
          });
        }
      };
    }
    function Dt(a, h) {
      for (var _ = Array(a), R = 0; R < a; ++R)
        _[R] = h(R);
      return _;
    }
    var _c = 5120, Sc = 5121, wc = 5122, Tc = 5123, Ac = 5124, Ec = 5125, Pc = 5126;
    function Cc(a) {
      for (var h = 16; h <= 1 << 28; h *= 16)
        if (a <= h)
          return h;
      return 0;
    }
    function Va(a) {
      var h, _;
      return h = (a > 65535) << 4, a >>>= h, _ = (a > 255) << 3, a >>>= _, h |= _, _ = (a > 15) << 2, a >>>= _, h |= _, _ = (a > 3) << 1, a >>>= _, h |= _, h | a >> 1;
    }
    function $a() {
      var a = Dt(8, function() {
        return [];
      });
      function h(I) {
        var G = Cc(I), Z = a[Va(G) >> 2];
        return Z.length > 0 ? Z.pop() : new ArrayBuffer(G);
      }
      function _(I) {
        a[Va(I.byteLength) >> 2].push(I);
      }
      function R(I, G) {
        var Z = null;
        switch (I) {
          case _c:
            Z = new Int8Array(h(G), 0, G);
            break;
          case Sc:
            Z = new Uint8Array(h(G), 0, G);
            break;
          case wc:
            Z = new Int16Array(h(2 * G), 0, G);
            break;
          case Tc:
            Z = new Uint16Array(h(2 * G), 0, G);
            break;
          case Ac:
            Z = new Int32Array(h(4 * G), 0, G);
            break;
          case Ec:
            Z = new Uint32Array(h(4 * G), 0, G);
            break;
          case Pc:
            Z = new Float32Array(h(4 * G), 0, G);
            break;
          default:
            return null;
        }
        return Z.length !== G ? Z.subarray(0, G) : Z;
      }
      function j(I) {
        _(I.buffer);
      }
      return {
        alloc: h,
        free: _,
        allocType: R,
        freeType: j
      };
    }
    var ht = $a();
    ht.zero = $a();
    var kc = 3408, Fc = 3410, Lc = 3411, zc = 3412, Ic = 3413, Rc = 3414, Dc = 3415, Mc = 33901, Oc = 33902, Nc = 3379, Gc = 3386, Bc = 34921, Vc = 36347, $c = 36348, jc = 35661, Uc = 35660, Xc = 34930, Hc = 36349, Wc = 34076, qc = 34024, Yc = 7936, Zc = 7937, Qc = 7938, Kc = 35724, Jc = 34047, el = 36063, tl = 34852, $r = 3553, ja = 34067, nl = 34069, rl = 33984, dr = 6408, Wi = 5126, Ua = 5121, qi = 36160, il = 36053, ol = 36064, al = 16384, sl = function(a, h) {
      var _ = 1;
      h.ext_texture_filter_anisotropic && (_ = a.getParameter(Jc));
      var R = 1, j = 1;
      h.webgl_draw_buffers && (R = a.getParameter(tl), j = a.getParameter(el));
      var I = !!h.oes_texture_float;
      if (I) {
        var G = a.createTexture();
        a.bindTexture($r, G), a.texImage2D($r, 0, dr, 1, 1, 0, dr, Wi, null);
        var Z = a.createFramebuffer();
        if (a.bindFramebuffer(qi, Z), a.framebufferTexture2D(qi, ol, $r, G, 0), a.bindTexture($r, null), a.checkFramebufferStatus(qi) !== il) I = false;
        else {
          a.viewport(0, 0, 1, 1), a.clearColor(1, 0, 0, 1), a.clear(al);
          var Y = ht.allocType(Wi, 4);
          a.readPixels(0, 0, 1, 1, dr, Wi, Y), a.getError() ? I = false : (a.deleteFramebuffer(Z), a.deleteTexture(G), I = Y[0] === 1), ht.freeType(Y);
        }
      }
      var ne = typeof navigator < "u" && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent)), ie = true;
      if (!ne) {
        var re = a.createTexture(), fe = ht.allocType(Ua, 36);
        a.activeTexture(rl), a.bindTexture(ja, re), a.texImage2D(nl, 0, dr, 3, 3, 0, dr, Ua, fe), ht.freeType(fe), a.bindTexture(ja, null), a.deleteTexture(re), ie = !a.getError();
      }
      return {
        // drawing buffer bit depth
        colorBits: [
          a.getParameter(Fc),
          a.getParameter(Lc),
          a.getParameter(zc),
          a.getParameter(Ic)
        ],
        depthBits: a.getParameter(Rc),
        stencilBits: a.getParameter(Dc),
        subpixelBits: a.getParameter(kc),
        // supported extensions
        extensions: Object.keys(h).filter(function(Q) {
          return !!h[Q];
        }),
        // max aniso samples
        maxAnisotropic: _,
        // max draw buffers
        maxDrawbuffers: R,
        maxColorAttachments: j,
        // point and line size ranges
        pointSizeDims: a.getParameter(Mc),
        lineWidthDims: a.getParameter(Oc),
        maxViewportDims: a.getParameter(Gc),
        maxCombinedTextureUnits: a.getParameter(jc),
        maxCubeMapSize: a.getParameter(Wc),
        maxRenderbufferSize: a.getParameter(qc),
        maxTextureUnits: a.getParameter(Xc),
        maxTextureSize: a.getParameter(Nc),
        maxAttributes: a.getParameter(Bc),
        maxVertexUniforms: a.getParameter(Vc),
        maxVertexTextureUnits: a.getParameter(Uc),
        maxVaryingVectors: a.getParameter($c),
        maxFragmentUniforms: a.getParameter(Hc),
        // vendor info
        glsl: a.getParameter(Kc),
        renderer: a.getParameter(Zc),
        vendor: a.getParameter(Yc),
        version: a.getParameter(Qc),
        // quirks
        readFloat: I,
        npotTextureCube: ie
      };
    };
    function Ut(a) {
      return !!a && typeof a == "object" && Array.isArray(a.shape) && Array.isArray(a.stride) && typeof a.offset == "number" && a.shape.length === a.stride.length && (Array.isArray(a.data) || n(a.data));
    }
    var Mt = function(a) {
      return Object.keys(a).map(function(h) {
        return a[h];
      });
    }, jr = {
      shape: ll,
      flatten: cl
    };
    function fl(a, h, _) {
      for (var R = 0; R < h; ++R)
        _[R] = a[R];
    }
    function ul(a, h, _, R) {
      for (var j = 0, I = 0; I < h; ++I)
        for (var G = a[I], Z = 0; Z < _; ++Z)
          R[j++] = G[Z];
    }
    function Xa(a, h, _, R, j, I) {
      for (var G = I, Z = 0; Z < h; ++Z)
        for (var Y = a[Z], ne = 0; ne < _; ++ne)
          for (var ie = Y[ne], re = 0; re < R; ++re)
            j[G++] = ie[re];
    }
    function Ha(a, h, _, R, j) {
      for (var I = 1, G = _ + 1; G < h.length; ++G)
        I *= h[G];
      var Z = h[_];
      if (h.length - _ === 4) {
        var Y = h[_ + 1], ne = h[_ + 2], ie = h[_ + 3];
        for (G = 0; G < Z; ++G)
          Xa(a[G], Y, ne, ie, R, j), j += I;
      } else
        for (G = 0; G < Z; ++G)
          Ha(a[G], h, _ + 1, R, j), j += I;
    }
    function cl(a, h, _, R) {
      var j = 1;
      if (h.length)
        for (var I = 0; I < h.length; ++I)
          j *= h[I];
      else
        j = 0;
      var G = R || ht.allocType(_, j);
      switch (h.length) {
        case 0:
          break;
        case 1:
          fl(a, h[0], G);
          break;
        case 2:
          ul(a, h[0], h[1], G);
          break;
        case 3:
          Xa(a, h[0], h[1], h[2], G, 0);
          break;
        default:
          Ha(a, h, 0, G, 0);
      }
      return G;
    }
    function ll(a) {
      for (var h = [], _ = a; _.length; _ = _[0])
        h.push(_.length);
      return h;
    }
    var Yi = {
      "[object Int8Array]": 5120,
      "[object Int16Array]": 5122,
      "[object Int32Array]": 5124,
      "[object Uint8Array]": 5121,
      "[object Uint8ClampedArray]": 5121,
      "[object Uint16Array]": 5123,
      "[object Uint32Array]": 5125,
      "[object Float32Array]": 5126,
      "[object Float64Array]": 5121,
      "[object ArrayBuffer]": 5121
    }, hl = 5120, dl = 5122, ml = 5124, pl = 5121, vl = 5123, gl = 5125, xl = 5126, yl = 5126, Tn = {
      int8: hl,
      int16: dl,
      int32: ml,
      uint8: pl,
      uint16: vl,
      uint32: gl,
      float: xl,
      float32: yl
    }, bl = 35048, _l = 35040, Ur = {
      dynamic: bl,
      stream: _l,
      static: 35044
    }, Zi = jr.flatten, Wa = jr.shape, qa = 35044, Sl = 35040, Qi = 5121, Ki = 5126, mn = [];
    mn[5120] = 1, mn[5122] = 2, mn[5124] = 4, mn[5121] = 1, mn[5123] = 2, mn[5125] = 4, mn[5126] = 4;
    function Xr(a) {
      return Yi[Object.prototype.toString.call(a)] | 0;
    }
    function Ya(a, h) {
      for (var _ = 0; _ < h.length; ++_)
        a[_] = h[_];
    }
    function Za(a, h, _, R, j, I, G) {
      for (var Z = 0, Y = 0; Y < _; ++Y)
        for (var ne = 0; ne < R; ++ne)
          a[Z++] = h[j * Y + I * ne + G];
    }
    function wl(a, h, _, R) {
      var j = 0, I = {};
      function G(C) {
        this.id = j++, this.buffer = a.createBuffer(), this.type = C, this.usage = qa, this.byteLength = 0, this.dimension = 1, this.dtype = Qi, this.persistentData = null, _.profile && (this.stats = { size: 0 });
      }
      G.prototype.bind = function() {
        a.bindBuffer(this.type, this.buffer);
      }, G.prototype.destroy = function() {
        fe(this);
      };
      var Z = [];
      function Y(C, O) {
        var ee = Z.pop();
        return ee || (ee = new G(C)), ee.bind(), re(ee, O, Sl, 0, 1, false), ee;
      }
      function ne(C) {
        Z.push(C);
      }
      function ie(C, O, ee) {
        C.byteLength = O.byteLength, a.bufferData(C.type, O, ee);
      }
      function re(C, O, ee, ge, W, me) {
        var he;
        if (C.usage = ee, Array.isArray(O)) {
          if (C.dtype = ge || Ki, O.length > 0) {
            var Ee;
            if (Array.isArray(O[0])) {
              he = Wa(O);
              for (var U = 1, $ = 1; $ < he.length; ++$)
                U *= he[$];
              C.dimension = U, Ee = Zi(O, he, C.dtype), ie(C, Ee, ee), me ? C.persistentData = Ee : ht.freeType(Ee);
            } else if (typeof O[0] == "number") {
              C.dimension = W;
              var be = ht.allocType(C.dtype, O.length);
              Ya(be, O), ie(C, be, ee), me ? C.persistentData = be : ht.freeType(be);
            } else n(O[0]) ? (C.dimension = O[0].length, C.dtype = ge || Xr(O[0]) || Ki, Ee = Zi(
              O,
              [O.length, O[0].length],
              C.dtype
            ), ie(C, Ee, ee), me ? C.persistentData = Ee : ht.freeType(Ee)) : d.raise("invalid buffer data");
          }
        } else if (n(O))
          C.dtype = ge || Xr(O), C.dimension = W, ie(C, O, ee), me && (C.persistentData = new Uint8Array(new Uint8Array(O.buffer)));
        else if (Ut(O)) {
          he = O.shape;
          var ue = O.stride, J = O.offset, ce = 0, le = 0, Me = 0, Re = 0;
          he.length === 1 ? (ce = he[0], le = 1, Me = ue[0], Re = 0) : he.length === 2 ? (ce = he[0], le = he[1], Me = ue[0], Re = ue[1]) : d.raise("invalid shape"), C.dtype = ge || Xr(O.data) || Ki, C.dimension = le;
          var de = ht.allocType(C.dtype, ce * le);
          Za(
            de,
            O.data,
            ce,
            le,
            Me,
            Re,
            J
          ), ie(C, de, ee), me ? C.persistentData = de : ht.freeType(de);
        } else O instanceof ArrayBuffer ? (C.dtype = Qi, C.dimension = W, ie(C, O, ee), me && (C.persistentData = new Uint8Array(new Uint8Array(O)))) : d.raise("invalid buffer data");
      }
      function fe(C) {
        h.bufferCount--, R(C);
        var O = C.buffer;
        d(O, "buffer must not be deleted already"), a.deleteBuffer(O), C.buffer = null, delete I[C.id];
      }
      function Q(C, O, ee, ge) {
        h.bufferCount++;
        var W = new G(O);
        I[W.id] = W;
        function me(U) {
          var $ = qa, be = null, ue = 0, J = 0, ce = 1;
          return Array.isArray(U) || n(U) || Ut(U) || U instanceof ArrayBuffer ? be = U : typeof U == "number" ? ue = U | 0 : U && (d.type(
            U,
            "object",
            "buffer arguments must be an object, a number or an array"
          ), "data" in U && (d(
            be === null || Array.isArray(be) || n(be) || Ut(be),
            "invalid data for buffer"
          ), be = U.data), "usage" in U && (d.parameter(U.usage, Ur, "invalid buffer usage"), $ = Ur[U.usage]), "type" in U && (d.parameter(U.type, Tn, "invalid buffer type"), J = Tn[U.type]), "dimension" in U && (d.type(U.dimension, "number", "invalid dimension"), ce = U.dimension | 0), "length" in U && (d.nni(ue, "buffer length must be a nonnegative integer"), ue = U.length | 0)), W.bind(), be ? re(W, be, $, J, ce, ge) : (ue && a.bufferData(W.type, ue, $), W.dtype = J || Qi, W.usage = $, W.dimension = ce, W.byteLength = ue), _.profile && (W.stats.size = W.byteLength * mn[W.dtype]), me;
        }
        function he(U, $) {
          d(
            $ + U.byteLength <= W.byteLength,
            "invalid buffer subdata call, buffer is too small.  Can't write data of size " + U.byteLength + " starting from offset " + $ + " to a buffer of size " + W.byteLength
          ), a.bufferSubData(W.type, $, U);
        }
        function Ee(U, $) {
          var be = ($ || 0) | 0, ue;
          if (W.bind(), n(U) || U instanceof ArrayBuffer)
            he(U, be);
          else if (Array.isArray(U)) {
            if (U.length > 0)
              if (typeof U[0] == "number") {
                var J = ht.allocType(W.dtype, U.length);
                Ya(J, U), he(J, be), ht.freeType(J);
              } else if (Array.isArray(U[0]) || n(U[0])) {
                ue = Wa(U);
                var ce = Zi(U, ue, W.dtype);
                he(ce, be), ht.freeType(ce);
              } else
                d.raise("invalid buffer data");
          } else if (Ut(U)) {
            ue = U.shape;
            var le = U.stride, Me = 0, Re = 0, de = 0, ve = 0;
            ue.length === 1 ? (Me = ue[0], Re = 1, de = le[0], ve = 0) : ue.length === 2 ? (Me = ue[0], Re = ue[1], de = le[0], ve = le[1]) : d.raise("invalid shape");
            var Fe = Array.isArray(U.data) ? W.dtype : Xr(U.data), Oe = ht.allocType(Fe, Me * Re);
            Za(
              Oe,
              U.data,
              Me,
              Re,
              de,
              ve,
              U.offset
            ), he(Oe, be), ht.freeType(Oe);
          } else
            d.raise("invalid data for buffer subdata");
          return me;
        }
        return ee || me(C), me._reglType = "buffer", me._buffer = W, me.subdata = Ee, _.profile && (me.stats = W.stats), me.destroy = function() {
          fe(W);
        }, me;
      }
      function te() {
        Mt(I).forEach(function(C) {
          C.buffer = a.createBuffer(), a.bindBuffer(C.type, C.buffer), a.bufferData(
            C.type,
            C.persistentData || C.byteLength,
            C.usage
          );
        });
      }
      return _.profile && (h.getTotalBufferSize = function() {
        var C = 0;
        return Object.keys(I).forEach(function(O) {
          C += I[O].stats.size;
        }), C;
      }), {
        create: Q,
        createStream: Y,
        destroyStream: ne,
        clear: function() {
          Mt(I).forEach(fe), Z.forEach(fe);
        },
        getBuffer: function(C) {
          return C && C._buffer instanceof G ? C._buffer : null;
        },
        restore: te,
        _initBuffer: re
      };
    }
    var Tl = 0, Al = 0, El = 1, Pl = 1, Cl = 4, kl = 4, pn = {
      points: Tl,
      point: Al,
      lines: El,
      line: Pl,
      triangles: Cl,
      triangle: kl,
      "line loop": 2,
      "line strip": 3,
      "triangle strip": 5,
      "triangle fan": 6
    }, Fl = 0, Ll = 1, mr = 4, zl = 5120, Un = 5121, Qa = 5122, Xn = 5123, Ka = 5124, An = 5125, Ji = 34963, Il = 35040, Rl = 35044;
    function Dl(a, h, _, R) {
      var j = {}, I = 0, G = {
        uint8: Un,
        uint16: Xn
      };
      h.oes_element_index_uint && (G.uint32 = An);
      function Z(te) {
        this.id = I++, j[this.id] = this, this.buffer = te, this.primType = mr, this.vertCount = 0, this.type = 0;
      }
      Z.prototype.bind = function() {
        this.buffer.bind();
      };
      var Y = [];
      function ne(te) {
        var C = Y.pop();
        return C || (C = new Z(_.create(
          null,
          Ji,
          true,
          false
        )._buffer)), re(C, te, Il, -1, -1, 0, 0), C;
      }
      function ie(te) {
        Y.push(te);
      }
      function re(te, C, O, ee, ge, W, me) {
        te.buffer.bind();
        var he;
        if (C) {
          var Ee = me;
          !me && (!n(C) || Ut(C) && !n(C.data)) && (Ee = h.oes_element_index_uint ? An : Xn), _._initBuffer(
            te.buffer,
            C,
            O,
            Ee,
            3
          );
        } else
          a.bufferData(Ji, W, O), te.buffer.dtype = he || Un, te.buffer.usage = O, te.buffer.dimension = 3, te.buffer.byteLength = W;
        if (he = me, !me) {
          switch (te.buffer.dtype) {
            case Un:
            case zl:
              he = Un;
              break;
            case Xn:
            case Qa:
              he = Xn;
              break;
            case An:
            case Ka:
              he = An;
              break;
            default:
              d.raise("unsupported type for element array");
          }
          te.buffer.dtype = he;
        }
        te.type = he, d(
          he !== An || !!h.oes_element_index_uint,
          "32 bit element buffers not supported, enable oes_element_index_uint first"
        );
        var U = ge;
        U < 0 && (U = te.buffer.byteLength, he === Xn ? U >>= 1 : he === An && (U >>= 2)), te.vertCount = U;
        var $ = ee;
        if (ee < 0) {
          $ = mr;
          var be = te.buffer.dimension;
          be === 1 && ($ = Fl), be === 2 && ($ = Ll), be === 3 && ($ = mr);
        }
        te.primType = $;
      }
      function fe(te) {
        R.elementsCount--, d(te.buffer !== null, "must not double destroy elements"), delete j[te.id], te.buffer.destroy(), te.buffer = null;
      }
      function Q(te, C) {
        var O = _.create(null, Ji, true), ee = new Z(O._buffer);
        R.elementsCount++;
        function ge(W) {
          if (!W)
            O(), ee.primType = mr, ee.vertCount = 0, ee.type = Un;
          else if (typeof W == "number")
            O(W), ee.primType = mr, ee.vertCount = W | 0, ee.type = Un;
          else {
            var me = null, he = Rl, Ee = -1, U = -1, $ = 0, be = 0;
            Array.isArray(W) || n(W) || Ut(W) ? me = W : (d.type(W, "object", "invalid arguments for elements"), "data" in W && (me = W.data, d(
              Array.isArray(me) || n(me) || Ut(me),
              "invalid data for element buffer"
            )), "usage" in W && (d.parameter(
              W.usage,
              Ur,
              "invalid element buffer usage"
            ), he = Ur[W.usage]), "primitive" in W && (d.parameter(
              W.primitive,
              pn,
              "invalid element buffer primitive"
            ), Ee = pn[W.primitive]), "count" in W && (d(
              typeof W.count == "number" && W.count >= 0,
              "invalid vertex count for elements"
            ), U = W.count | 0), "type" in W && (d.parameter(
              W.type,
              G,
              "invalid buffer type"
            ), be = G[W.type]), "length" in W ? $ = W.length | 0 : ($ = U, be === Xn || be === Qa ? $ *= 2 : (be === An || be === Ka) && ($ *= 4))), re(
              ee,
              me,
              he,
              Ee,
              U,
              $,
              be
            );
          }
          return ge;
        }
        return ge(te), ge._reglType = "elements", ge._elements = ee, ge.subdata = function(W, me) {
          return O.subdata(W, me), ge;
        }, ge.destroy = function() {
          fe(ee);
        }, ge;
      }
      return {
        create: Q,
        createStream: ne,
        destroyStream: ie,
        getElements: function(te) {
          return typeof te == "function" && te._elements instanceof Z ? te._elements : null;
        },
        clear: function() {
          Mt(j).forEach(fe);
        }
      };
    }
    var Ja = new Float32Array(1), Ml = new Uint32Array(Ja.buffer), Ol = 5123;
    function es(a) {
      for (var h = ht.allocType(Ol, a.length), _ = 0; _ < a.length; ++_)
        if (isNaN(a[_]))
          h[_] = 65535;
        else if (a[_] === 1 / 0)
          h[_] = 31744;
        else if (a[_] === -1 / 0)
          h[_] = 64512;
        else {
          Ja[0] = a[_];
          var R = Ml[0], j = R >>> 31 << 15, I = (R << 1 >>> 24) - 127, G = R >> 13 & 1023;
          if (I < -24)
            h[_] = j;
          else if (I < -14) {
            var Z = -14 - I;
            h[_] = j + (G + 1024 >> Z);
          } else I > 15 ? h[_] = j + 31744 : h[_] = j + (I + 15 << 10) + G;
        }
      return h;
    }
    function ot(a) {
      return Array.isArray(a) || n(a);
    }
    var ts = function(a) {
      return !(a & a - 1) && !!a;
    }, Nl = 34467, Zt = 3553, eo = 34067, Hr = 34069, En = 6408, to = 6406, Wr = 6407, pr = 6409, qr = 6410, ns = 32854, no = 32855, rs = 36194, Gl = 32819, Bl = 32820, Vl = 33635, $l = 34042, ro = 6402, Yr = 34041, io = 35904, oo = 35906, Hn = 36193, ao = 33776, so = 33777, fo = 33778, uo = 33779, is = 35986, os = 35987, as = 34798, ss = 35840, fs = 35841, us = 35842, cs = 35843, ls = 36196, Wn = 5121, co = 5123, lo = 5125, vr = 5126, jl = 10242, Ul = 10243, Xl = 10497, ho = 33071, Hl = 33648, Wl = 10240, ql = 10241, mo = 9728, Yl = 9729, po = 9984, hs = 9985, ds = 9986, vo = 9987, Zl = 33170, Zr = 4352, Ql = 4353, Kl = 4354, Jl = 34046, eh = 3317, th = 37440, nh = 37441, rh = 37443, ms = 37444, gr = 33984, ih = [
      po,
      ds,
      hs,
      vo
    ], Qr = [
      0,
      pr,
      qr,
      Wr,
      En
    ], Bt = {};
    Bt[pr] = Bt[to] = Bt[ro] = 1, Bt[Yr] = Bt[qr] = 2, Bt[Wr] = Bt[io] = 3, Bt[En] = Bt[oo] = 4;
    function qn(a) {
      return "[object " + a + "]";
    }
    var ps = qn("HTMLCanvasElement"), vs = qn("OffscreenCanvas"), gs = qn("CanvasRenderingContext2D"), xs = qn("ImageBitmap"), ys = qn("HTMLImageElement"), bs = qn("HTMLVideoElement"), oh = Object.keys(Yi).concat([
      ps,
      vs,
      gs,
      xs,
      ys,
      bs
    ]), Yn = [];
    Yn[Wn] = 1, Yn[vr] = 4, Yn[Hn] = 2, Yn[co] = 2, Yn[lo] = 4;
    var Tt = [];
    Tt[ns] = 2, Tt[no] = 2, Tt[rs] = 2, Tt[Yr] = 4, Tt[ao] = 0.5, Tt[so] = 0.5, Tt[fo] = 1, Tt[uo] = 1, Tt[is] = 0.5, Tt[os] = 1, Tt[as] = 1, Tt[ss] = 0.5, Tt[fs] = 0.25, Tt[us] = 0.5, Tt[cs] = 0.25, Tt[ls] = 0.5;
    function _s(a) {
      return Array.isArray(a) && (a.length === 0 || typeof a[0] == "number");
    }
    function Ss(a) {
      if (!Array.isArray(a))
        return false;
      var h = a.length;
      return !(h === 0 || !ot(a[0]));
    }
    function Pn(a) {
      return Object.prototype.toString.call(a);
    }
    function ws(a) {
      return Pn(a) === ps;
    }
    function Ts(a) {
      return Pn(a) === vs;
    }
    function ah(a) {
      return Pn(a) === gs;
    }
    function sh(a) {
      return Pn(a) === xs;
    }
    function fh(a) {
      return Pn(a) === ys;
    }
    function uh(a) {
      return Pn(a) === bs;
    }
    function go(a) {
      if (!a)
        return false;
      var h = Pn(a);
      return oh.indexOf(h) >= 0 ? true : _s(a) || Ss(a) || Ut(a);
    }
    function As(a) {
      return Yi[Object.prototype.toString.call(a)] | 0;
    }
    function ch(a, h) {
      var _ = h.length;
      switch (a.type) {
        case Wn:
        case co:
        case lo:
        case vr:
          var R = ht.allocType(a.type, _);
          R.set(h), a.data = R;
          break;
        case Hn:
          a.data = es(h);
          break;
        default:
          d.raise("unsupported texture type, must specify a typed array");
      }
    }
    function Es(a, h) {
      return ht.allocType(
        a.type === Hn ? vr : a.type,
        h
      );
    }
    function Ps(a, h) {
      a.type === Hn ? (a.data = es(h), ht.freeType(h)) : a.data = h;
    }
    function lh(a, h, _, R, j, I) {
      for (var G = a.width, Z = a.height, Y = a.channels, ne = G * Z * Y, ie = Es(a, ne), re = 0, fe = 0; fe < Z; ++fe)
        for (var Q = 0; Q < G; ++Q)
          for (var te = 0; te < Y; ++te)
            ie[re++] = h[_ * Q + R * fe + j * te + I];
      Ps(a, ie);
    }
    function Kr(a, h, _, R, j, I) {
      var G;
      if (typeof Tt[a] < "u" ? G = Tt[a] : G = Bt[a] * Yn[h], I && (G *= 6), j) {
        for (var Z = 0, Y = _; Y >= 1; )
          Z += G * Y * Y, Y /= 2;
        return Z;
      } else
        return G * _ * R;
    }
    function hh(a, h, _, R, j, I, G) {
      var Z = {
        "don't care": Zr,
        "dont care": Zr,
        nice: Kl,
        fast: Ql
      }, Y = {
        repeat: Xl,
        clamp: ho,
        mirror: Hl
      }, ne = {
        nearest: mo,
        linear: Yl
      }, ie = r({
        mipmap: vo,
        "nearest mipmap nearest": po,
        "linear mipmap nearest": hs,
        "nearest mipmap linear": ds,
        "linear mipmap linear": vo
      }, ne), re = {
        none: 0,
        browser: ms
      }, fe = {
        uint8: Wn,
        rgba4: Gl,
        rgb565: Vl,
        "rgb5 a1": Bl
      }, Q = {
        alpha: to,
        luminance: pr,
        "luminance alpha": qr,
        rgb: Wr,
        rgba: En,
        rgba4: ns,
        "rgb5 a1": no,
        rgb565: rs
      }, te = {};
      h.ext_srgb && (Q.srgb = io, Q.srgba = oo), h.oes_texture_float && (fe.float32 = fe.float = vr), h.oes_texture_half_float && (fe.float16 = fe["half float"] = Hn), h.webgl_depth_texture && (r(Q, {
        depth: ro,
        "depth stencil": Yr
      }), r(fe, {
        uint16: co,
        uint32: lo,
        "depth stencil": $l
      })), h.webgl_compressed_texture_s3tc && r(te, {
        "rgb s3tc dxt1": ao,
        "rgba s3tc dxt1": so,
        "rgba s3tc dxt3": fo,
        "rgba s3tc dxt5": uo
      }), h.webgl_compressed_texture_atc && r(te, {
        "rgb atc": is,
        "rgba atc explicit alpha": os,
        "rgba atc interpolated alpha": as
      }), h.webgl_compressed_texture_pvrtc && r(te, {
        "rgb pvrtc 4bppv1": ss,
        "rgb pvrtc 2bppv1": fs,
        "rgba pvrtc 4bppv1": us,
        "rgba pvrtc 2bppv1": cs
      }), h.webgl_compressed_texture_etc1 && (te["rgb etc1"] = ls);
      var C = Array.prototype.slice.call(
        a.getParameter(Nl)
      );
      Object.keys(te).forEach(function(x) {
        var D = te[x];
        C.indexOf(D) >= 0 && (Q[x] = D);
      });
      var O = Object.keys(Q);
      _.textureFormats = O;
      var ee = [];
      Object.keys(Q).forEach(function(x) {
        var D = Q[x];
        ee[D] = x;
      });
      var ge = [];
      Object.keys(fe).forEach(function(x) {
        var D = fe[x];
        ge[D] = x;
      });
      var W = [];
      Object.keys(ne).forEach(function(x) {
        var D = ne[x];
        W[D] = x;
      });
      var me = [];
      Object.keys(ie).forEach(function(x) {
        var D = ie[x];
        me[D] = x;
      });
      var he = [];
      Object.keys(Y).forEach(function(x) {
        var D = Y[x];
        he[D] = x;
      });
      var Ee = O.reduce(function(x, D) {
        var z = Q[D];
        return z === pr || z === to || z === pr || z === qr || z === ro || z === Yr || h.ext_srgb && (z === io || z === oo) ? x[z] = z : z === no || D.indexOf("rgba") >= 0 ? x[z] = En : x[z] = Wr, x;
      }, {});
      function U() {
        this.internalformat = En, this.format = En, this.type = Wn, this.compressed = false, this.premultiplyAlpha = false, this.flipY = false, this.unpackAlignment = 1, this.colorSpace = ms, this.width = 0, this.height = 0, this.channels = 0;
      }
      function $(x, D) {
        x.internalformat = D.internalformat, x.format = D.format, x.type = D.type, x.compressed = D.compressed, x.premultiplyAlpha = D.premultiplyAlpha, x.flipY = D.flipY, x.unpackAlignment = D.unpackAlignment, x.colorSpace = D.colorSpace, x.width = D.width, x.height = D.height, x.channels = D.channels;
      }
      function be(x, D) {
        if (!(typeof D != "object" || !D)) {
          if ("premultiplyAlpha" in D && (d.type(
            D.premultiplyAlpha,
            "boolean",
            "invalid premultiplyAlpha"
          ), x.premultiplyAlpha = D.premultiplyAlpha), "flipY" in D && (d.type(
            D.flipY,
            "boolean",
            "invalid texture flip"
          ), x.flipY = D.flipY), "alignment" in D && (d.oneOf(
            D.alignment,
            [1, 2, 4, 8],
            "invalid texture unpack alignment"
          ), x.unpackAlignment = D.alignment), "colorSpace" in D && (d.parameter(
            D.colorSpace,
            re,
            "invalid colorSpace"
          ), x.colorSpace = re[D.colorSpace]), "type" in D) {
            var z = D.type;
            d(
              h.oes_texture_float || !(z === "float" || z === "float32"),
              "you must enable the OES_texture_float extension in order to use floating point textures."
            ), d(
              h.oes_texture_half_float || !(z === "half float" || z === "float16"),
              "you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures."
            ), d(
              h.webgl_depth_texture || !(z === "uint16" || z === "uint32" || z === "depth stencil"),
              "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
            ), d.parameter(
              z,
              fe,
              "invalid texture type"
            ), x.type = fe[z];
          }
          var ye = x.width, Ue = x.height, m = x.channels, c = false;
          "shape" in D ? (d(
            Array.isArray(D.shape) && D.shape.length >= 2,
            "shape must be an array"
          ), ye = D.shape[0], Ue = D.shape[1], D.shape.length === 3 && (m = D.shape[2], d(m > 0 && m <= 4, "invalid number of channels"), c = true), d(ye >= 0 && ye <= _.maxTextureSize, "invalid width"), d(Ue >= 0 && Ue <= _.maxTextureSize, "invalid height")) : ("radius" in D && (ye = Ue = D.radius, d(ye >= 0 && ye <= _.maxTextureSize, "invalid radius")), "width" in D && (ye = D.width, d(ye >= 0 && ye <= _.maxTextureSize, "invalid width")), "height" in D && (Ue = D.height, d(Ue >= 0 && Ue <= _.maxTextureSize, "invalid height")), "channels" in D && (m = D.channels, d(m > 0 && m <= 4, "invalid number of channels"), c = true)), x.width = ye | 0, x.height = Ue | 0, x.channels = m | 0;
          var w = false;
          if ("format" in D) {
            var P = D.format;
            d(
              h.webgl_depth_texture || !(P === "depth" || P === "depth stencil"),
              "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
            ), d.parameter(
              P,
              Q,
              "invalid texture format"
            );
            var k = x.internalformat = Q[P];
            x.format = Ee[k], P in fe && ("type" in D || (x.type = fe[P])), P in te && (x.compressed = true), w = true;
          }
          !c && w ? x.channels = Bt[x.format] : c && !w ? x.channels !== Qr[x.format] && (x.format = x.internalformat = Qr[x.channels]) : w && c && d(
            x.channels === Bt[x.format],
            "number of channels inconsistent with specified format"
          );
        }
      }
      function ue(x) {
        a.pixelStorei(th, x.flipY), a.pixelStorei(nh, x.premultiplyAlpha), a.pixelStorei(rh, x.colorSpace), a.pixelStorei(eh, x.unpackAlignment);
      }
      function J() {
        U.call(this), this.xOffset = 0, this.yOffset = 0, this.data = null, this.needsFree = false, this.element = null, this.needsCopy = false;
      }
      function ce(x, D) {
        var z = null;
        if (go(D) ? z = D : D && (d.type(D, "object", "invalid pixel data type"), be(x, D), "x" in D && (x.xOffset = D.x | 0), "y" in D && (x.yOffset = D.y | 0), go(D.data) && (z = D.data)), d(
          !x.compressed || z instanceof Uint8Array,
          "compressed texture data must be stored in a uint8array"
        ), D.copy) {
          d(!z, "can not specify copy and data field for the same texture");
          var ye = j.viewportWidth, Ue = j.viewportHeight;
          x.width = x.width || ye - x.xOffset, x.height = x.height || Ue - x.yOffset, x.needsCopy = true, d(
            x.xOffset >= 0 && x.xOffset < ye && x.yOffset >= 0 && x.yOffset < Ue && x.width > 0 && x.width <= ye && x.height > 0 && x.height <= Ue,
            "copy texture read out of bounds"
          );
        } else if (!z)
          x.width = x.width || 1, x.height = x.height || 1, x.channels = x.channels || 4;
        else if (n(z))
          x.channels = x.channels || 4, x.data = z, !("type" in D) && x.type === Wn && (x.type = As(z));
        else if (_s(z))
          x.channels = x.channels || 4, ch(x, z), x.alignment = 1, x.needsFree = true;
        else if (Ut(z)) {
          var m = z.data;
          !Array.isArray(m) && x.type === Wn && (x.type = As(m));
          var c = z.shape, w = z.stride, P, k, A, T, E, p;
          c.length === 3 ? (A = c[2], p = w[2]) : (d(c.length === 2, "invalid ndarray pixel data, must be 2 or 3D"), A = 1, p = 1), P = c[0], k = c[1], T = w[0], E = w[1], x.alignment = 1, x.width = P, x.height = k, x.channels = A, x.format = x.internalformat = Qr[A], x.needsFree = true, lh(x, m, T, E, p, z.offset);
        } else if (ws(z) || Ts(z) || ah(z))
          ws(z) || Ts(z) ? x.element = z : x.element = z.canvas, x.width = x.element.width, x.height = x.element.height, x.channels = 4;
        else if (sh(z))
          x.element = z, x.width = z.width, x.height = z.height, x.channels = 4;
        else if (fh(z))
          x.element = z, x.width = z.naturalWidth, x.height = z.naturalHeight, x.channels = 4;
        else if (uh(z))
          x.element = z, x.width = z.videoWidth, x.height = z.videoHeight, x.channels = 4;
        else if (Ss(z)) {
          var y = x.width || z[0].length, g = x.height || z.length, L = x.channels;
          ot(z[0][0]) ? L = L || z[0][0].length : L = L || 1;
          for (var F = jr.shape(z), V = 1, X = 0; X < F.length; ++X)
            V *= F[X];
          var se = Es(x, V);
          jr.flatten(z, F, "", se), Ps(x, se), x.alignment = 1, x.width = y, x.height = g, x.channels = L, x.format = x.internalformat = Qr[L], x.needsFree = true;
        }
        x.type === vr ? d(
          _.extensions.indexOf("oes_texture_float") >= 0,
          "oes_texture_float extension not enabled"
        ) : x.type === Hn && d(
          _.extensions.indexOf("oes_texture_half_float") >= 0,
          "oes_texture_half_float extension not enabled"
        );
      }
      function le(x, D, z) {
        var ye = x.element, Ue = x.data, m = x.internalformat, c = x.format, w = x.type, P = x.width, k = x.height;
        ue(x), ye ? a.texImage2D(D, z, c, c, w, ye) : x.compressed ? a.compressedTexImage2D(D, z, m, P, k, 0, Ue) : x.needsCopy ? (R(), a.copyTexImage2D(
          D,
          z,
          c,
          x.xOffset,
          x.yOffset,
          P,
          k,
          0
        )) : a.texImage2D(D, z, c, P, k, 0, c, w, Ue || null);
      }
      function Me(x, D, z, ye, Ue) {
        var m = x.element, c = x.data, w = x.internalformat, P = x.format, k = x.type, A = x.width, T = x.height;
        ue(x), m ? a.texSubImage2D(
          D,
          Ue,
          z,
          ye,
          P,
          k,
          m
        ) : x.compressed ? a.compressedTexSubImage2D(
          D,
          Ue,
          z,
          ye,
          w,
          A,
          T,
          c
        ) : x.needsCopy ? (R(), a.copyTexSubImage2D(
          D,
          Ue,
          z,
          ye,
          x.xOffset,
          x.yOffset,
          A,
          T
        )) : a.texSubImage2D(
          D,
          Ue,
          z,
          ye,
          A,
          T,
          P,
          k,
          c
        );
      }
      var Re = [];
      function de() {
        return Re.pop() || new J();
      }
      function ve(x) {
        x.needsFree && ht.freeType(x.data), J.call(x), Re.push(x);
      }
      function Fe() {
        U.call(this), this.genMipmaps = false, this.mipmapHint = Zr, this.mipmask = 0, this.images = Array(16);
      }
      function Oe(x, D, z) {
        var ye = x.images[0] = de();
        x.mipmask = 1, ye.width = x.width = D, ye.height = x.height = z, ye.channels = x.channels = 4;
      }
      function Xe(x, D) {
        var z = null;
        if (go(D))
          z = x.images[0] = de(), $(z, x), ce(z, D), x.mipmask = 1;
        else if (be(x, D), Array.isArray(D.mipmap))
          for (var ye = D.mipmap, Ue = 0; Ue < ye.length; ++Ue)
            z = x.images[Ue] = de(), $(z, x), z.width >>= Ue, z.height >>= Ue, ce(z, ye[Ue]), x.mipmask |= 1 << Ue;
        else
          z = x.images[0] = de(), $(z, x), ce(z, D), x.mipmask = 1;
        $(x, x.images[0]), x.compressed && (x.internalformat === ao || x.internalformat === so || x.internalformat === fo || x.internalformat === uo) && d(
          x.width % 4 === 0 && x.height % 4 === 0,
          "for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4"
        );
      }
      function at(x, D) {
        for (var z = x.images, ye = 0; ye < z.length; ++ye) {
          if (!z[ye])
            return;
          le(z[ye], D, ye);
        }
      }
      var ft = [];
      function Ze() {
        var x = ft.pop() || new Fe();
        U.call(x), x.mipmask = 0;
        for (var D = 0; D < 16; ++D)
          x.images[D] = null;
        return x;
      }
      function pt(x) {
        for (var D = x.images, z = 0; z < D.length; ++z)
          D[z] && ve(D[z]), D[z] = null;
        ft.push(x);
      }
      function it() {
        this.minFilter = mo, this.magFilter = mo, this.wrapS = ho, this.wrapT = ho, this.anisotropic = 1, this.genMipmaps = false, this.mipmapHint = Zr;
      }
      function mt(x, D) {
        if ("min" in D) {
          var z = D.min;
          d.parameter(z, ie), x.minFilter = ie[z], ih.indexOf(x.minFilter) >= 0 && !("faces" in D) && (x.genMipmaps = true);
        }
        if ("mag" in D) {
          var ye = D.mag;
          d.parameter(ye, ne), x.magFilter = ne[ye];
        }
        var Ue = x.wrapS, m = x.wrapT;
        if ("wrap" in D) {
          var c = D.wrap;
          typeof c == "string" ? (d.parameter(c, Y), Ue = m = Y[c]) : Array.isArray(c) && (d.parameter(c[0], Y), d.parameter(c[1], Y), Ue = Y[c[0]], m = Y[c[1]]);
        } else {
          if ("wrapS" in D) {
            var w = D.wrapS;
            d.parameter(w, Y), Ue = Y[w];
          }
          if ("wrapT" in D) {
            var P = D.wrapT;
            d.parameter(P, Y), m = Y[P];
          }
        }
        if (x.wrapS = Ue, x.wrapT = m, "anisotropic" in D) {
          var k = D.anisotropic;
          d(
            typeof k == "number" && k >= 1 && k <= _.maxAnisotropic,
            "aniso samples must be between 1 and "
          ), x.anisotropic = D.anisotropic;
        }
        if ("mipmap" in D) {
          var A = false;
          switch (typeof D.mipmap) {
            case "string":
              d.parameter(
                D.mipmap,
                Z,
                "invalid mipmap hint"
              ), x.mipmapHint = Z[D.mipmap], x.genMipmaps = true, A = true;
              break;
            case "boolean":
              A = x.genMipmaps = D.mipmap;
              break;
            case "object":
              d(Array.isArray(D.mipmap), "invalid mipmap type"), x.genMipmaps = false, A = true;
              break;
            default:
              d.raise("invalid mipmap type");
          }
          A && !("min" in D) && (x.minFilter = po);
        }
      }
      function vt(x, D) {
        a.texParameteri(D, ql, x.minFilter), a.texParameteri(D, Wl, x.magFilter), a.texParameteri(D, jl, x.wrapS), a.texParameteri(D, Ul, x.wrapT), h.ext_texture_filter_anisotropic && a.texParameteri(D, Jl, x.anisotropic), x.genMipmaps && (a.hint(Zl, x.mipmapHint), a.generateMipmap(D));
      }
      var gt = 0, _t = {}, At = _.maxTextureUnits, ct = Array(At).map(function() {
        return null;
      });
      function Ve(x) {
        U.call(this), this.mipmask = 0, this.internalformat = En, this.id = gt++, this.refCount = 1, this.target = x, this.texture = a.createTexture(), this.unit = -1, this.bindCount = 0, this.texInfo = new it(), G.profile && (this.stats = { size: 0 });
      }
      function Et(x) {
        a.activeTexture(gr), a.bindTexture(x.target, x.texture);
      }
      function Ke() {
        var x = ct[0];
        x ? a.bindTexture(x.target, x.texture) : a.bindTexture(Zt, null);
      }
      function Ce(x) {
        var D = x.texture;
        d(D, "must not double destroy texture");
        var z = x.unit, ye = x.target;
        z >= 0 && (a.activeTexture(gr + z), a.bindTexture(ye, null), ct[z] = null), a.deleteTexture(D), x.texture = null, x.params = null, x.pixels = null, x.refCount = 0, delete _t[x.id], I.textureCount--;
      }
      r(Ve.prototype, {
        bind: function() {
          var x = this;
          x.bindCount += 1;
          var D = x.unit;
          if (D < 0) {
            for (var z = 0; z < At; ++z) {
              var ye = ct[z];
              if (ye) {
                if (ye.bindCount > 0)
                  continue;
                ye.unit = -1;
              }
              ct[z] = x, D = z;
              break;
            }
            D >= At && d.raise("insufficient number of texture units"), G.profile && I.maxTextureUnits < D + 1 && (I.maxTextureUnits = D + 1), x.unit = D, a.activeTexture(gr + D), a.bindTexture(x.target, x.texture);
          }
          return D;
        },
        unbind: function() {
          this.bindCount -= 1;
        },
        decRef: function() {
          --this.refCount <= 0 && Ce(this);
        }
      });
      function He(x, D) {
        var z = new Ve(Zt);
        _t[z.id] = z, I.textureCount++;
        function ye(c, w) {
          var P = z.texInfo;
          it.call(P);
          var k = Ze();
          return typeof c == "number" ? typeof w == "number" ? Oe(k, c | 0, w | 0) : Oe(k, c | 0, c | 0) : c ? (d.type(c, "object", "invalid arguments to regl.texture"), mt(P, c), Xe(k, c)) : Oe(k, 1, 1), P.genMipmaps && (k.mipmask = (k.width << 1) - 1), z.mipmask = k.mipmask, $(z, k), d.texture2D(P, k, _), z.internalformat = k.internalformat, ye.width = k.width, ye.height = k.height, Et(z), at(k, Zt), vt(P, Zt), Ke(), pt(k), G.profile && (z.stats.size = Kr(
            z.internalformat,
            z.type,
            k.width,
            k.height,
            P.genMipmaps,
            false
          )), ye.format = ee[z.internalformat], ye.type = ge[z.type], ye.mag = W[P.magFilter], ye.min = me[P.minFilter], ye.wrapS = he[P.wrapS], ye.wrapT = he[P.wrapT], ye;
        }
        function Ue(c, w, P, k) {
          d(!!c, "must specify image data");
          var A = w | 0, T = P | 0, E = k | 0, p = de();
          return $(p, z), p.width = 0, p.height = 0, ce(p, c), p.width = p.width || (z.width >> E) - A, p.height = p.height || (z.height >> E) - T, d(
            z.type === p.type && z.format === p.format && z.internalformat === p.internalformat,
            "incompatible format for texture.subimage"
          ), d(
            A >= 0 && T >= 0 && A + p.width <= z.width && T + p.height <= z.height,
            "texture.subimage write out of bounds"
          ), d(
            z.mipmask & 1 << E,
            "missing mipmap data"
          ), d(
            p.data || p.element || p.needsCopy,
            "missing image data"
          ), Et(z), Me(p, Zt, A, T, E), Ke(), ve(p), ye;
        }
        function m(c, w) {
          var P = c | 0, k = w | 0 || P;
          if (P === z.width && k === z.height)
            return ye;
          ye.width = z.width = P, ye.height = z.height = k, Et(z);
          for (var A = 0; z.mipmask >> A; ++A) {
            var T = P >> A, E = k >> A;
            if (!T || !E) break;
            a.texImage2D(
              Zt,
              A,
              z.format,
              T,
              E,
              0,
              z.format,
              z.type,
              null
            );
          }
          return Ke(), G.profile && (z.stats.size = Kr(
            z.internalformat,
            z.type,
            P,
            k,
            false,
            false
          )), ye;
        }
        return ye(x, D), ye.subimage = Ue, ye.resize = m, ye._reglType = "texture2d", ye._texture = z, G.profile && (ye.stats = z.stats), ye.destroy = function() {
          z.decRef();
        }, ye;
      }
      function Qe(x, D, z, ye, Ue, m) {
        var c = new Ve(eo);
        _t[c.id] = c, I.cubeCount++;
        var w = new Array(6);
        function P(T, E, p, y, g, L) {
          var F, V = c.texInfo;
          for (it.call(V), F = 0; F < 6; ++F)
            w[F] = Ze();
          if (typeof T == "number" || !T) {
            var X = T | 0 || 1;
            for (F = 0; F < 6; ++F)
              Oe(w[F], X, X);
          } else if (typeof T == "object")
            if (E)
              Xe(w[0], T), Xe(w[1], E), Xe(w[2], p), Xe(w[3], y), Xe(w[4], g), Xe(w[5], L);
            else if (mt(V, T), be(c, T), "faces" in T) {
              var se = T.faces;
              for (d(
                Array.isArray(se) && se.length === 6,
                "cube faces must be a length 6 array"
              ), F = 0; F < 6; ++F)
                d(
                  typeof se[F] == "object" && !!se[F],
                  "invalid input for cube map face"
                ), $(w[F], c), Xe(w[F], se[F]);
            } else
              for (F = 0; F < 6; ++F)
                Xe(w[F], T);
          else
            d.raise("invalid arguments to cube map");
          for ($(c, w[0]), d.optional(function() {
            _.npotTextureCube || d(ts(c.width) && ts(c.height), "your browser does not support non power or two texture dimensions");
          }), V.genMipmaps ? c.mipmask = (w[0].width << 1) - 1 : c.mipmask = w[0].mipmask, d.textureCube(c, V, w, _), c.internalformat = w[0].internalformat, P.width = w[0].width, P.height = w[0].height, Et(c), F = 0; F < 6; ++F)
            at(w[F], Hr + F);
          for (vt(V, eo), Ke(), G.profile && (c.stats.size = Kr(
            c.internalformat,
            c.type,
            P.width,
            P.height,
            V.genMipmaps,
            true
          )), P.format = ee[c.internalformat], P.type = ge[c.type], P.mag = W[V.magFilter], P.min = me[V.minFilter], P.wrapS = he[V.wrapS], P.wrapT = he[V.wrapT], F = 0; F < 6; ++F)
            pt(w[F]);
          return P;
        }
        function k(T, E, p, y, g) {
          d(!!E, "must specify image data"), d(typeof T == "number" && T === (T | 0) && T >= 0 && T < 6, "invalid face");
          var L = p | 0, F = y | 0, V = g | 0, X = de();
          return $(X, c), X.width = 0, X.height = 0, ce(X, E), X.width = X.width || (c.width >> V) - L, X.height = X.height || (c.height >> V) - F, d(
            c.type === X.type && c.format === X.format && c.internalformat === X.internalformat,
            "incompatible format for texture.subimage"
          ), d(
            L >= 0 && F >= 0 && L + X.width <= c.width && F + X.height <= c.height,
            "texture.subimage write out of bounds"
          ), d(
            c.mipmask & 1 << V,
            "missing mipmap data"
          ), d(
            X.data || X.element || X.needsCopy,
            "missing image data"
          ), Et(c), Me(X, Hr + T, L, F, V), Ke(), ve(X), P;
        }
        function A(T) {
          var E = T | 0;
          if (E !== c.width) {
            P.width = c.width = E, P.height = c.height = E, Et(c);
            for (var p = 0; p < 6; ++p)
              for (var y = 0; c.mipmask >> y; ++y)
                a.texImage2D(
                  Hr + p,
                  y,
                  c.format,
                  E >> y,
                  E >> y,
                  0,
                  c.format,
                  c.type,
                  null
                );
            return Ke(), G.profile && (c.stats.size = Kr(
              c.internalformat,
              c.type,
              P.width,
              P.height,
              false,
              true
            )), P;
          }
        }
        return P(x, D, z, ye, Ue, m), P.subimage = k, P.resize = A, P._reglType = "textureCube", P._texture = c, G.profile && (P.stats = c.stats), P.destroy = function() {
          c.decRef();
        }, P;
      }
      function lt() {
        for (var x = 0; x < At; ++x)
          a.activeTexture(gr + x), a.bindTexture(Zt, null), ct[x] = null;
        Mt(_t).forEach(Ce), I.cubeCount = 0, I.textureCount = 0;
      }
      G.profile && (I.getTotalTextureSize = function() {
        var x = 0;
        return Object.keys(_t).forEach(function(D) {
          x += _t[D].stats.size;
        }), x;
      });
      function Kt() {
        for (var x = 0; x < At; ++x) {
          var D = ct[x];
          D && (D.bindCount = 0, D.unit = -1, ct[x] = null);
        }
        Mt(_t).forEach(function(z) {
          z.texture = a.createTexture(), a.bindTexture(z.target, z.texture);
          for (var ye = 0; ye < 32; ++ye)
            if (z.mipmask & 1 << ye)
              if (z.target === Zt)
                a.texImage2D(
                  Zt,
                  ye,
                  z.internalformat,
                  z.width >> ye,
                  z.height >> ye,
                  0,
                  z.internalformat,
                  z.type,
                  null
                );
              else
                for (var Ue = 0; Ue < 6; ++Ue)
                  a.texImage2D(
                    Hr + Ue,
                    ye,
                    z.internalformat,
                    z.width >> ye,
                    z.height >> ye,
                    0,
                    z.internalformat,
                    z.type,
                    null
                  );
          vt(z.texInfo, z.target);
        });
      }
      function Rn() {
        for (var x = 0; x < At; ++x) {
          var D = ct[x];
          D && (D.bindCount = 0, D.unit = -1, ct[x] = null), a.activeTexture(gr + x), a.bindTexture(Zt, null), a.bindTexture(eo, null);
        }
      }
      return {
        create2D: He,
        createCube: Qe,
        clear: lt,
        getTexture: function(x) {
          return null;
        },
        restore: Kt,
        refresh: Rn
      };
    }
    var vn = 36161, Jr = 32854, Cs = 32855, ks = 36194, Fs = 33189, Ls = 36168, zs = 34041, Is = 35907, Rs = 34836, Ds = 34842, Ms = 34843, Xt = [];
    Xt[Jr] = 2, Xt[Cs] = 2, Xt[ks] = 2, Xt[Fs] = 2, Xt[Ls] = 1, Xt[zs] = 4, Xt[Is] = 4, Xt[Rs] = 16, Xt[Ds] = 8, Xt[Ms] = 6;
    function Os(a, h, _) {
      return Xt[a] * h * _;
    }
    var dh = function(a, h, _, R, j) {
      var I = {
        rgba4: Jr,
        rgb565: ks,
        "rgb5 a1": Cs,
        depth: Fs,
        stencil: Ls,
        "depth stencil": zs
      };
      h.ext_srgb && (I.srgba = Is), h.ext_color_buffer_half_float && (I.rgba16f = Ds, I.rgb16f = Ms), h.webgl_color_buffer_float && (I.rgba32f = Rs);
      var G = [];
      Object.keys(I).forEach(function(Q) {
        var te = I[Q];
        G[te] = Q;
      });
      var Z = 0, Y = {};
      function ne(Q) {
        this.id = Z++, this.refCount = 1, this.renderbuffer = Q, this.format = Jr, this.width = 0, this.height = 0, j.profile && (this.stats = { size: 0 });
      }
      ne.prototype.decRef = function() {
        --this.refCount <= 0 && ie(this);
      };
      function ie(Q) {
        var te = Q.renderbuffer;
        d(te, "must not double destroy renderbuffer"), a.bindRenderbuffer(vn, null), a.deleteRenderbuffer(te), Q.renderbuffer = null, Q.refCount = 0, delete Y[Q.id], R.renderbufferCount--;
      }
      function re(Q, te) {
        var C = new ne(a.createRenderbuffer());
        Y[C.id] = C, R.renderbufferCount++;
        function O(ge, W) {
          var me = 0, he = 0, Ee = Jr;
          if (typeof ge == "object" && ge) {
            var U = ge;
            if ("shape" in U) {
              var $ = U.shape;
              d(
                Array.isArray($) && $.length >= 2,
                "invalid renderbuffer shape"
              ), me = $[0] | 0, he = $[1] | 0;
            } else
              "radius" in U && (me = he = U.radius | 0), "width" in U && (me = U.width | 0), "height" in U && (he = U.height | 0);
            "format" in U && (d.parameter(
              U.format,
              I,
              "invalid renderbuffer format"
            ), Ee = I[U.format]);
          } else typeof ge == "number" ? (me = ge | 0, typeof W == "number" ? he = W | 0 : he = me) : ge ? d.raise("invalid arguments to renderbuffer constructor") : me = he = 1;
          if (d(
            me > 0 && he > 0 && me <= _.maxRenderbufferSize && he <= _.maxRenderbufferSize,
            "invalid renderbuffer size"
          ), !(me === C.width && he === C.height && Ee === C.format))
            return O.width = C.width = me, O.height = C.height = he, C.format = Ee, a.bindRenderbuffer(vn, C.renderbuffer), a.renderbufferStorage(vn, Ee, me, he), d(
              a.getError() === 0,
              "invalid render buffer format"
            ), j.profile && (C.stats.size = Os(C.format, C.width, C.height)), O.format = G[C.format], O;
        }
        function ee(ge, W) {
          var me = ge | 0, he = W | 0 || me;
          return me === C.width && he === C.height || (d(
            me > 0 && he > 0 && me <= _.maxRenderbufferSize && he <= _.maxRenderbufferSize,
            "invalid renderbuffer size"
          ), O.width = C.width = me, O.height = C.height = he, a.bindRenderbuffer(vn, C.renderbuffer), a.renderbufferStorage(vn, C.format, me, he), d(
            a.getError() === 0,
            "invalid render buffer format"
          ), j.profile && (C.stats.size = Os(
            C.format,
            C.width,
            C.height
          ))), O;
        }
        return O(Q, te), O.resize = ee, O._reglType = "renderbuffer", O._renderbuffer = C, j.profile && (O.stats = C.stats), O.destroy = function() {
          C.decRef();
        }, O;
      }
      j.profile && (R.getTotalRenderbufferSize = function() {
        var Q = 0;
        return Object.keys(Y).forEach(function(te) {
          Q += Y[te].stats.size;
        }), Q;
      });
      function fe() {
        Mt(Y).forEach(function(Q) {
          Q.renderbuffer = a.createRenderbuffer(), a.bindRenderbuffer(vn, Q.renderbuffer), a.renderbufferStorage(vn, Q.format, Q.width, Q.height);
        }), a.bindRenderbuffer(vn, null);
      }
      return {
        create: re,
        clear: function() {
          Mt(Y).forEach(ie);
        },
        restore: fe
      };
    }, on = 36160, xo = 36161, Cn = 3553, ei = 34069, Ns = 36064, Gs = 36096, Bs = 36128, Vs = 33306, $s = 36053, mh = 36054, ph = 36055, vh = 36057, gh = 36061, xh = 36193, yh = 5121, bh = 5126, js = 6407, Us = 6408, _h = 6402, Sh = [
      js,
      Us
    ], yo = [];
    yo[Us] = 4, yo[js] = 3;
    var ti = [];
    ti[yh] = 1, ti[bh] = 4, ti[xh] = 2;
    var wh = 32854, Th = 32855, Ah = 36194, Eh = 33189, Ph = 36168, Xs = 34041, Ch = 35907, kh = 34836, Fh = 34842, Lh = 34843, zh = [
      wh,
      Th,
      Ah,
      Ch,
      Fh,
      Lh,
      kh
    ], Zn = {};
    Zn[$s] = "complete", Zn[mh] = "incomplete attachment", Zn[vh] = "incomplete dimensions", Zn[ph] = "incomplete, missing attachment", Zn[gh] = "unsupported";
    function Ih(a, h, _, R, j, I) {
      var G = {
        cur: null,
        next: null,
        dirty: false,
        setFBO: null
      }, Z = ["rgba"], Y = ["rgba4", "rgb565", "rgb5 a1"];
      h.ext_srgb && Y.push("srgba"), h.ext_color_buffer_half_float && Y.push("rgba16f", "rgb16f"), h.webgl_color_buffer_float && Y.push("rgba32f");
      var ne = ["uint8"];
      h.oes_texture_half_float && ne.push("half float", "float16"), h.oes_texture_float && ne.push("float", "float32");
      function ie(J, ce, le) {
        this.target = J, this.texture = ce, this.renderbuffer = le;
        var Me = 0, Re = 0;
        ce ? (Me = ce.width, Re = ce.height) : le && (Me = le.width, Re = le.height), this.width = Me, this.height = Re;
      }
      function re(J) {
        J && (J.texture && J.texture._texture.decRef(), J.renderbuffer && J.renderbuffer._renderbuffer.decRef());
      }
      function fe(J, ce, le) {
        if (J)
          if (J.texture) {
            var Me = J.texture._texture, Re = Math.max(1, Me.width), de = Math.max(1, Me.height);
            d(
              Re === ce && de === le,
              "inconsistent width/height for supplied texture"
            ), Me.refCount += 1;
          } else {
            var ve = J.renderbuffer._renderbuffer;
            d(
              ve.width === ce && ve.height === le,
              "inconsistent width/height for renderbuffer"
            ), ve.refCount += 1;
          }
      }
      function Q(J, ce) {
        ce && (ce.texture ? a.framebufferTexture2D(
          on,
          J,
          ce.target,
          ce.texture._texture.texture,
          0
        ) : a.framebufferRenderbuffer(
          on,
          J,
          xo,
          ce.renderbuffer._renderbuffer.renderbuffer
        ));
      }
      function te(J) {
        var ce = Cn, le = null, Me = null, Re = J;
        typeof J == "object" && (Re = J.data, "target" in J && (ce = J.target | 0)), d.type(Re, "function", "invalid attachment data");
        var de = Re._reglType;
        return de === "texture2d" ? (le = Re, d(ce === Cn)) : de === "textureCube" ? (le = Re, d(
          ce >= ei && ce < ei + 6,
          "invalid cube map target"
        )) : de === "renderbuffer" ? (Me = Re, ce = xo) : d.raise("invalid regl object for attachment"), new ie(ce, le, Me);
      }
      function C(J, ce, le, Me, Re) {
        if (le) {
          var de = R.create2D({
            width: J,
            height: ce,
            format: Me,
            type: Re
          });
          return de._texture.refCount = 0, new ie(Cn, de, null);
        } else {
          var ve = j.create({
            width: J,
            height: ce,
            format: Me
          });
          return ve._renderbuffer.refCount = 0, new ie(xo, null, ve);
        }
      }
      function O(J) {
        return J && (J.texture || J.renderbuffer);
      }
      function ee(J, ce, le) {
        J && (J.texture ? J.texture.resize(ce, le) : J.renderbuffer && J.renderbuffer.resize(ce, le), J.width = ce, J.height = le);
      }
      var ge = 0, W = {};
      function me() {
        this.id = ge++, W[this.id] = this, this.framebuffer = a.createFramebuffer(), this.width = 0, this.height = 0, this.colorAttachments = [], this.depthAttachment = null, this.stencilAttachment = null, this.depthStencilAttachment = null;
      }
      function he(J) {
        J.colorAttachments.forEach(re), re(J.depthAttachment), re(J.stencilAttachment), re(J.depthStencilAttachment);
      }
      function Ee(J) {
        var ce = J.framebuffer;
        d(ce, "must not double destroy framebuffer"), a.deleteFramebuffer(ce), J.framebuffer = null, I.framebufferCount--, delete W[J.id];
      }
      function U(J) {
        var ce;
        a.bindFramebuffer(on, J.framebuffer);
        var le = J.colorAttachments;
        for (ce = 0; ce < le.length; ++ce)
          Q(Ns + ce, le[ce]);
        for (ce = le.length; ce < _.maxColorAttachments; ++ce)
          a.framebufferTexture2D(
            on,
            Ns + ce,
            Cn,
            null,
            0
          );
        a.framebufferTexture2D(
          on,
          Vs,
          Cn,
          null,
          0
        ), a.framebufferTexture2D(
          on,
          Gs,
          Cn,
          null,
          0
        ), a.framebufferTexture2D(
          on,
          Bs,
          Cn,
          null,
          0
        ), Q(Gs, J.depthAttachment), Q(Bs, J.stencilAttachment), Q(Vs, J.depthStencilAttachment);
        var Me = a.checkFramebufferStatus(on);
        !a.isContextLost() && Me !== $s && d.raise("framebuffer configuration not supported, status = " + Zn[Me]), a.bindFramebuffer(on, G.next ? G.next.framebuffer : null), G.cur = G.next, a.getError();
      }
      function $(J, ce) {
        var le = new me();
        I.framebufferCount++;
        function Me(de, ve) {
          var Fe;
          d(
            G.next !== le,
            "can not update framebuffer which is currently in use"
          );
          var Oe = 0, Xe = 0, at = true, ft = true, Ze = null, pt = true, it = "rgba", mt = "uint8", vt = 1, gt = null, _t = null, At = null, ct = false;
          if (typeof de == "number")
            Oe = de | 0, Xe = ve | 0 || Oe;
          else if (!de)
            Oe = Xe = 1;
          else {
            d.type(de, "object", "invalid arguments for framebuffer");
            var Ve = de;
            if ("shape" in Ve) {
              var Et = Ve.shape;
              d(
                Array.isArray(Et) && Et.length >= 2,
                "invalid shape for framebuffer"
              ), Oe = Et[0], Xe = Et[1];
            } else
              "radius" in Ve && (Oe = Xe = Ve.radius), "width" in Ve && (Oe = Ve.width), "height" in Ve && (Xe = Ve.height);
            ("color" in Ve || "colors" in Ve) && (Ze = Ve.color || Ve.colors, Array.isArray(Ze) && d(
              Ze.length === 1 || h.webgl_draw_buffers,
              "multiple render targets not supported"
            )), Ze || ("colorCount" in Ve && (vt = Ve.colorCount | 0, d(vt > 0, "invalid color buffer count")), "colorTexture" in Ve && (pt = !!Ve.colorTexture, it = "rgba4"), "colorType" in Ve && (mt = Ve.colorType, pt ? (d(
              h.oes_texture_float || !(mt === "float" || mt === "float32"),
              "you must enable OES_texture_float in order to use floating point framebuffer objects"
            ), d(
              h.oes_texture_half_float || !(mt === "half float" || mt === "float16"),
              "you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects"
            )) : mt === "half float" || mt === "float16" ? (d(
              h.ext_color_buffer_half_float,
              "you must enable EXT_color_buffer_half_float to use 16-bit render buffers"
            ), it = "rgba16f") : (mt === "float" || mt === "float32") && (d(
              h.webgl_color_buffer_float,
              "you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers"
            ), it = "rgba32f"), d.oneOf(mt, ne, "invalid color type")), "colorFormat" in Ve && (it = Ve.colorFormat, Z.indexOf(it) >= 0 ? pt = true : Y.indexOf(it) >= 0 ? pt = false : d.optional(function() {
              pt ? d.oneOf(
                Ve.colorFormat,
                Z,
                "invalid color format for texture"
              ) : d.oneOf(
                Ve.colorFormat,
                Y,
                "invalid color format for renderbuffer"
              );
            }))), ("depthTexture" in Ve || "depthStencilTexture" in Ve) && (ct = !!(Ve.depthTexture || Ve.depthStencilTexture), d(
              !ct || h.webgl_depth_texture,
              "webgl_depth_texture extension not supported"
            )), "depth" in Ve && (typeof Ve.depth == "boolean" ? at = Ve.depth : (gt = Ve.depth, ft = false)), "stencil" in Ve && (typeof Ve.stencil == "boolean" ? ft = Ve.stencil : (_t = Ve.stencil, at = false)), "depthStencil" in Ve && (typeof Ve.depthStencil == "boolean" ? at = ft = Ve.depthStencil : (At = Ve.depthStencil, at = false, ft = false));
          }
          var Ke = null, Ce = null, He = null, Qe = null;
          if (Array.isArray(Ze))
            Ke = Ze.map(te);
          else if (Ze)
            Ke = [te(Ze)];
          else
            for (Ke = new Array(vt), Fe = 0; Fe < vt; ++Fe)
              Ke[Fe] = C(
                Oe,
                Xe,
                pt,
                it,
                mt
              );
          d(
            h.webgl_draw_buffers || Ke.length <= 1,
            "you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers."
          ), d(
            Ke.length <= _.maxColorAttachments,
            "too many color attachments, not supported"
          ), Oe = Oe || Ke[0].width, Xe = Xe || Ke[0].height, gt ? Ce = te(gt) : at && !ft && (Ce = C(
            Oe,
            Xe,
            ct,
            "depth",
            "uint32"
          )), _t ? He = te(_t) : ft && !at && (He = C(
            Oe,
            Xe,
            false,
            "stencil",
            "uint8"
          )), At ? Qe = te(At) : !gt && !_t && ft && at && (Qe = C(
            Oe,
            Xe,
            ct,
            "depth stencil",
            "depth stencil"
          )), d(
            !!gt + !!_t + !!At <= 1,
            "invalid framebuffer configuration, can specify exactly one depth/stencil attachment"
          );
          var lt = null;
          for (Fe = 0; Fe < Ke.length; ++Fe)
            if (fe(Ke[Fe], Oe, Xe), d(
              !Ke[Fe] || Ke[Fe].texture && Sh.indexOf(Ke[Fe].texture._texture.format) >= 0 || Ke[Fe].renderbuffer && zh.indexOf(Ke[Fe].renderbuffer._renderbuffer.format) >= 0,
              "framebuffer color attachment " + Fe + " is invalid"
            ), Ke[Fe] && Ke[Fe].texture) {
              var Kt = yo[Ke[Fe].texture._texture.format] * ti[Ke[Fe].texture._texture.type];
              lt === null ? lt = Kt : d(
                lt === Kt,
                "all color attachments much have the same number of bits per pixel."
              );
            }
          return fe(Ce, Oe, Xe), d(
            !Ce || Ce.texture && Ce.texture._texture.format === _h || Ce.renderbuffer && Ce.renderbuffer._renderbuffer.format === Eh,
            "invalid depth attachment for framebuffer object"
          ), fe(He, Oe, Xe), d(
            !He || He.renderbuffer && He.renderbuffer._renderbuffer.format === Ph,
            "invalid stencil attachment for framebuffer object"
          ), fe(Qe, Oe, Xe), d(
            !Qe || Qe.texture && Qe.texture._texture.format === Xs || Qe.renderbuffer && Qe.renderbuffer._renderbuffer.format === Xs,
            "invalid depth-stencil attachment for framebuffer object"
          ), he(le), le.width = Oe, le.height = Xe, le.colorAttachments = Ke, le.depthAttachment = Ce, le.stencilAttachment = He, le.depthStencilAttachment = Qe, Me.color = Ke.map(O), Me.depth = O(Ce), Me.stencil = O(He), Me.depthStencil = O(Qe), Me.width = le.width, Me.height = le.height, U(le), Me;
        }
        function Re(de, ve) {
          d(
            G.next !== le,
            "can not resize a framebuffer which is currently in use"
          );
          var Fe = Math.max(de | 0, 1), Oe = Math.max(ve | 0 || Fe, 1);
          if (Fe === le.width && Oe === le.height)
            return Me;
          for (var Xe = le.colorAttachments, at = 0; at < Xe.length; ++at)
            ee(Xe[at], Fe, Oe);
          return ee(le.depthAttachment, Fe, Oe), ee(le.stencilAttachment, Fe, Oe), ee(le.depthStencilAttachment, Fe, Oe), le.width = Me.width = Fe, le.height = Me.height = Oe, U(le), Me;
        }
        return Me(J, ce), r(Me, {
          resize: Re,
          _reglType: "framebuffer",
          _framebuffer: le,
          destroy: function() {
            Ee(le), he(le);
          },
          use: function(de) {
            G.setFBO({
              framebuffer: Me
            }, de);
          }
        });
      }
      function be(J) {
        var ce = Array(6);
        function le(Re) {
          var de;
          d(
            ce.indexOf(G.next) < 0,
            "can not update framebuffer which is currently in use"
          );
          var ve = {
            color: null
          }, Fe = 0, Oe = null, Xe = "rgba", at = "uint8", ft = 1;
          if (typeof Re == "number")
            Fe = Re | 0;
          else if (!Re)
            Fe = 1;
          else {
            d.type(Re, "object", "invalid arguments for framebuffer");
            var Ze = Re;
            if ("shape" in Ze) {
              var pt = Ze.shape;
              d(
                Array.isArray(pt) && pt.length >= 2,
                "invalid shape for framebuffer"
              ), d(
                pt[0] === pt[1],
                "cube framebuffer must be square"
              ), Fe = pt[0];
            } else
              "radius" in Ze && (Fe = Ze.radius | 0), "width" in Ze ? (Fe = Ze.width | 0, "height" in Ze && d(Ze.height === Fe, "must be square")) : "height" in Ze && (Fe = Ze.height | 0);
            ("color" in Ze || "colors" in Ze) && (Oe = Ze.color || Ze.colors, Array.isArray(Oe) && d(
              Oe.length === 1 || h.webgl_draw_buffers,
              "multiple render targets not supported"
            )), Oe || ("colorCount" in Ze && (ft = Ze.colorCount | 0, d(ft > 0, "invalid color buffer count")), "colorType" in Ze && (d.oneOf(
              Ze.colorType,
              ne,
              "invalid color type"
            ), at = Ze.colorType), "colorFormat" in Ze && (Xe = Ze.colorFormat, d.oneOf(
              Ze.colorFormat,
              Z,
              "invalid color format for texture"
            ))), "depth" in Ze && (ve.depth = Ze.depth), "stencil" in Ze && (ve.stencil = Ze.stencil), "depthStencil" in Ze && (ve.depthStencil = Ze.depthStencil);
          }
          var it;
          if (Oe)
            if (Array.isArray(Oe))
              for (it = [], de = 0; de < Oe.length; ++de)
                it[de] = Oe[de];
            else
              it = [Oe];
          else {
            it = Array(ft);
            var mt = {
              radius: Fe,
              format: Xe,
              type: at
            };
            for (de = 0; de < ft; ++de)
              it[de] = R.createCube(mt);
          }
          for (ve.color = Array(it.length), de = 0; de < it.length; ++de) {
            var vt = it[de];
            d(
              typeof vt == "function" && vt._reglType === "textureCube",
              "invalid cube map"
            ), Fe = Fe || vt.width, d(
              vt.width === Fe && vt.height === Fe,
              "invalid cube map shape"
            ), ve.color[de] = {
              target: ei,
              data: it[de]
            };
          }
          for (de = 0; de < 6; ++de) {
            for (var gt = 0; gt < it.length; ++gt)
              ve.color[gt].target = ei + de;
            de > 0 && (ve.depth = ce[0].depth, ve.stencil = ce[0].stencil, ve.depthStencil = ce[0].depthStencil), ce[de] ? ce[de](ve) : ce[de] = $(ve);
          }
          return r(le, {
            width: Fe,
            height: Fe,
            color: it
          });
        }
        function Me(Re) {
          var de, ve = Re | 0;
          if (d(
            ve > 0 && ve <= _.maxCubeMapSize,
            "invalid radius for cube fbo"
          ), ve === le.width)
            return le;
          var Fe = le.color;
          for (de = 0; de < Fe.length; ++de)
            Fe[de].resize(ve);
          for (de = 0; de < 6; ++de)
            ce[de].resize(ve);
          return le.width = le.height = ve, le;
        }
        return le(J), r(le, {
          faces: ce,
          resize: Me,
          _reglType: "framebufferCube",
          destroy: function() {
            ce.forEach(function(Re) {
              Re.destroy();
            });
          }
        });
      }
      function ue() {
        G.cur = null, G.next = null, G.dirty = true, Mt(W).forEach(function(J) {
          J.framebuffer = a.createFramebuffer(), U(J);
        });
      }
      return r(G, {
        getFramebuffer: function(J) {
          if (typeof J == "function" && J._reglType === "framebuffer") {
            var ce = J._framebuffer;
            if (ce instanceof me)
              return ce;
          }
          return null;
        },
        create: $,
        createCube: be,
        clear: function() {
          Mt(W).forEach(Ee);
        },
        restore: ue
      });
    }
    var Rh = 5126, Hs = 34962, ni = 34963, Ws = [
      "attributes",
      "elements",
      "offset",
      "count",
      "primitive",
      "instances"
    ];
    function bo() {
      this.state = 0, this.x = 0, this.y = 0, this.z = 0, this.w = 0, this.buffer = null, this.size = 0, this.normalized = false, this.type = Rh, this.offset = 0, this.stride = 0, this.divisor = 0;
    }
    function Dh(a, h, _, R, j, I, G) {
      for (var Z = _.maxAttributes, Y = new Array(Z), ne = 0; ne < Z; ++ne)
        Y[ne] = new bo();
      var ie = 0, re = {}, fe = {
        Record: bo,
        scope: {},
        state: Y,
        currentVAO: null,
        targetVAO: null,
        restore: te() ? he : function() {
        },
        createVAO: Ee,
        getVAO: O,
        destroyBuffer: Q,
        setVAO: te() ? ee : ge,
        clear: te() ? W : function() {
        }
      };
      function Q(U) {
        for (var $ = 0; $ < Y.length; ++$) {
          var be = Y[$];
          be.buffer === U && (a.disableVertexAttribArray($), be.buffer = null);
        }
      }
      function te() {
        return h.oes_vertex_array_object;
      }
      function C() {
        return h.angle_instanced_arrays;
      }
      function O(U) {
        return typeof U == "function" && U._vao ? U._vao : null;
      }
      function ee(U) {
        if (U !== fe.currentVAO) {
          var $ = te();
          U ? $.bindVertexArrayOES(U.vao) : $.bindVertexArrayOES(null), fe.currentVAO = U;
        }
      }
      function ge(U) {
        if (U !== fe.currentVAO) {
          if (U)
            U.bindAttrs();
          else {
            for (var $ = C(), be = 0; be < Y.length; ++be) {
              var ue = Y[be];
              ue.buffer ? (a.enableVertexAttribArray(be), ue.buffer.bind(), a.vertexAttribPointer(be, ue.size, ue.type, ue.normalized, ue.stride, ue.offfset), $ && ue.divisor && $.vertexAttribDivisorANGLE(be, ue.divisor)) : (a.disableVertexAttribArray(be), a.vertexAttrib4f(be, ue.x, ue.y, ue.z, ue.w));
            }
            G.elements ? a.bindBuffer(ni, G.elements.buffer.buffer) : a.bindBuffer(ni, null);
          }
          fe.currentVAO = U;
        }
      }
      function W() {
        Mt(re).forEach(function(U) {
          U.destroy();
        });
      }
      function me() {
        this.id = ++ie, this.attributes = [], this.elements = null, this.ownsElements = false, this.count = 0, this.offset = 0, this.instances = -1, this.primitive = 4;
        var U = te();
        U ? this.vao = U.createVertexArrayOES() : this.vao = null, re[this.id] = this, this.buffers = [];
      }
      me.prototype.bindAttrs = function() {
        for (var U = C(), $ = this.attributes, be = 0; be < $.length; ++be) {
          var ue = $[be];
          ue.buffer ? (a.enableVertexAttribArray(be), a.bindBuffer(Hs, ue.buffer.buffer), a.vertexAttribPointer(be, ue.size, ue.type, ue.normalized, ue.stride, ue.offset), U && ue.divisor && U.vertexAttribDivisorANGLE(be, ue.divisor)) : (a.disableVertexAttribArray(be), a.vertexAttrib4f(be, ue.x, ue.y, ue.z, ue.w));
        }
        for (var J = $.length; J < Z; ++J)
          a.disableVertexAttribArray(J);
        var ce = I.getElements(this.elements);
        ce ? a.bindBuffer(ni, ce.buffer.buffer) : a.bindBuffer(ni, null);
      }, me.prototype.refresh = function() {
        var U = te();
        U && (U.bindVertexArrayOES(this.vao), this.bindAttrs(), fe.currentVAO = null, U.bindVertexArrayOES(null));
      }, me.prototype.destroy = function() {
        if (this.vao) {
          var U = te();
          this === fe.currentVAO && (fe.currentVAO = null, U.bindVertexArrayOES(null)), U.deleteVertexArrayOES(this.vao), this.vao = null;
        }
        this.ownsElements && (this.elements.destroy(), this.elements = null, this.ownsElements = false), re[this.id] && (delete re[this.id], R.vaoCount -= 1);
      };
      function he() {
        var U = te();
        U && Mt(re).forEach(function($) {
          $.refresh();
        });
      }
      function Ee(U) {
        var $ = new me();
        R.vaoCount += 1;
        function be(ue) {
          var J;
          if (Array.isArray(ue))
            J = ue, $.elements && $.ownsElements && $.elements.destroy(), $.elements = null, $.ownsElements = false, $.offset = 0, $.count = 0, $.instances = -1, $.primitive = 4;
          else {
            if (d(typeof ue == "object", "invalid arguments for create vao"), d("attributes" in ue, "must specify attributes for vao"), ue.elements) {
              var ce = ue.elements;
              $.ownsElements ? typeof ce == "function" && ce._reglType === "elements" ? ($.elements.destroy(), $.ownsElements = false) : ($.elements(ce), $.ownsElements = false) : I.getElements(ue.elements) ? ($.elements = ue.elements, $.ownsElements = false) : ($.elements = I.create(ue.elements), $.ownsElements = true);
            } else
              $.elements = null, $.ownsElements = false;
            J = ue.attributes, $.offset = 0, $.count = -1, $.instances = -1, $.primitive = 4, $.elements && ($.count = $.elements._elements.vertCount, $.primitive = $.elements._elements.primType), "offset" in ue && ($.offset = ue.offset | 0), "count" in ue && ($.count = ue.count | 0), "instances" in ue && ($.instances = ue.instances | 0), "primitive" in ue && (d(ue.primitive in pn, "bad primitive type: " + ue.primitive), $.primitive = pn[ue.primitive]), d.optional(() => {
              for (var at = Object.keys(ue), ft = 0; ft < at.length; ++ft)
                d(Ws.indexOf(at[ft]) >= 0, 'invalid option for vao: "' + at[ft] + '" valid options are ' + Ws);
            }), d(Array.isArray(J), "attributes must be an array");
          }
          d(J.length < Z, "too many attributes"), d(J.length > 0, "must specify at least one attribute");
          var le = {}, Me = $.attributes;
          Me.length = J.length;
          for (var Re = 0; Re < J.length; ++Re) {
            var de = J[Re], ve = Me[Re] = new bo(), Fe = de.data || de;
            if (Array.isArray(Fe) || n(Fe) || Ut(Fe)) {
              var Oe;
              $.buffers[Re] && (Oe = $.buffers[Re], n(Fe) && Oe._buffer.byteLength >= Fe.byteLength ? Oe.subdata(Fe) : (Oe.destroy(), $.buffers[Re] = null)), $.buffers[Re] || (Oe = $.buffers[Re] = j.create(de, Hs, false, true)), ve.buffer = j.getBuffer(Oe), ve.size = ve.buffer.dimension | 0, ve.normalized = false, ve.type = ve.buffer.dtype, ve.offset = 0, ve.stride = 0, ve.divisor = 0, ve.state = 1, le[Re] = 1;
            } else j.getBuffer(de) ? (ve.buffer = j.getBuffer(de), ve.size = ve.buffer.dimension | 0, ve.normalized = false, ve.type = ve.buffer.dtype, ve.offset = 0, ve.stride = 0, ve.divisor = 0, ve.state = 1) : j.getBuffer(de.buffer) ? (ve.buffer = j.getBuffer(de.buffer), ve.size = (+de.size || ve.buffer.dimension) | 0, ve.normalized = !!de.normalized || false, "type" in de ? (d.parameter(de.type, Tn, "invalid buffer type"), ve.type = Tn[de.type]) : ve.type = ve.buffer.dtype, ve.offset = (de.offset || 0) | 0, ve.stride = (de.stride || 0) | 0, ve.divisor = (de.divisor || 0) | 0, ve.state = 1, d(ve.size >= 1 && ve.size <= 4, "size must be between 1 and 4"), d(ve.offset >= 0, "invalid offset"), d(ve.stride >= 0 && ve.stride <= 255, "stride must be between 0 and 255"), d(ve.divisor >= 0, "divisor must be positive"), d(!ve.divisor || !!h.angle_instanced_arrays, "ANGLE_instanced_arrays must be enabled to use divisor")) : "x" in de ? (d(Re > 0, "first attribute must not be a constant"), ve.x = +de.x || 0, ve.y = +de.y || 0, ve.z = +de.z || 0, ve.w = +de.w || 0, ve.state = 2) : d(false, "invalid attribute spec for location " + Re);
          }
          for (var Xe = 0; Xe < $.buffers.length; ++Xe)
            !le[Xe] && $.buffers[Xe] && ($.buffers[Xe].destroy(), $.buffers[Xe] = null);
          return $.refresh(), be;
        }
        return be.destroy = function() {
          for (var ue = 0; ue < $.buffers.length; ++ue)
            $.buffers[ue] && $.buffers[ue].destroy();
          $.buffers.length = 0, $.ownsElements && ($.elements.destroy(), $.elements = null, $.ownsElements = false), $.destroy();
        }, be._vao = $, be._reglType = "vao", be(U);
      }
      return fe;
    }
    var qs = 35632, Mh = 35633, Oh = 35718, Nh = 35721;
    function Gh(a, h, _, R) {
      var j = {}, I = {};
      function G(C, O, ee, ge) {
        this.name = C, this.id = O, this.location = ee, this.info = ge;
      }
      function Z(C, O) {
        for (var ee = 0; ee < C.length; ++ee)
          if (C[ee].id === O.id) {
            C[ee].location = O.location;
            return;
          }
        C.push(O);
      }
      function Y(C, O, ee) {
        var ge = C === qs ? j : I, W = ge[O];
        if (!W) {
          var me = h.str(O);
          W = a.createShader(C), a.shaderSource(W, me), a.compileShader(W), d.shaderError(a, W, me, C, ee), ge[O] = W;
        }
        return W;
      }
      var ne = {}, ie = [], re = 0;
      function fe(C, O) {
        this.id = re++, this.fragId = C, this.vertId = O, this.program = null, this.uniforms = [], this.attributes = [], this.refCount = 1, R.profile && (this.stats = {
          uniformsCount: 0,
          attributesCount: 0
        });
      }
      function Q(C, O, ee) {
        var ge, W, me = Y(qs, C.fragId), he = Y(Mh, C.vertId), Ee = C.program = a.createProgram();
        if (a.attachShader(Ee, me), a.attachShader(Ee, he), ee)
          for (ge = 0; ge < ee.length; ++ge) {
            var U = ee[ge];
            a.bindAttribLocation(Ee, U[0], U[1]);
          }
        a.linkProgram(Ee), d.linkError(
          a,
          Ee,
          h.str(C.fragId),
          h.str(C.vertId),
          O
        );
        var $ = a.getProgramParameter(Ee, Oh);
        R.profile && (C.stats.uniformsCount = $);
        var be = C.uniforms;
        for (ge = 0; ge < $; ++ge)
          if (W = a.getActiveUniform(Ee, ge), W) {
            if (W.size > 1)
              for (var ue = 0; ue < W.size; ++ue) {
                var J = W.name.replace("[0]", "[" + ue + "]");
                Z(be, new G(
                  J,
                  h.id(J),
                  a.getUniformLocation(Ee, J),
                  W
                ));
              }
            var ce = W.name;
            W.size > 1 && (ce = ce.replace("[0]", "")), Z(be, new G(
              ce,
              h.id(ce),
              a.getUniformLocation(Ee, ce),
              W
            ));
          }
        var le = a.getProgramParameter(Ee, Nh);
        R.profile && (C.stats.attributesCount = le);
        var Me = C.attributes;
        for (ge = 0; ge < le; ++ge)
          W = a.getActiveAttrib(Ee, ge), W && Z(Me, new G(
            W.name,
            h.id(W.name),
            a.getAttribLocation(Ee, W.name),
            W
          ));
      }
      R.profile && (_.getMaxUniformsCount = function() {
        var C = 0;
        return ie.forEach(function(O) {
          O.stats.uniformsCount > C && (C = O.stats.uniformsCount);
        }), C;
      }, _.getMaxAttributesCount = function() {
        var C = 0;
        return ie.forEach(function(O) {
          O.stats.attributesCount > C && (C = O.stats.attributesCount);
        }), C;
      });
      function te() {
        j = {}, I = {};
        for (var C = 0; C < ie.length; ++C)
          Q(ie[C], null, ie[C].attributes.map(function(O) {
            return [O.location, O.name];
          }));
      }
      return {
        clear: function() {
          var C = a.deleteShader.bind(a);
          Mt(j).forEach(C), j = {}, Mt(I).forEach(C), I = {}, ie.forEach(function(O) {
            a.deleteProgram(O.program);
          }), ie.length = 0, ne = {}, _.shaderCount = 0;
        },
        program: function(C, O, ee, ge) {
          d.command(C >= 0, "missing vertex shader", ee), d.command(O >= 0, "missing fragment shader", ee);
          var W = ne[O];
          W || (W = ne[O] = {});
          var me = W[C];
          if (me && (me.refCount++, !ge))
            return me;
          var he = new fe(O, C);
          return _.shaderCount++, Q(he, ee, ge), me || (W[C] = he), ie.push(he), r(he, {
            destroy: function() {
              if (he.refCount--, he.refCount <= 0) {
                a.deleteProgram(he.program);
                var Ee = ie.indexOf(he);
                ie.splice(Ee, 1), _.shaderCount--;
              }
              W[he.vertId].refCount <= 0 && (a.deleteShader(I[he.vertId]), delete I[he.vertId], delete ne[he.fragId][he.vertId]), Object.keys(ne[he.fragId]).length || (a.deleteShader(j[he.fragId]), delete j[he.fragId], delete ne[he.fragId]);
            }
          });
        },
        restore: te,
        shader: Y,
        frag: -1,
        vert: -1
      };
    }
    var Bh = 6408, xr = 5121, Vh = 3333, ri = 5126;
    function $h(a, h, _, R, j, I, G) {
      function Z(ie) {
        var re;
        h.next === null ? (d(
          j.preserveDrawingBuffer,
          'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer'
        ), re = xr) : (d(
          h.next.colorAttachments[0].texture !== null,
          "You cannot read from a renderbuffer"
        ), re = h.next.colorAttachments[0].texture._texture.type, d.optional(function() {
          I.oes_texture_float ? (d(
            re === xr || re === ri,
            "Reading from a framebuffer is only allowed for the types 'uint8' and 'float'"
          ), re === ri && d(G.readFloat, "Reading 'float' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float")) : d(
            re === xr,
            "Reading from a framebuffer is only allowed for the type 'uint8'"
          );
        }));
        var fe = 0, Q = 0, te = R.framebufferWidth, C = R.framebufferHeight, O = null;
        n(ie) ? O = ie : ie && (d.type(ie, "object", "invalid arguments to regl.read()"), fe = ie.x | 0, Q = ie.y | 0, d(
          fe >= 0 && fe < R.framebufferWidth,
          "invalid x offset for regl.read"
        ), d(
          Q >= 0 && Q < R.framebufferHeight,
          "invalid y offset for regl.read"
        ), te = (ie.width || R.framebufferWidth - fe) | 0, C = (ie.height || R.framebufferHeight - Q) | 0, O = ie.data || null), O && (re === xr ? d(
          O instanceof Uint8Array,
          "buffer must be 'Uint8Array' when reading from a framebuffer of type 'uint8'"
        ) : re === ri && d(
          O instanceof Float32Array,
          "buffer must be 'Float32Array' when reading from a framebuffer of type 'float'"
        )), d(
          te > 0 && te + fe <= R.framebufferWidth,
          "invalid width for read pixels"
        ), d(
          C > 0 && C + Q <= R.framebufferHeight,
          "invalid height for read pixels"
        ), _();
        var ee = te * C * 4;
        return O || (re === xr ? O = new Uint8Array(ee) : re === ri && (O = O || new Float32Array(ee))), d.isTypedArray(O, "data buffer for regl.read() must be a typedarray"), d(O.byteLength >= ee, "data buffer for regl.read() too small"), a.pixelStorei(Vh, 4), a.readPixels(
          fe,
          Q,
          te,
          C,
          Bh,
          re,
          O
        ), O;
      }
      function Y(ie) {
        var re;
        return h.setFBO({
          framebuffer: ie.framebuffer
        }, function() {
          re = Z(ie);
        }), re;
      }
      function ne(ie) {
        return !ie || !("framebuffer" in ie) ? Z(ie) : Y(ie);
      }
      return ne;
    }
    function Qn(a) {
      return Array.prototype.slice.call(a);
    }
    function Kn(a) {
      return Qn(a).join("");
    }
    function jh() {
      var a = 0, h = [], _ = [];
      function R(re) {
        for (var fe = 0; fe < _.length; ++fe)
          if (_[fe] === re)
            return h[fe];
        var Q = "g" + a++;
        return h.push(Q), _.push(re), Q;
      }
      function j() {
        var re = [];
        function fe() {
          re.push.apply(re, Qn(arguments));
        }
        var Q = [];
        function te() {
          var C = "v" + a++;
          return Q.push(C), arguments.length > 0 && (re.push(C, "="), re.push.apply(re, Qn(arguments)), re.push(";")), C;
        }
        return r(fe, {
          def: te,
          toString: function() {
            return Kn([
              Q.length > 0 ? "var " + Q.join(",") + ";" : "",
              Kn(re)
            ]);
          }
        });
      }
      function I() {
        var re = j(), fe = j(), Q = re.toString, te = fe.toString;
        function C(O, ee) {
          fe(O, ee, "=", re.def(O, ee), ";");
        }
        return r(function() {
          re.apply(re, Qn(arguments));
        }, {
          def: re.def,
          entry: re,
          exit: fe,
          save: C,
          set: function(O, ee, ge) {
            C(O, ee), re(O, ee, "=", ge, ";");
          },
          toString: function() {
            return Q() + te();
          }
        });
      }
      function G() {
        var re = Kn(arguments), fe = I(), Q = I(), te = fe.toString, C = Q.toString;
        return r(fe, {
          then: function() {
            return fe.apply(fe, Qn(arguments)), this;
          },
          else: function() {
            return Q.apply(Q, Qn(arguments)), this;
          },
          toString: function() {
            var O = C();
            return O && (O = "else{" + O + "}"), Kn([
              "if(",
              re,
              "){",
              te(),
              "}",
              O
            ]);
          }
        });
      }
      var Z = j(), Y = {};
      function ne(re, fe) {
        var Q = [];
        function te() {
          var W = "a" + Q.length;
          return Q.push(W), W;
        }
        fe = fe || 0;
        for (var C = 0; C < fe; ++C)
          te();
        var O = I(), ee = O.toString, ge = Y[re] = r(O, {
          arg: te,
          toString: function() {
            return Kn([
              "function(",
              Q.join(),
              "){",
              ee(),
              "}"
            ]);
          }
        });
        return ge;
      }
      function ie() {
        var re = [
          '"use strict";',
          Z,
          "return {"
        ];
        Object.keys(Y).forEach(function(te) {
          re.push('"', te, '":', Y[te].toString(), ",");
        }), re.push("}");
        var fe = Kn(re).replace(/;/g, `;
`).replace(/}/g, `}
`).replace(/{/g, `{
`), Q = Function.apply(null, h.concat(fe));
        return Q.apply(null, _);
      }
      return {
        global: Z,
        link: R,
        block: j,
        proc: ne,
        scope: I,
        cond: G,
        compile: ie
      };
    }
    var Jn = "xyzw".split(""), Ys = 5121, er = 1, _o = 2, So = 0, wo = 1, To = 2, Ao = 3, ii = 4, Zs = 5, Qs = 6, Ks = "dither", Js = "blend.enable", ef = "blend.color", Eo = "blend.equation", Po = "blend.func", tf = "depth.enable", nf = "depth.func", rf = "depth.range", of = "depth.mask", Co = "colorMask", af = "cull.enable", sf = "cull.face", ko = "frontFace", Fo = "lineWidth", ff = "polygonOffset.enable", Lo = "polygonOffset.offset", uf = "sample.alpha", cf = "sample.enable", zo = "sample.coverage", lf = "stencil.enable", hf = "stencil.mask", Io = "stencil.func", Ro = "stencil.opFront", yr = "stencil.opBack", df = "scissor.enable", oi = "scissor.box", an = "viewport", br = "profile", kn = "framebuffer", _r = "vert", Sr = "frag", Fn = "elements", Ln = "primitive", zn = "count", ai = "offset", si = "instances", wr = "vao", Do = "Width", Mo = "Height", tr = kn + Do, nr = kn + Mo, Uh = an + Do, Xh = an + Mo, mf = "drawingBuffer", pf = mf + Do, vf = mf + Mo, Hh = [
      Po,
      Eo,
      Io,
      Ro,
      yr,
      zo,
      an,
      oi,
      Lo
    ], rr = 34962, Oo = 34963, Wh = 35632, qh = 35633, gf = 3553, Yh = 34067, Zh = 2884, Qh = 3042, Kh = 3024, Jh = 2960, ed = 2929, td = 3089, nd = 32823, rd = 32926, id = 32928, No = 5126, fi = 35664, ui = 35665, ci = 35666, Go = 5124, li = 35667, hi = 35668, di = 35669, Bo = 35670, mi = 35671, pi = 35672, vi = 35673, Tr = 35674, Ar = 35675, Er = 35676, Pr = 35678, Cr = 35680, Vo = 4, kr = 1028, In = 1029, xf = 2304, $o = 2305, od = 32775, ad = 32776, sd = 519, gn = 7680, yf = 0, bf = 1, _f = 32774, fd = 513, Sf = 36160, ud = 36064, Qt = {
      0: 0,
      1: 1,
      zero: 0,
      one: 1,
      "src color": 768,
      "one minus src color": 769,
      "src alpha": 770,
      "one minus src alpha": 771,
      "dst color": 774,
      "one minus dst color": 775,
      "dst alpha": 772,
      "one minus dst alpha": 773,
      "constant color": 32769,
      "one minus constant color": 32770,
      "constant alpha": 32771,
      "one minus constant alpha": 32772,
      "src alpha saturate": 776
    }, wf = [
      "constant color, constant alpha",
      "one minus constant color, constant alpha",
      "constant color, one minus constant alpha",
      "one minus constant color, one minus constant alpha",
      "constant alpha, constant color",
      "constant alpha, one minus constant color",
      "one minus constant alpha, constant color",
      "one minus constant alpha, one minus constant color"
    ], ir = {
      never: 512,
      less: 513,
      "<": 513,
      equal: 514,
      "=": 514,
      "==": 514,
      "===": 514,
      lequal: 515,
      "<=": 515,
      greater: 516,
      ">": 516,
      notequal: 517,
      "!=": 517,
      "!==": 517,
      gequal: 518,
      ">=": 518,
      always: 519
    }, xn = {
      0: 0,
      zero: 0,
      keep: 7680,
      replace: 7681,
      increment: 7682,
      decrement: 7683,
      "increment wrap": 34055,
      "decrement wrap": 34056,
      invert: 5386
    }, Tf = {
      frag: Wh,
      vert: qh
    }, jo = {
      cw: xf,
      ccw: $o
    };
    function gi(a) {
      return Array.isArray(a) || n(a) || Ut(a);
    }
    function Af(a) {
      return a.sort(function(h, _) {
        return h === an ? -1 : _ === an ? 1 : h < _ ? -1 : 1;
      });
    }
    function xt(a, h, _, R) {
      this.thisDep = a, this.contextDep = h, this.propDep = _, this.append = R;
    }
    function yn(a) {
      return a && !(a.thisDep || a.contextDep || a.propDep);
    }
    function dt(a) {
      return new xt(false, false, false, a);
    }
    function Ct(a, h) {
      var _ = a.type;
      if (_ === So) {
        var R = a.data.length;
        return new xt(
          true,
          R >= 1,
          R >= 2,
          h
        );
      } else if (_ === ii) {
        var j = a.data;
        return new xt(
          j.thisDep,
          j.contextDep,
          j.propDep,
          h
        );
      } else {
        if (_ === Zs)
          return new xt(
            false,
            false,
            false,
            h
          );
        if (_ === Qs) {
          for (var I = false, G = false, Z = false, Y = 0; Y < a.data.length; ++Y) {
            var ne = a.data[Y];
            if (ne.type === wo)
              Z = true;
            else if (ne.type === To)
              G = true;
            else if (ne.type === Ao)
              I = true;
            else if (ne.type === So) {
              I = true;
              var ie = ne.data;
              ie >= 1 && (G = true), ie >= 2 && (Z = true);
            } else ne.type === ii && (I = I || ne.data.thisDep, G = G || ne.data.contextDep, Z = Z || ne.data.propDep);
          }
          return new xt(
            I,
            G,
            Z,
            h
          );
        } else
          return new xt(
            _ === Ao,
            _ === To,
            _ === wo,
            h
          );
      }
    }
    var Ef = new xt(false, false, false, function() {
    });
    function cd(a, h, _, R, j, I, G, Z, Y, ne, ie, re, fe, Q, te) {
      var C = ne.Record, O = {
        add: 32774,
        subtract: 32778,
        "reverse subtract": 32779
      };
      _.ext_blend_minmax && (O.min = od, O.max = ad);
      var ee = _.angle_instanced_arrays, ge = _.webgl_draw_buffers, W = _.oes_vertex_array_object, me = {
        dirty: true,
        profile: te.profile
      }, he = {}, Ee = [], U = {}, $ = {};
      function be(m) {
        return m.replace(".", "_");
      }
      function ue(m, c, w) {
        var P = be(m);
        Ee.push(m), he[P] = me[P] = !!w, U[P] = c;
      }
      function J(m, c, w) {
        var P = be(m);
        Ee.push(m), Array.isArray(w) ? (me[P] = w.slice(), he[P] = w.slice()) : me[P] = he[P] = w, $[P] = c;
      }
      ue(Ks, Kh), ue(Js, Qh), J(ef, "blendColor", [0, 0, 0, 0]), J(
        Eo,
        "blendEquationSeparate",
        [_f, _f]
      ), J(
        Po,
        "blendFuncSeparate",
        [bf, yf, bf, yf]
      ), ue(tf, ed, true), J(nf, "depthFunc", fd), J(rf, "depthRange", [0, 1]), J(of, "depthMask", true), J(Co, Co, [true, true, true, true]), ue(af, Zh), J(sf, "cullFace", In), J(ko, ko, $o), J(Fo, Fo, 1), ue(ff, nd), J(Lo, "polygonOffset", [0, 0]), ue(uf, rd), ue(cf, id), J(zo, "sampleCoverage", [1, false]), ue(lf, Jh), J(hf, "stencilMask", -1), J(Io, "stencilFunc", [sd, 0, -1]), J(
        Ro,
        "stencilOpSeparate",
        [kr, gn, gn, gn]
      ), J(
        yr,
        "stencilOpSeparate",
        [In, gn, gn, gn]
      ), ue(df, td), J(
        oi,
        "scissor",
        [0, 0, a.drawingBufferWidth, a.drawingBufferHeight]
      ), J(
        an,
        an,
        [0, 0, a.drawingBufferWidth, a.drawingBufferHeight]
      );
      var ce = {
        gl: a,
        context: fe,
        strings: h,
        next: he,
        current: me,
        draw: re,
        elements: I,
        buffer: j,
        shader: ie,
        attributes: ne.state,
        vao: ne,
        uniforms: Y,
        framebuffer: Z,
        extensions: _,
        timer: Q,
        isBufferArgs: gi
      }, le = {
        primTypes: pn,
        compareFuncs: ir,
        blendFuncs: Qt,
        blendEquations: O,
        stencilOps: xn,
        glTypes: Tn,
        orientationType: jo
      };
      d.optional(function() {
        ce.isArrayLike = ot;
      }), ge && (le.backBuffer = [In], le.drawBuffer = Dt(R.maxDrawbuffers, function(m) {
        return m === 0 ? [0] : Dt(m, function(c) {
          return ud + c;
        });
      }));
      var Me = 0;
      function Re() {
        var m = jh(), c = m.link, w = m.global;
        m.id = Me++, m.batchId = "0";
        var P = c(ce), k = m.shared = {
          props: "a0"
        };
        Object.keys(ce).forEach(function(y) {
          k[y] = w.def(P, ".", y);
        }), d.optional(function() {
          m.CHECK = c(d), m.commandStr = d.guessCommand(), m.command = c(m.commandStr), m.assert = function(y, g, L) {
            y(
              "if(!(",
              g,
              "))",
              this.CHECK,
              ".commandRaise(",
              c(L),
              ",",
              this.command,
              ");"
            );
          }, le.invalidBlendCombinations = wf;
        });
        var A = m.next = {}, T = m.current = {};
        Object.keys($).forEach(function(y) {
          Array.isArray(me[y]) && (A[y] = w.def(k.next, ".", y), T[y] = w.def(k.current, ".", y));
        });
        var E = m.constants = {};
        Object.keys(le).forEach(function(y) {
          E[y] = w.def(JSON.stringify(le[y]));
        }), m.invoke = function(y, g) {
          switch (g.type) {
            case So:
              var L = [
                "this",
                k.context,
                k.props,
                m.batchId
              ];
              return y.def(
                c(g.data),
                ".call(",
                L.slice(0, Math.max(g.data.length + 1, 4)),
                ")"
              );
            case wo:
              return y.def(k.props, g.data);
            case To:
              return y.def(k.context, g.data);
            case Ao:
              return y.def("this", g.data);
            case ii:
              return g.data.append(m, y), g.data.ref;
            case Zs:
              return g.data.toString();
            case Qs:
              return g.data.map(function(F) {
                return m.invoke(y, F);
              });
          }
        }, m.attribCache = {};
        var p = {};
        return m.scopeAttrib = function(y) {
          var g = h.id(y);
          if (g in p)
            return p[g];
          var L = ne.scope[g];
          L || (L = ne.scope[g] = new C());
          var F = p[g] = c(L);
          return F;
        }, m;
      }
      function de(m) {
        var c = m.static, w = m.dynamic, P;
        if (br in c) {
          var k = !!c[br];
          P = dt(function(T, E) {
            return k;
          }), P.enable = k;
        } else if (br in w) {
          var A = w[br];
          P = Ct(A, function(T, E) {
            return T.invoke(E, A);
          });
        }
        return P;
      }
      function ve(m, c) {
        var w = m.static, P = m.dynamic;
        if (kn in w) {
          var k = w[kn];
          return k ? (k = Z.getFramebuffer(k), d.command(k, "invalid framebuffer object"), dt(function(T, E) {
            var p = T.link(k), y = T.shared;
            E.set(
              y.framebuffer,
              ".next",
              p
            );
            var g = y.context;
            return E.set(
              g,
              "." + tr,
              p + ".width"
            ), E.set(
              g,
              "." + nr,
              p + ".height"
            ), p;
          })) : dt(function(T, E) {
            var p = T.shared;
            E.set(
              p.framebuffer,
              ".next",
              "null"
            );
            var y = p.context;
            return E.set(
              y,
              "." + tr,
              y + "." + pf
            ), E.set(
              y,
              "." + nr,
              y + "." + vf
            ), "null";
          });
        } else if (kn in P) {
          var A = P[kn];
          return Ct(A, function(T, E) {
            var p = T.invoke(E, A), y = T.shared, g = y.framebuffer, L = E.def(
              g,
              ".getFramebuffer(",
              p,
              ")"
            );
            d.optional(function() {
              T.assert(
                E,
                "!" + p + "||" + L,
                "invalid framebuffer object"
              );
            }), E.set(
              g,
              ".next",
              L
            );
            var F = y.context;
            return E.set(
              F,
              "." + tr,
              L + "?" + L + ".width:" + F + "." + pf
            ), E.set(
              F,
              "." + nr,
              L + "?" + L + ".height:" + F + "." + vf
            ), L;
          });
        } else
          return null;
      }
      function Fe(m, c, w) {
        var P = m.static, k = m.dynamic;
        function A(p) {
          if (p in P) {
            var y = P[p];
            d.commandType(y, "object", "invalid " + p, w.commandStr);
            var g = true, L = y.x | 0, F = y.y | 0, V, X;
            return "width" in y ? (V = y.width | 0, d.command(V >= 0, "invalid " + p, w.commandStr)) : g = false, "height" in y ? (X = y.height | 0, d.command(X >= 0, "invalid " + p, w.commandStr)) : g = false, new xt(
              !g && c && c.thisDep,
              !g && c && c.contextDep,
              !g && c && c.propDep,
              function(Ae, xe) {
                var H = Ae.shared.context, B = V;
                "width" in y || (B = xe.def(H, ".", tr, "-", L));
                var Se = X;
                return "height" in y || (Se = xe.def(H, ".", nr, "-", F)), [L, F, B, Se];
              }
            );
          } else if (p in k) {
            var se = k[p], Ie = Ct(se, function(Ae, xe) {
              var H = Ae.invoke(xe, se);
              d.optional(function() {
                Ae.assert(
                  xe,
                  H + "&&typeof " + H + '==="object"',
                  "invalid " + p
                );
              });
              var B = Ae.shared.context, Se = xe.def(H, ".x|0"), _e = xe.def(H, ".y|0"), Le = xe.def(
                '"width" in ',
                H,
                "?",
                H,
                ".width|0:",
                "(",
                B,
                ".",
                tr,
                "-",
                Se,
                ")"
              ), Je = xe.def(
                '"height" in ',
                H,
                "?",
                H,
                ".height|0:",
                "(",
                B,
                ".",
                nr,
                "-",
                _e,
                ")"
              );
              return d.optional(function() {
                Ae.assert(
                  xe,
                  Le + ">=0&&" + Je + ">=0",
                  "invalid " + p
                );
              }), [Se, _e, Le, Je];
            });
            return c && (Ie.thisDep = Ie.thisDep || c.thisDep, Ie.contextDep = Ie.contextDep || c.contextDep, Ie.propDep = Ie.propDep || c.propDep), Ie;
          } else return c ? new xt(
            c.thisDep,
            c.contextDep,
            c.propDep,
            function(Ae, xe) {
              var H = Ae.shared.context;
              return [
                0,
                0,
                xe.def(H, ".", tr),
                xe.def(H, ".", nr)
              ];
            }
          ) : null;
        }
        var T = A(an);
        if (T) {
          var E = T;
          T = new xt(
            T.thisDep,
            T.contextDep,
            T.propDep,
            function(p, y) {
              var g = E.append(p, y), L = p.shared.context;
              return y.set(
                L,
                "." + Uh,
                g[2]
              ), y.set(
                L,
                "." + Xh,
                g[3]
              ), g;
            }
          );
        }
        return {
          viewport: T,
          scissor_box: A(oi)
        };
      }
      function Oe(m, c) {
        var w = m.static, P = typeof w[Sr] == "string" && typeof w[_r] == "string";
        if (P) {
          if (Object.keys(c.dynamic).length > 0)
            return null;
          var k = c.static, A = Object.keys(k);
          if (A.length > 0 && typeof k[A[0]] == "number") {
            for (var T = [], E = 0; E < A.length; ++E)
              d(typeof k[A[E]] == "number", "must specify all vertex attribute locations when using vaos"), T.push([k[A[E]] | 0, A[E]]);
            return T;
          }
        }
        return null;
      }
      function Xe(m, c, w) {
        var P = m.static, k = m.dynamic;
        function A(g) {
          if (g in P) {
            var L = h.id(P[g]);
            d.optional(function() {
              ie.shader(Tf[g], L, d.guessCommand());
            });
            var F = dt(function() {
              return L;
            });
            return F.id = L, F;
          } else if (g in k) {
            var V = k[g];
            return Ct(V, function(X, se) {
              var Ie = X.invoke(se, V), Ae = se.def(X.shared.strings, ".id(", Ie, ")");
              return d.optional(function() {
                se(
                  X.shared.shader,
                  ".shader(",
                  Tf[g],
                  ",",
                  Ae,
                  ",",
                  X.command,
                  ");"
                );
              }), Ae;
            });
          }
          return null;
        }
        var T = A(Sr), E = A(_r), p = null, y;
        return yn(T) && yn(E) ? (p = ie.program(E.id, T.id, null, w), y = dt(function(g, L) {
          return g.link(p);
        })) : y = new xt(
          T && T.thisDep || E && E.thisDep,
          T && T.contextDep || E && E.contextDep,
          T && T.propDep || E && E.propDep,
          function(g, L) {
            var F = g.shared.shader, V;
            T ? V = T.append(g, L) : V = L.def(F, ".", Sr);
            var X;
            E ? X = E.append(g, L) : X = L.def(F, ".", _r);
            var se = F + ".program(" + X + "," + V;
            return d.optional(function() {
              se += "," + g.command;
            }), L.def(se + ")");
          }
        ), {
          frag: T,
          vert: E,
          progVar: y,
          program: p
        };
      }
      function at(m, c) {
        var w = m.static, P = m.dynamic, k = {}, A = false;
        function T() {
          if (wr in w) {
            var xe = w[wr];
            return xe !== null && ne.getVAO(xe) === null && (xe = ne.createVAO(xe)), A = true, k.vao = xe, dt(function(B) {
              var Se = ne.getVAO(xe);
              return Se ? B.link(Se) : "null";
            });
          } else if (wr in P) {
            A = true;
            var H = P[wr];
            return Ct(H, function(B, Se) {
              var _e = B.invoke(Se, H);
              return Se.def(B.shared.vao + ".getVAO(" + _e + ")");
            });
          }
          return null;
        }
        var E = T(), p = false;
        function y() {
          if (Fn in w) {
            var xe = w[Fn];
            if (k.elements = xe, gi(xe)) {
              var H = k.elements = I.create(xe, true);
              xe = I.getElements(H), p = true;
            } else xe && (xe = I.getElements(xe), p = true, d.command(xe, "invalid elements", c.commandStr));
            var B = dt(function(_e, Le) {
              if (xe) {
                var Je = _e.link(xe);
                return _e.ELEMENTS = Je, Je;
              }
              return _e.ELEMENTS = null, null;
            });
            return B.value = xe, B;
          } else if (Fn in P) {
            p = true;
            var Se = P[Fn];
            return Ct(Se, function(_e, Le) {
              var Je = _e.shared, Pt = Je.isBufferArgs, Dn = Je.elements, sn = _e.invoke(Le, Se), Jt = Le.def("null"), bn = Le.def(Pt, "(", sn, ")"), Mn = _e.cond(bn).then(Jt, "=", Dn, ".createStream(", sn, ");").else(Jt, "=", Dn, ".getElements(", sn, ");");
              return d.optional(function() {
                _e.assert(
                  Mn.else,
                  "!" + sn + "||" + Jt,
                  "invalid elements"
                );
              }), Le.entry(Mn), Le.exit(
                _e.cond(bn).then(Dn, ".destroyStream(", Jt, ");")
              ), _e.ELEMENTS = Jt, Jt;
            });
          } else if (A)
            return new xt(
              E.thisDep,
              E.contextDep,
              E.propDep,
              function(_e, Le) {
                return Le.def(_e.shared.vao + ".currentVAO?" + _e.shared.elements + ".getElements(" + _e.shared.vao + ".currentVAO.elements):null");
              }
            );
          return null;
        }
        var g = y();
        function L() {
          if (Ln in w) {
            var xe = w[Ln];
            return k.primitive = xe, d.commandParameter(xe, pn, "invalid primitve", c.commandStr), dt(function(B, Se) {
              return pn[xe];
            });
          } else if (Ln in P) {
            var H = P[Ln];
            return Ct(H, function(B, Se) {
              var _e = B.constants.primTypes, Le = B.invoke(Se, H);
              return d.optional(function() {
                B.assert(
                  Se,
                  Le + " in " + _e,
                  "invalid primitive, must be one of " + Object.keys(pn)
                );
              }), Se.def(_e, "[", Le, "]");
            });
          } else {
            if (p)
              return yn(g) ? g.value ? dt(function(B, Se) {
                return Se.def(B.ELEMENTS, ".primType");
              }) : dt(function() {
                return Vo;
              }) : new xt(
                g.thisDep,
                g.contextDep,
                g.propDep,
                function(B, Se) {
                  var _e = B.ELEMENTS;
                  return Se.def(_e, "?", _e, ".primType:", Vo);
                }
              );
            if (A)
              return new xt(
                E.thisDep,
                E.contextDep,
                E.propDep,
                function(B, Se) {
                  return Se.def(B.shared.vao + ".currentVAO?" + B.shared.vao + ".currentVAO.primitive:" + Vo);
                }
              );
          }
          return null;
        }
        function F(xe, H) {
          if (xe in w) {
            var B = w[xe] | 0;
            return H ? k.offset = B : k.instances = B, d.command(!H || B >= 0, "invalid " + xe, c.commandStr), dt(function(_e, Le) {
              return H && (_e.OFFSET = B), B;
            });
          } else if (xe in P) {
            var Se = P[xe];
            return Ct(Se, function(_e, Le) {
              var Je = _e.invoke(Le, Se);
              return H && (_e.OFFSET = Je, d.optional(function() {
                _e.assert(
                  Le,
                  Je + ">=0",
                  "invalid " + xe
                );
              })), Je;
            });
          } else if (H) {
            if (p)
              return dt(function(_e, Le) {
                return _e.OFFSET = 0, 0;
              });
            if (A)
              return new xt(
                E.thisDep,
                E.contextDep,
                E.propDep,
                function(_e, Le) {
                  return Le.def(_e.shared.vao + ".currentVAO?" + _e.shared.vao + ".currentVAO.offset:0");
                }
              );
          } else if (A)
            return new xt(
              E.thisDep,
              E.contextDep,
              E.propDep,
              function(_e, Le) {
                return Le.def(_e.shared.vao + ".currentVAO?" + _e.shared.vao + ".currentVAO.instances:-1");
              }
            );
          return null;
        }
        var V = F(ai, true);
        function X() {
          if (zn in w) {
            var xe = w[zn] | 0;
            return k.count = xe, d.command(
              typeof xe == "number" && xe >= 0,
              "invalid vertex count",
              c.commandStr
            ), dt(function() {
              return xe;
            });
          } else if (zn in P) {
            var H = P[zn];
            return Ct(H, function(Le, Je) {
              var Pt = Le.invoke(Je, H);
              return d.optional(function() {
                Le.assert(
                  Je,
                  "typeof " + Pt + '==="number"&&' + Pt + ">=0&&" + Pt + "===(" + Pt + "|0)",
                  "invalid vertex count"
                );
              }), Pt;
            });
          } else if (p)
            if (yn(g)) {
              if (g)
                return V ? new xt(
                  V.thisDep,
                  V.contextDep,
                  V.propDep,
                  function(Le, Je) {
                    var Pt = Je.def(
                      Le.ELEMENTS,
                      ".vertCount-",
                      Le.OFFSET
                    );
                    return d.optional(function() {
                      Le.assert(
                        Je,
                        Pt + ">=0",
                        "invalid vertex offset/element buffer too small"
                      );
                    }), Pt;
                  }
                ) : dt(function(Le, Je) {
                  return Je.def(Le.ELEMENTS, ".vertCount");
                });
              var B = dt(function() {
                return -1;
              });
              return d.optional(function() {
                B.MISSING = true;
              }), B;
            } else {
              var Se = new xt(
                g.thisDep || V.thisDep,
                g.contextDep || V.contextDep,
                g.propDep || V.propDep,
                function(Le, Je) {
                  var Pt = Le.ELEMENTS;
                  return Le.OFFSET ? Je.def(
                    Pt,
                    "?",
                    Pt,
                    ".vertCount-",
                    Le.OFFSET,
                    ":-1"
                  ) : Je.def(Pt, "?", Pt, ".vertCount:-1");
                }
              );
              return d.optional(function() {
                Se.DYNAMIC = true;
              }), Se;
            }
          else if (A) {
            var _e = new xt(
              E.thisDep,
              E.contextDep,
              E.propDep,
              function(Le, Je) {
                return Je.def(Le.shared.vao, ".currentVAO?", Le.shared.vao, ".currentVAO.count:-1");
              }
            );
            return _e;
          }
          return null;
        }
        var se = L(), Ie = X(), Ae = F(si, false);
        return {
          elements: g,
          primitive: se,
          count: Ie,
          instances: Ae,
          offset: V,
          vao: E,
          vaoActive: A,
          elementsActive: p,
          // static draw props
          static: k
        };
      }
      function ft(m, c) {
        var w = m.static, P = m.dynamic, k = {};
        return Ee.forEach(function(A) {
          var T = be(A);
          function E(p, y) {
            if (A in w) {
              var g = p(w[A]);
              k[T] = dt(function() {
                return g;
              });
            } else if (A in P) {
              var L = P[A];
              k[T] = Ct(L, function(F, V) {
                return y(F, V, F.invoke(V, L));
              });
            }
          }
          switch (A) {
            case af:
            case Js:
            case Ks:
            case lf:
            case tf:
            case df:
            case ff:
            case uf:
            case cf:
            case of:
              return E(
                function(p) {
                  return d.commandType(p, "boolean", A, c.commandStr), p;
                },
                function(p, y, g) {
                  return d.optional(function() {
                    p.assert(
                      y,
                      "typeof " + g + '==="boolean"',
                      "invalid flag " + A,
                      p.commandStr
                    );
                  }), g;
                }
              );
            case nf:
              return E(
                function(p) {
                  return d.commandParameter(p, ir, "invalid " + A, c.commandStr), ir[p];
                },
                function(p, y, g) {
                  var L = p.constants.compareFuncs;
                  return d.optional(function() {
                    p.assert(
                      y,
                      g + " in " + L,
                      "invalid " + A + ", must be one of " + Object.keys(ir)
                    );
                  }), y.def(L, "[", g, "]");
                }
              );
            case rf:
              return E(
                function(p) {
                  return d.command(
                    ot(p) && p.length === 2 && typeof p[0] == "number" && typeof p[1] == "number" && p[0] <= p[1],
                    "depth range is 2d array",
                    c.commandStr
                  ), p;
                },
                function(p, y, g) {
                  d.optional(function() {
                    p.assert(
                      y,
                      p.shared.isArrayLike + "(" + g + ")&&" + g + ".length===2&&typeof " + g + '[0]==="number"&&typeof ' + g + '[1]==="number"&&' + g + "[0]<=" + g + "[1]",
                      "depth range must be a 2d array"
                    );
                  });
                  var L = y.def("+", g, "[0]"), F = y.def("+", g, "[1]");
                  return [L, F];
                }
              );
            case Po:
              return E(
                function(p) {
                  d.commandType(p, "object", "blend.func", c.commandStr);
                  var y = "srcRGB" in p ? p.srcRGB : p.src, g = "srcAlpha" in p ? p.srcAlpha : p.src, L = "dstRGB" in p ? p.dstRGB : p.dst, F = "dstAlpha" in p ? p.dstAlpha : p.dst;
                  return d.commandParameter(y, Qt, T + ".srcRGB", c.commandStr), d.commandParameter(g, Qt, T + ".srcAlpha", c.commandStr), d.commandParameter(L, Qt, T + ".dstRGB", c.commandStr), d.commandParameter(F, Qt, T + ".dstAlpha", c.commandStr), d.command(
                    wf.indexOf(y + ", " + L) === -1,
                    "unallowed blending combination (srcRGB, dstRGB) = (" + y + ", " + L + ")",
                    c.commandStr
                  ), [
                    Qt[y],
                    Qt[L],
                    Qt[g],
                    Qt[F]
                  ];
                },
                function(p, y, g) {
                  var L = p.constants.blendFuncs;
                  d.optional(function() {
                    p.assert(
                      y,
                      g + "&&typeof " + g + '==="object"',
                      "invalid blend func, must be an object"
                    );
                  });
                  function F(H, B) {
                    var Se = y.def(
                      '"',
                      H,
                      B,
                      '" in ',
                      g,
                      "?",
                      g,
                      ".",
                      H,
                      B,
                      ":",
                      g,
                      ".",
                      H
                    );
                    return d.optional(function() {
                      p.assert(
                        y,
                        Se + " in " + L,
                        "invalid " + A + "." + H + B + ", must be one of " + Object.keys(Qt)
                      );
                    }), Se;
                  }
                  var V = F("src", "RGB"), X = F("dst", "RGB");
                  d.optional(function() {
                    var H = p.constants.invalidBlendCombinations;
                    p.assert(
                      y,
                      H + ".indexOf(" + V + '+", "+' + X + ") === -1 ",
                      "unallowed blending combination for (srcRGB, dstRGB)"
                    );
                  });
                  var se = y.def(L, "[", V, "]"), Ie = y.def(L, "[", F("src", "Alpha"), "]"), Ae = y.def(L, "[", X, "]"), xe = y.def(L, "[", F("dst", "Alpha"), "]");
                  return [se, Ae, Ie, xe];
                }
              );
            case Eo:
              return E(
                function(p) {
                  if (typeof p == "string")
                    return d.commandParameter(p, O, "invalid " + A, c.commandStr), [
                      O[p],
                      O[p]
                    ];
                  if (typeof p == "object")
                    return d.commandParameter(
                      p.rgb,
                      O,
                      A + ".rgb",
                      c.commandStr
                    ), d.commandParameter(
                      p.alpha,
                      O,
                      A + ".alpha",
                      c.commandStr
                    ), [
                      O[p.rgb],
                      O[p.alpha]
                    ];
                  d.commandRaise("invalid blend.equation", c.commandStr);
                },
                function(p, y, g) {
                  var L = p.constants.blendEquations, F = y.def(), V = y.def(), X = p.cond("typeof ", g, '==="string"');
                  return d.optional(function() {
                    function se(Ie, Ae, xe) {
                      p.assert(
                        Ie,
                        xe + " in " + L,
                        "invalid " + Ae + ", must be one of " + Object.keys(O)
                      );
                    }
                    se(X.then, A, g), p.assert(
                      X.else,
                      g + "&&typeof " + g + '==="object"',
                      "invalid " + A
                    ), se(X.else, A + ".rgb", g + ".rgb"), se(X.else, A + ".alpha", g + ".alpha");
                  }), X.then(
                    F,
                    "=",
                    V,
                    "=",
                    L,
                    "[",
                    g,
                    "];"
                  ), X.else(
                    F,
                    "=",
                    L,
                    "[",
                    g,
                    ".rgb];",
                    V,
                    "=",
                    L,
                    "[",
                    g,
                    ".alpha];"
                  ), y(X), [F, V];
                }
              );
            case ef:
              return E(
                function(p) {
                  return d.command(
                    ot(p) && p.length === 4,
                    "blend.color must be a 4d array",
                    c.commandStr
                  ), Dt(4, function(y) {
                    return +p[y];
                  });
                },
                function(p, y, g) {
                  return d.optional(function() {
                    p.assert(
                      y,
                      p.shared.isArrayLike + "(" + g + ")&&" + g + ".length===4",
                      "blend.color must be a 4d array"
                    );
                  }), Dt(4, function(L) {
                    return y.def("+", g, "[", L, "]");
                  });
                }
              );
            case hf:
              return E(
                function(p) {
                  return d.commandType(p, "number", T, c.commandStr), p | 0;
                },
                function(p, y, g) {
                  return d.optional(function() {
                    p.assert(
                      y,
                      "typeof " + g + '==="number"',
                      "invalid stencil.mask"
                    );
                  }), y.def(g, "|0");
                }
              );
            case Io:
              return E(
                function(p) {
                  d.commandType(p, "object", T, c.commandStr);
                  var y = p.cmp || "keep", g = p.ref || 0, L = "mask" in p ? p.mask : -1;
                  return d.commandParameter(y, ir, A + ".cmp", c.commandStr), d.commandType(g, "number", A + ".ref", c.commandStr), d.commandType(L, "number", A + ".mask", c.commandStr), [
                    ir[y],
                    g,
                    L
                  ];
                },
                function(p, y, g) {
                  var L = p.constants.compareFuncs;
                  d.optional(function() {
                    function se() {
                      p.assert(
                        y,
                        Array.prototype.join.call(arguments, ""),
                        "invalid stencil.func"
                      );
                    }
                    se(g + "&&typeof ", g, '==="object"'), se(
                      '!("cmp" in ',
                      g,
                      ")||(",
                      g,
                      ".cmp in ",
                      L,
                      ")"
                    );
                  });
                  var F = y.def(
                    '"cmp" in ',
                    g,
                    "?",
                    L,
                    "[",
                    g,
                    ".cmp]",
                    ":",
                    gn
                  ), V = y.def(g, ".ref|0"), X = y.def(
                    '"mask" in ',
                    g,
                    "?",
                    g,
                    ".mask|0:-1"
                  );
                  return [F, V, X];
                }
              );
            case Ro:
            case yr:
              return E(
                function(p) {
                  d.commandType(p, "object", T, c.commandStr);
                  var y = p.fail || "keep", g = p.zfail || "keep", L = p.zpass || "keep";
                  return d.commandParameter(y, xn, A + ".fail", c.commandStr), d.commandParameter(g, xn, A + ".zfail", c.commandStr), d.commandParameter(L, xn, A + ".zpass", c.commandStr), [
                    A === yr ? In : kr,
                    xn[y],
                    xn[g],
                    xn[L]
                  ];
                },
                function(p, y, g) {
                  var L = p.constants.stencilOps;
                  d.optional(function() {
                    p.assert(
                      y,
                      g + "&&typeof " + g + '==="object"',
                      "invalid " + A
                    );
                  });
                  function F(V) {
                    return d.optional(function() {
                      p.assert(
                        y,
                        '!("' + V + '" in ' + g + ")||(" + g + "." + V + " in " + L + ")",
                        "invalid " + A + "." + V + ", must be one of " + Object.keys(xn)
                      );
                    }), y.def(
                      '"',
                      V,
                      '" in ',
                      g,
                      "?",
                      L,
                      "[",
                      g,
                      ".",
                      V,
                      "]:",
                      gn
                    );
                  }
                  return [
                    A === yr ? In : kr,
                    F("fail"),
                    F("zfail"),
                    F("zpass")
                  ];
                }
              );
            case Lo:
              return E(
                function(p) {
                  d.commandType(p, "object", T, c.commandStr);
                  var y = p.factor | 0, g = p.units | 0;
                  return d.commandType(y, "number", T + ".factor", c.commandStr), d.commandType(g, "number", T + ".units", c.commandStr), [y, g];
                },
                function(p, y, g) {
                  d.optional(function() {
                    p.assert(
                      y,
                      g + "&&typeof " + g + '==="object"',
                      "invalid " + A
                    );
                  });
                  var L = y.def(g, ".factor|0"), F = y.def(g, ".units|0");
                  return [L, F];
                }
              );
            case sf:
              return E(
                function(p) {
                  var y = 0;
                  return p === "front" ? y = kr : p === "back" && (y = In), d.command(!!y, T, c.commandStr), y;
                },
                function(p, y, g) {
                  return d.optional(function() {
                    p.assert(
                      y,
                      g + '==="front"||' + g + '==="back"',
                      "invalid cull.face"
                    );
                  }), y.def(g, '==="front"?', kr, ":", In);
                }
              );
            case Fo:
              return E(
                function(p) {
                  return d.command(
                    typeof p == "number" && p >= R.lineWidthDims[0] && p <= R.lineWidthDims[1],
                    "invalid line width, must be a positive number between " + R.lineWidthDims[0] + " and " + R.lineWidthDims[1],
                    c.commandStr
                  ), p;
                },
                function(p, y, g) {
                  return d.optional(function() {
                    p.assert(
                      y,
                      "typeof " + g + '==="number"&&' + g + ">=" + R.lineWidthDims[0] + "&&" + g + "<=" + R.lineWidthDims[1],
                      "invalid line width"
                    );
                  }), g;
                }
              );
            case ko:
              return E(
                function(p) {
                  return d.commandParameter(p, jo, T, c.commandStr), jo[p];
                },
                function(p, y, g) {
                  return d.optional(function() {
                    p.assert(
                      y,
                      g + '==="cw"||' + g + '==="ccw"',
                      "invalid frontFace, must be one of cw,ccw"
                    );
                  }), y.def(g + '==="cw"?' + xf + ":" + $o);
                }
              );
            case Co:
              return E(
                function(p) {
                  return d.command(
                    ot(p) && p.length === 4,
                    "color.mask must be length 4 array",
                    c.commandStr
                  ), p.map(function(y) {
                    return !!y;
                  });
                },
                function(p, y, g) {
                  return d.optional(function() {
                    p.assert(
                      y,
                      p.shared.isArrayLike + "(" + g + ")&&" + g + ".length===4",
                      "invalid color.mask"
                    );
                  }), Dt(4, function(L) {
                    return "!!" + g + "[" + L + "]";
                  });
                }
              );
            case zo:
              return E(
                function(p) {
                  d.command(typeof p == "object" && p, T, c.commandStr);
                  var y = "value" in p ? p.value : 1, g = !!p.invert;
                  return d.command(
                    typeof y == "number" && y >= 0 && y <= 1,
                    "sample.coverage.value must be a number between 0 and 1",
                    c.commandStr
                  ), [y, g];
                },
                function(p, y, g) {
                  d.optional(function() {
                    p.assert(
                      y,
                      g + "&&typeof " + g + '==="object"',
                      "invalid sample.coverage"
                    );
                  });
                  var L = y.def(
                    '"value" in ',
                    g,
                    "?+",
                    g,
                    ".value:1"
                  ), F = y.def("!!", g, ".invert");
                  return [L, F];
                }
              );
          }
        }), k;
      }
      function Ze(m, c) {
        var w = m.static, P = m.dynamic, k = {};
        return Object.keys(w).forEach(function(A) {
          var T = w[A], E;
          if (typeof T == "number" || typeof T == "boolean")
            E = dt(function() {
              return T;
            });
          else if (typeof T == "function") {
            var p = T._reglType;
            p === "texture2d" || p === "textureCube" ? E = dt(function(y) {
              return y.link(T);
            }) : p === "framebuffer" || p === "framebufferCube" ? (d.command(
              T.color.length > 0,
              'missing color attachment for framebuffer sent to uniform "' + A + '"',
              c.commandStr
            ), E = dt(function(y) {
              return y.link(T.color[0]);
            })) : d.commandRaise('invalid data for uniform "' + A + '"', c.commandStr);
          } else ot(T) ? E = dt(function(y) {
            var g = y.global.def(
              "[",
              Dt(T.length, function(L) {
                return d.command(
                  typeof T[L] == "number" || typeof T[L] == "boolean",
                  "invalid uniform " + A,
                  y.commandStr
                ), T[L];
              }),
              "]"
            );
            return g;
          }) : d.commandRaise('invalid or missing data for uniform "' + A + '"', c.commandStr);
          E.value = T, k[A] = E;
        }), Object.keys(P).forEach(function(A) {
          var T = P[A];
          k[A] = Ct(T, function(E, p) {
            return E.invoke(p, T);
          });
        }), k;
      }
      function pt(m, c) {
        var w = m.static, P = m.dynamic, k = {};
        return Object.keys(w).forEach(function(A) {
          var T = w[A], E = h.id(A), p = new C();
          if (gi(T))
            p.state = er, p.buffer = j.getBuffer(
              j.create(T, rr, false, true)
            ), p.type = 0;
          else {
            var y = j.getBuffer(T);
            if (y)
              p.state = er, p.buffer = y, p.type = 0;
            else if (d.command(
              typeof T == "object" && T,
              "invalid data for attribute " + A,
              c.commandStr
            ), "constant" in T) {
              var g = T.constant;
              p.buffer = "null", p.state = _o, typeof g == "number" ? p.x = g : (d.command(
                ot(g) && g.length > 0 && g.length <= 4,
                "invalid constant for attribute " + A,
                c.commandStr
              ), Jn.forEach(function(Ae, xe) {
                xe < g.length && (p[Ae] = g[xe]);
              }));
            } else {
              gi(T.buffer) ? y = j.getBuffer(
                j.create(T.buffer, rr, false, true)
              ) : y = j.getBuffer(T.buffer), d.command(!!y, 'missing buffer for attribute "' + A + '"', c.commandStr);
              var L = T.offset | 0;
              d.command(
                L >= 0,
                'invalid offset for attribute "' + A + '"',
                c.commandStr
              );
              var F = T.stride | 0;
              d.command(
                F >= 0 && F < 256,
                'invalid stride for attribute "' + A + '", must be integer betweeen [0, 255]',
                c.commandStr
              );
              var V = T.size | 0;
              d.command(
                !("size" in T) || V > 0 && V <= 4,
                'invalid size for attribute "' + A + '", must be 1,2,3,4',
                c.commandStr
              );
              var X = !!T.normalized, se = 0;
              "type" in T && (d.commandParameter(
                T.type,
                Tn,
                "invalid type for attribute " + A,
                c.commandStr
              ), se = Tn[T.type]);
              var Ie = T.divisor | 0;
              d.optional(function() {
                "divisor" in T && (d.command(
                  Ie === 0 || ee,
                  'cannot specify divisor for attribute "' + A + '", instancing not supported',
                  c.commandStr
                ), d.command(
                  Ie >= 0,
                  'invalid divisor for attribute "' + A + '"',
                  c.commandStr
                ));
                var Ae = c.commandStr, xe = [
                  "buffer",
                  "offset",
                  "divisor",
                  "normalized",
                  "type",
                  "size",
                  "stride"
                ];
                Object.keys(T).forEach(function(H) {
                  d.command(
                    xe.indexOf(H) >= 0,
                    'unknown parameter "' + H + '" for attribute pointer "' + A + '" (valid parameters are ' + xe + ")",
                    Ae
                  );
                });
              }), p.buffer = y, p.state = er, p.size = V, p.normalized = X, p.type = se || y.dtype, p.offset = L, p.stride = F, p.divisor = Ie;
            }
          }
          k[A] = dt(function(Ae, xe) {
            var H = Ae.attribCache;
            if (E in H)
              return H[E];
            var B = {
              isStream: false
            };
            return Object.keys(p).forEach(function(Se) {
              B[Se] = p[Se];
            }), p.buffer && (B.buffer = Ae.link(p.buffer), B.type = B.type || B.buffer + ".dtype"), H[E] = B, B;
          });
        }), Object.keys(P).forEach(function(A) {
          var T = P[A];
          function E(p, y) {
            var g = p.invoke(y, T), L = p.shared, F = p.constants, V = L.isBufferArgs, X = L.buffer;
            d.optional(function() {
              p.assert(
                y,
                g + "&&(typeof " + g + '==="object"||typeof ' + g + '==="function")&&(' + V + "(" + g + ")||" + X + ".getBuffer(" + g + ")||" + X + ".getBuffer(" + g + ".buffer)||" + V + "(" + g + '.buffer)||("constant" in ' + g + "&&(typeof " + g + '.constant==="number"||' + L.isArrayLike + "(" + g + ".constant))))",
                'invalid dynamic attribute "' + A + '"'
              );
            });
            var se = {
              isStream: y.def(false)
            }, Ie = new C();
            Ie.state = er, Object.keys(Ie).forEach(function(B) {
              se[B] = y.def("" + Ie[B]);
            });
            var Ae = se.buffer, xe = se.type;
            y(
              "if(",
              V,
              "(",
              g,
              ")){",
              se.isStream,
              "=true;",
              Ae,
              "=",
              X,
              ".createStream(",
              rr,
              ",",
              g,
              ");",
              xe,
              "=",
              Ae,
              ".dtype;",
              "}else{",
              Ae,
              "=",
              X,
              ".getBuffer(",
              g,
              ");",
              "if(",
              Ae,
              "){",
              xe,
              "=",
              Ae,
              ".dtype;",
              '}else if("constant" in ',
              g,
              "){",
              se.state,
              "=",
              _o,
              ";",
              "if(typeof " + g + '.constant === "number"){',
              se[Jn[0]],
              "=",
              g,
              ".constant;",
              Jn.slice(1).map(function(B) {
                return se[B];
              }).join("="),
              "=0;",
              "}else{",
              Jn.map(function(B, Se) {
                return se[B] + "=" + g + ".constant.length>" + Se + "?" + g + ".constant[" + Se + "]:0;";
              }).join(""),
              "}}else{",
              "if(",
              V,
              "(",
              g,
              ".buffer)){",
              Ae,
              "=",
              X,
              ".createStream(",
              rr,
              ",",
              g,
              ".buffer);",
              "}else{",
              Ae,
              "=",
              X,
              ".getBuffer(",
              g,
              ".buffer);",
              "}",
              xe,
              '="type" in ',
              g,
              "?",
              F.glTypes,
              "[",
              g,
              ".type]:",
              Ae,
              ".dtype;",
              se.normalized,
              "=!!",
              g,
              ".normalized;"
            );
            function H(B) {
              y(se[B], "=", g, ".", B, "|0;");
            }
            return H("size"), H("offset"), H("stride"), H("divisor"), y("}}"), y.exit(
              "if(",
              se.isStream,
              "){",
              X,
              ".destroyStream(",
              Ae,
              ");",
              "}"
            ), se;
          }
          k[A] = Ct(T, E);
        }), k;
      }
      function it(m) {
        var c = m.static, w = m.dynamic, P = {};
        return Object.keys(c).forEach(function(k) {
          var A = c[k];
          P[k] = dt(function(T, E) {
            return typeof A == "number" || typeof A == "boolean" ? "" + A : T.link(A);
          });
        }), Object.keys(w).forEach(function(k) {
          var A = w[k];
          P[k] = Ct(A, function(T, E) {
            return T.invoke(E, A);
          });
        }), P;
      }
      function mt(m, c, w, P, k) {
        var A = m.static, T = m.dynamic;
        d.optional(function() {
          var H = [
            kn,
            _r,
            Sr,
            Fn,
            Ln,
            ai,
            zn,
            si,
            br,
            wr
          ].concat(Ee);
          function B(Se) {
            Object.keys(Se).forEach(function(_e) {
              d.command(
                H.indexOf(_e) >= 0,
                'unknown parameter "' + _e + '"',
                k.commandStr
              );
            });
          }
          B(A), B(T);
        });
        var E = Oe(m, c), p = ve(m), y = Fe(m, p, k), g = at(m, k), L = ft(m, k), F = Xe(m, k, E);
        function V(H) {
          var B = y[H];
          B && (L[H] = B);
        }
        V(an), V(be(oi));
        var X = Object.keys(L).length > 0, se = {
          framebuffer: p,
          draw: g,
          shader: F,
          state: L,
          dirty: X,
          scopeVAO: null,
          drawVAO: null,
          useVAO: false,
          attributes: {}
        };
        if (se.profile = de(m), se.uniforms = Ze(w, k), se.drawVAO = se.scopeVAO = g.vao, !se.drawVAO && F.program && !E && _.angle_instanced_arrays && g.static.elements) {
          var Ie = true, Ae = F.program.attributes.map(function(H) {
            var B = c.static[H];
            return Ie = Ie && !!B, B;
          });
          if (Ie && Ae.length > 0) {
            var xe = ne.getVAO(ne.createVAO({
              attributes: Ae,
              elements: g.static.elements
            }));
            se.drawVAO = new xt(null, null, null, function(H, B) {
              return H.link(xe);
            }), se.useVAO = true;
          }
        }
        return E ? se.useVAO = true : se.attributes = pt(c, k), se.context = it(P), se;
      }
      function vt(m, c, w) {
        var P = m.shared, k = P.context, A = m.scope();
        Object.keys(w).forEach(function(T) {
          c.save(k, "." + T);
          var E = w[T], p = E.append(m, c);
          Array.isArray(p) ? A(k, ".", T, "=[", p.join(), "];") : A(k, ".", T, "=", p, ";");
        }), c(A);
      }
      function gt(m, c, w, P) {
        var k = m.shared, A = k.gl, T = k.framebuffer, E;
        ge && (E = c.def(k.extensions, ".webgl_draw_buffers"));
        var p = m.constants, y = p.drawBuffer, g = p.backBuffer, L;
        w ? L = w.append(m, c) : L = c.def(T, ".next"), P || c("if(", L, "!==", T, ".cur){"), c(
          "if(",
          L,
          "){",
          A,
          ".bindFramebuffer(",
          Sf,
          ",",
          L,
          ".framebuffer);"
        ), ge && c(
          E,
          ".drawBuffersWEBGL(",
          y,
          "[",
          L,
          ".colorAttachments.length]);"
        ), c(
          "}else{",
          A,
          ".bindFramebuffer(",
          Sf,
          ",null);"
        ), ge && c(E, ".drawBuffersWEBGL(", g, ");"), c(
          "}",
          T,
          ".cur=",
          L,
          ";"
        ), P || c("}");
      }
      function _t(m, c, w) {
        var P = m.shared, k = P.gl, A = m.current, T = m.next, E = P.current, p = P.next, y = m.cond(E, ".dirty");
        Ee.forEach(function(g) {
          var L = be(g);
          if (!(L in w.state)) {
            var F, V;
            if (L in T) {
              F = T[L], V = A[L];
              var X = Dt(me[L].length, function(Ie) {
                return y.def(F, "[", Ie, "]");
              });
              y(m.cond(X.map(function(Ie, Ae) {
                return Ie + "!==" + V + "[" + Ae + "]";
              }).join("||")).then(
                k,
                ".",
                $[L],
                "(",
                X,
                ");",
                X.map(function(Ie, Ae) {
                  return V + "[" + Ae + "]=" + Ie;
                }).join(";"),
                ";"
              ));
            } else {
              F = y.def(p, ".", L);
              var se = m.cond(F, "!==", E, ".", L);
              y(se), L in U ? se(
                m.cond(F).then(k, ".enable(", U[L], ");").else(k, ".disable(", U[L], ");"),
                E,
                ".",
                L,
                "=",
                F,
                ";"
              ) : se(
                k,
                ".",
                $[L],
                "(",
                F,
                ");",
                E,
                ".",
                L,
                "=",
                F,
                ";"
              );
            }
          }
        }), Object.keys(w.state).length === 0 && y(E, ".dirty=false;"), c(y);
      }
      function At(m, c, w, P) {
        var k = m.shared, A = m.current, T = k.current, E = k.gl;
        Af(Object.keys(w)).forEach(function(p) {
          var y = w[p];
          if (!(P && !P(y))) {
            var g = y.append(m, c);
            if (U[p]) {
              var L = U[p];
              yn(y) ? g ? c(E, ".enable(", L, ");") : c(E, ".disable(", L, ");") : c(m.cond(g).then(E, ".enable(", L, ");").else(E, ".disable(", L, ");")), c(T, ".", p, "=", g, ";");
            } else if (ot(g)) {
              var F = A[p];
              c(
                E,
                ".",
                $[p],
                "(",
                g,
                ");",
                g.map(function(V, X) {
                  return F + "[" + X + "]=" + V;
                }).join(";"),
                ";"
              );
            } else
              c(
                E,
                ".",
                $[p],
                "(",
                g,
                ");",
                T,
                ".",
                p,
                "=",
                g,
                ";"
              );
          }
        });
      }
      function ct(m, c) {
        ee && (m.instancing = c.def(
          m.shared.extensions,
          ".angle_instanced_arrays"
        ));
      }
      function Ve(m, c, w, P, k) {
        var A = m.shared, T = m.stats, E = A.current, p = A.timer, y = w.profile;
        function g() {
          return typeof performance > "u" ? "Date.now()" : "performance.now()";
        }
        var L, F;
        function V(H) {
          L = c.def(), H(L, "=", g(), ";"), typeof k == "string" ? H(T, ".count+=", k, ";") : H(T, ".count++;"), Q && (P ? (F = c.def(), H(F, "=", p, ".getNumPendingQueries();")) : H(p, ".beginQuery(", T, ");"));
        }
        function X(H) {
          H(T, ".cpuTime+=", g(), "-", L, ";"), Q && (P ? H(
            p,
            ".pushScopeStats(",
            F,
            ",",
            p,
            ".getNumPendingQueries(),",
            T,
            ");"
          ) : H(p, ".endQuery();"));
        }
        function se(H) {
          var B = c.def(E, ".profile");
          c(E, ".profile=", H, ";"), c.exit(E, ".profile=", B, ";");
        }
        var Ie;
        if (y) {
          if (yn(y)) {
            y.enable ? (V(c), X(c.exit), se("true")) : se("false");
            return;
          }
          Ie = y.append(m, c), se(Ie);
        } else
          Ie = c.def(E, ".profile");
        var Ae = m.block();
        V(Ae), c("if(", Ie, "){", Ae, "}");
        var xe = m.block();
        X(xe), c.exit("if(", Ie, "){", xe, "}");
      }
      function Et(m, c, w, P, k) {
        var A = m.shared;
        function T(p) {
          switch (p) {
            case fi:
            case li:
            case mi:
              return 2;
            case ui:
            case hi:
            case pi:
              return 3;
            case ci:
            case di:
            case vi:
              return 4;
            default:
              return 1;
          }
        }
        function E(p, y, g) {
          var L = A.gl, F = c.def(p, ".location"), V = c.def(A.attributes, "[", F, "]"), X = g.state, se = g.buffer, Ie = [
            g.x,
            g.y,
            g.z,
            g.w
          ], Ae = [
            "buffer",
            "normalized",
            "offset",
            "stride"
          ];
          function xe() {
            c(
              "if(!",
              V,
              ".buffer){",
              L,
              ".enableVertexAttribArray(",
              F,
              ");}"
            );
            var B = g.type, Se;
            if (g.size ? Se = c.def(g.size, "||", y) : Se = y, c(
              "if(",
              V,
              ".type!==",
              B,
              "||",
              V,
              ".size!==",
              Se,
              "||",
              Ae.map(function(Le) {
                return V + "." + Le + "!==" + g[Le];
              }).join("||"),
              "){",
              L,
              ".bindBuffer(",
              rr,
              ",",
              se,
              ".buffer);",
              L,
              ".vertexAttribPointer(",
              [
                F,
                Se,
                B,
                g.normalized,
                g.stride,
                g.offset
              ],
              ");",
              V,
              ".type=",
              B,
              ";",
              V,
              ".size=",
              Se,
              ";",
              Ae.map(function(Le) {
                return V + "." + Le + "=" + g[Le] + ";";
              }).join(""),
              "}"
            ), ee) {
              var _e = g.divisor;
              c(
                "if(",
                V,
                ".divisor!==",
                _e,
                "){",
                m.instancing,
                ".vertexAttribDivisorANGLE(",
                [F, _e],
                ");",
                V,
                ".divisor=",
                _e,
                ";}"
              );
            }
          }
          function H() {
            c(
              "if(",
              V,
              ".buffer){",
              L,
              ".disableVertexAttribArray(",
              F,
              ");",
              V,
              ".buffer=null;",
              "}if(",
              Jn.map(function(B, Se) {
                return V + "." + B + "!==" + Ie[Se];
              }).join("||"),
              "){",
              L,
              ".vertexAttrib4f(",
              F,
              ",",
              Ie,
              ");",
              Jn.map(function(B, Se) {
                return V + "." + B + "=" + Ie[Se] + ";";
              }).join(""),
              "}"
            );
          }
          X === er ? xe() : X === _o ? H() : (c("if(", X, "===", er, "){"), xe(), c("}else{"), H(), c("}"));
        }
        P.forEach(function(p) {
          var y = p.name, g = w.attributes[y], L;
          if (g) {
            if (!k(g))
              return;
            L = g.append(m, c);
          } else {
            if (!k(Ef))
              return;
            var F = m.scopeAttrib(y);
            d.optional(function() {
              m.assert(
                c,
                F + ".state",
                "missing attribute " + y
              );
            }), L = {}, Object.keys(new C()).forEach(function(V) {
              L[V] = c.def(F, ".", V);
            });
          }
          E(
            m.link(p),
            T(p.info.type),
            L
          );
        });
      }
      function Ke(m, c, w, P, k, A) {
        for (var T = m.shared, E = T.gl, p = {}, y, g = 0; g < P.length; ++g) {
          var L = P[g], F = L.name, V = L.info.type, X = L.info.size, se = w.uniforms[F];
          if (X > 1) {
            if (!se)
              continue;
            var Ie = F.replace("[0]", "");
            if (p[Ie])
              continue;
            p[Ie] = 1;
          }
          var Ae = m.link(L), xe = Ae + ".location", H;
          if (se) {
            if (!k(se))
              continue;
            if (yn(se)) {
              var B = se.value;
              if (d.command(
                B !== null && typeof B < "u",
                'missing uniform "' + F + '"',
                m.commandStr
              ), V === Pr || V === Cr) {
                d.command(
                  typeof B == "function" && (V === Pr && (B._reglType === "texture2d" || B._reglType === "framebuffer") || V === Cr && (B._reglType === "textureCube" || B._reglType === "framebufferCube")),
                  "invalid texture for uniform " + F,
                  m.commandStr
                );
                var Se = m.link(B._texture || B.color[0]._texture);
                c(E, ".uniform1i(", xe, ",", Se + ".bind());"), c.exit(Se, ".unbind();");
              } else if (V === Tr || V === Ar || V === Er) {
                d.optional(function() {
                  d.command(
                    ot(B),
                    "invalid matrix for uniform " + F,
                    m.commandStr
                  ), d.command(
                    V === Tr && B.length === 4 || V === Ar && B.length === 9 || V === Er && B.length === 16,
                    "invalid length for matrix uniform " + F,
                    m.commandStr
                  );
                });
                var _e = m.global.def("new Float32Array([" + Array.prototype.slice.call(B) + "])"), Le = 2;
                V === Ar ? Le = 3 : V === Er && (Le = 4), c(
                  E,
                  ".uniformMatrix",
                  Le,
                  "fv(",
                  xe,
                  ",false,",
                  _e,
                  ");"
                );
              } else {
                switch (V) {
                  case No:
                    X === 1 ? d.commandType(B, "number", "uniform " + F, m.commandStr) : d.command(
                      ot(B) && B.length === X,
                      "uniform " + F,
                      m.commandStr
                    ), y = "1f";
                    break;
                  case fi:
                    d.command(
                      ot(B) && B.length && B.length % 2 === 0 && B.length <= X * 2,
                      "uniform " + F,
                      m.commandStr
                    ), y = "2f";
                    break;
                  case ui:
                    d.command(
                      ot(B) && B.length && B.length % 3 === 0 && B.length <= X * 3,
                      "uniform " + F,
                      m.commandStr
                    ), y = "3f";
                    break;
                  case ci:
                    d.command(
                      ot(B) && B.length && B.length % 4 === 0 && B.length <= X * 4,
                      "uniform " + F,
                      m.commandStr
                    ), y = "4f";
                    break;
                  case Bo:
                    X === 1 ? d.commandType(B, "boolean", "uniform " + F, m.commandStr) : d.command(
                      ot(B) && B.length === X,
                      "uniform " + F,
                      m.commandStr
                    ), y = "1i";
                    break;
                  case Go:
                    X === 1 ? d.commandType(B, "number", "uniform " + F, m.commandStr) : d.command(
                      ot(B) && B.length === X,
                      "uniform " + F,
                      m.commandStr
                    ), y = "1i";
                    break;
                  case mi:
                    d.command(
                      ot(B) && B.length && B.length % 2 === 0 && B.length <= X * 2,
                      "uniform " + F,
                      m.commandStr
                    ), y = "2i";
                    break;
                  case li:
                    d.command(
                      ot(B) && B.length && B.length % 2 === 0 && B.length <= X * 2,
                      "uniform " + F,
                      m.commandStr
                    ), y = "2i";
                    break;
                  case pi:
                    d.command(
                      ot(B) && B.length && B.length % 3 === 0 && B.length <= X * 3,
                      "uniform " + F,
                      m.commandStr
                    ), y = "3i";
                    break;
                  case hi:
                    d.command(
                      ot(B) && B.length && B.length % 3 === 0 && B.length <= X * 3,
                      "uniform " + F,
                      m.commandStr
                    ), y = "3i";
                    break;
                  case vi:
                    d.command(
                      ot(B) && B.length && B.length % 4 === 0 && B.length <= X * 4,
                      "uniform " + F,
                      m.commandStr
                    ), y = "4i";
                    break;
                  case di:
                    d.command(
                      ot(B) && B.length && B.length % 4 === 0 && B.length <= X * 4,
                      "uniform " + F,
                      m.commandStr
                    ), y = "4i";
                    break;
                }
                X > 1 ? (y += "v", B = m.global.def("[" + Array.prototype.slice.call(B) + "]")) : B = ot(B) ? Array.prototype.slice.call(B) : B, c(
                  E,
                  ".uniform",
                  y,
                  "(",
                  xe,
                  ",",
                  B,
                  ");"
                );
              }
              continue;
            } else
              H = se.append(m, c);
          } else {
            if (!k(Ef))
              continue;
            H = c.def(T.uniforms, "[", h.id(F), "]");
          }
          V === Pr ? (d(!Array.isArray(H), "must specify a scalar prop for textures"), c(
            "if(",
            H,
            "&&",
            H,
            '._reglType==="framebuffer"){',
            H,
            "=",
            H,
            ".color[0];",
            "}"
          )) : V === Cr && (d(!Array.isArray(H), "must specify a scalar prop for cube maps"), c(
            "if(",
            H,
            "&&",
            H,
            '._reglType==="framebufferCube"){',
            H,
            "=",
            H,
            ".color[0];",
            "}"
          )), d.optional(function() {
            function Ot(kt, xi) {
              m.assert(
                c,
                kt,
                'bad data or missing for uniform "' + F + '".  ' + xi
              );
            }
            function On(kt, xi) {
              xi === 1 && d(!Array.isArray(H), "must not specify an array type for uniform"), Ot(
                "Array.isArray(" + H + ") && typeof " + H + '[0]===" ' + kt + '" || typeof ' + H + '==="' + kt + '"',
                "invalid type, expected " + kt
              );
            }
            function Vt(kt, xi, yi) {
              Array.isArray(H) ? d(H.length && H.length % kt === 0 && H.length <= kt * yi, "must have length of " + (yi === 1 ? "" : "n * ") + kt) : Ot(
                T.isArrayLike + "(" + H + ")&&" + H + ".length && " + H + ".length % " + kt + " === 0 && " + H + ".length<=" + kt * yi,
                "invalid vector, should have length of " + (yi === 1 ? "" : "n * ") + kt,
                m.commandStr
              );
            }
            function If(kt) {
              d(!Array.isArray(H), "must not specify a value type"), Ot(
                "typeof " + H + '==="function"&&' + H + '._reglType==="texture' + (kt === gf ? "2d" : "Cube") + '"',
                "invalid texture type",
                m.commandStr
              );
            }
            switch (V) {
              case Go:
                On("number", X);
                break;
              case li:
                Vt(2, "number", X);
                break;
              case hi:
                Vt(3, "number", X);
                break;
              case di:
                Vt(4, "number", X);
                break;
              case No:
                On("number", X);
                break;
              case fi:
                Vt(2, "number", X);
                break;
              case ui:
                Vt(3, "number", X);
                break;
              case ci:
                Vt(4, "number", X);
                break;
              case Bo:
                On("boolean", X);
                break;
              case mi:
                Vt(2, "boolean", X);
                break;
              case pi:
                Vt(3, "boolean", X);
                break;
              case vi:
                Vt(4, "boolean", X);
                break;
              case Tr:
                Vt(4, "number", X);
                break;
              case Ar:
                Vt(9, "number", X);
                break;
              case Er:
                Vt(16, "number", X);
                break;
              case Pr:
                If(gf);
                break;
              case Cr:
                If(Yh);
                break;
            }
          });
          var Je = 1;
          switch (V) {
            case Pr:
            case Cr:
              var Pt = c.def(H, "._texture");
              c(E, ".uniform1i(", xe, ",", Pt, ".bind());"), c.exit(Pt, ".unbind();");
              continue;
            case Go:
            case Bo:
              y = "1i";
              break;
            case li:
            case mi:
              y = "2i", Je = 2;
              break;
            case hi:
            case pi:
              y = "3i", Je = 3;
              break;
            case di:
            case vi:
              y = "4i", Je = 4;
              break;
            case No:
              y = "1f";
              break;
            case fi:
              y = "2f", Je = 2;
              break;
            case ui:
              y = "3f", Je = 3;
              break;
            case ci:
              y = "4f", Je = 4;
              break;
            case Tr:
              y = "Matrix2fv";
              break;
            case Ar:
              y = "Matrix3fv";
              break;
            case Er:
              y = "Matrix4fv";
              break;
          }
          if (y.indexOf("Matrix") === -1 && X > 1 && (y += "v", Je = 1), y.charAt(0) === "M") {
            c(E, ".uniform", y, "(", xe, ",");
            var Dn = Math.pow(V - Tr + 2, 2), sn = m.global.def("new Float32Array(", Dn, ")");
            Array.isArray(H) ? c(
              "false,(",
              Dt(Dn, function(Ot) {
                return sn + "[" + Ot + "]=" + H[Ot];
              }),
              ",",
              sn,
              ")"
            ) : c(
              "false,(Array.isArray(",
              H,
              ")||",
              H,
              " instanceof Float32Array)?",
              H,
              ":(",
              Dt(Dn, function(Ot) {
                return sn + "[" + Ot + "]=" + H + "[" + Ot + "]";
              }),
              ",",
              sn,
              ")"
            ), c(");");
          } else if (Je > 1) {
            for (var Jt = [], bn = [], Mn = 0; Mn < Je; ++Mn)
              Array.isArray(H) ? bn.push(H[Mn]) : bn.push(c.def(H + "[" + Mn + "]")), A && Jt.push(c.def());
            A && c("if(!", m.batchId, "||", Jt.map(function(Ot, On) {
              return Ot + "!==" + bn[On];
            }).join("||"), "){", Jt.map(function(Ot, On) {
              return Ot + "=" + bn[On] + ";";
            }).join("")), c(E, ".uniform", y, "(", xe, ",", bn.join(","), ");"), A && c("}");
          } else {
            if (d(!Array.isArray(H), "uniform value must not be an array"), A) {
              var zf = c.def();
              c(
                "if(!",
                m.batchId,
                "||",
                zf,
                "!==",
                H,
                "){",
                zf,
                "=",
                H,
                ";"
              );
            }
            c(E, ".uniform", y, "(", xe, ",", H, ");"), A && c("}");
          }
        }
      }
      function Ce(m, c, w, P) {
        var k = m.shared, A = k.gl, T = k.draw, E = P.draw;
        function p() {
          var Se = E.elements, _e, Le = c;
          return Se ? ((Se.contextDep && P.contextDynamic || Se.propDep) && (Le = w), _e = Se.append(m, Le), E.elementsActive && Le(
            "if(" + _e + ")" + A + ".bindBuffer(" + Oo + "," + _e + ".buffer.buffer);"
          )) : (_e = Le.def(), Le(
            _e,
            "=",
            T,
            ".",
            Fn,
            ";",
            "if(",
            _e,
            "){",
            A,
            ".bindBuffer(",
            Oo,
            ",",
            _e,
            ".buffer.buffer);}",
            "else if(",
            k.vao,
            ".currentVAO){",
            _e,
            "=",
            m.shared.elements + ".getElements(" + k.vao,
            ".currentVAO.elements);",
            W ? "" : "if(" + _e + ")" + A + ".bindBuffer(" + Oo + "," + _e + ".buffer.buffer);",
            "}"
          )), _e;
        }
        function y() {
          var Se = E.count, _e, Le = c;
          return Se ? ((Se.contextDep && P.contextDynamic || Se.propDep) && (Le = w), _e = Se.append(m, Le), d.optional(function() {
            Se.MISSING && m.assert(c, "false", "missing vertex count"), Se.DYNAMIC && m.assert(Le, _e + ">=0", "missing vertex count");
          })) : (_e = Le.def(T, ".", zn), d.optional(function() {
            m.assert(Le, _e + ">=0", "missing vertex count");
          })), _e;
        }
        var g = p();
        function L(Se) {
          var _e = E[Se];
          return _e ? _e.contextDep && P.contextDynamic || _e.propDep ? _e.append(m, w) : _e.append(m, c) : c.def(T, ".", Se);
        }
        var F = L(Ln), V = L(ai), X = y();
        if (typeof X == "number") {
          if (X === 0)
            return;
        } else
          w("if(", X, "){"), w.exit("}");
        var se, Ie;
        ee && (se = L(si), Ie = m.instancing);
        var Ae = g + ".type", xe = E.elements && yn(E.elements) && !E.vaoActive;
        function H() {
          function Se() {
            w(Ie, ".drawElementsInstancedANGLE(", [
              F,
              X,
              Ae,
              V + "<<((" + Ae + "-" + Ys + ")>>1)",
              se
            ], ");");
          }
          function _e() {
            w(
              Ie,
              ".drawArraysInstancedANGLE(",
              [F, V, X, se],
              ");"
            );
          }
          g && g !== "null" ? xe ? Se() : (w("if(", g, "){"), Se(), w("}else{"), _e(), w("}")) : _e();
        }
        function B() {
          function Se() {
            w(A + ".drawElements(" + [
              F,
              X,
              Ae,
              V + "<<((" + Ae + "-" + Ys + ")>>1)"
            ] + ");");
          }
          function _e() {
            w(A + ".drawArrays(" + [F, V, X] + ");");
          }
          g && g !== "null" ? xe ? Se() : (w("if(", g, "){"), Se(), w("}else{"), _e(), w("}")) : _e();
        }
        ee && (typeof se != "number" || se >= 0) ? typeof se == "string" ? (w("if(", se, ">0){"), H(), w("}else if(", se, "<0){"), B(), w("}")) : H() : B();
      }
      function He(m, c, w, P, k) {
        var A = Re(), T = A.proc("body", k);
        return d.optional(function() {
          A.commandStr = c.commandStr, A.command = A.link(c.commandStr);
        }), ee && (A.instancing = T.def(
          A.shared.extensions,
          ".angle_instanced_arrays"
        )), m(A, T, w, P), A.compile().body;
      }
      function Qe(m, c, w, P) {
        ct(m, c), w.useVAO ? w.drawVAO ? c(m.shared.vao, ".setVAO(", w.drawVAO.append(m, c), ");") : c(m.shared.vao, ".setVAO(", m.shared.vao, ".targetVAO);") : (c(m.shared.vao, ".setVAO(null);"), Et(m, c, w, P.attributes, function() {
          return true;
        })), Ke(m, c, w, P.uniforms, function() {
          return true;
        }, false), Ce(m, c, c, w);
      }
      function lt(m, c) {
        var w = m.proc("draw", 1);
        ct(m, w), vt(m, w, c.context), gt(m, w, c.framebuffer), _t(m, w, c), At(m, w, c.state), Ve(m, w, c, false, true);
        var P = c.shader.progVar.append(m, w);
        if (w(m.shared.gl, ".useProgram(", P, ".program);"), c.shader.program)
          Qe(m, w, c, c.shader.program);
        else {
          w(m.shared.vao, ".setVAO(null);");
          var k = m.global.def("{}"), A = w.def(P, ".id"), T = w.def(k, "[", A, "]");
          w(
            m.cond(T).then(T, ".call(this,a0);").else(
              T,
              "=",
              k,
              "[",
              A,
              "]=",
              m.link(function(E) {
                return He(Qe, m, c, E, 1);
              }),
              "(",
              P,
              ");",
              T,
              ".call(this,a0);"
            )
          );
        }
        Object.keys(c.state).length > 0 && w(m.shared.current, ".dirty=true;"), m.shared.vao && w(m.shared.vao, ".setVAO(null);");
      }
      function Kt(m, c, w, P) {
        m.batchId = "a1", ct(m, c);
        function k() {
          return true;
        }
        Et(m, c, w, P.attributes, k), Ke(m, c, w, P.uniforms, k, false), Ce(m, c, c, w);
      }
      function Rn(m, c, w, P) {
        ct(m, c);
        var k = w.contextDep, A = c.def(), T = "a0", E = "a1", p = c.def();
        m.shared.props = p, m.batchId = A;
        var y = m.scope(), g = m.scope();
        c(
          y.entry,
          "for(",
          A,
          "=0;",
          A,
          "<",
          E,
          ";++",
          A,
          "){",
          p,
          "=",
          T,
          "[",
          A,
          "];",
          g,
          "}",
          y.exit
        );
        function L(Ae) {
          return Ae.contextDep && k || Ae.propDep;
        }
        function F(Ae) {
          return !L(Ae);
        }
        if (w.needsContext && vt(m, g, w.context), w.needsFramebuffer && gt(m, g, w.framebuffer), At(m, g, w.state, L), w.profile && L(w.profile) && Ve(m, g, w, false, true), P)
          w.useVAO ? w.drawVAO ? L(w.drawVAO) ? g(m.shared.vao, ".setVAO(", w.drawVAO.append(m, g), ");") : y(m.shared.vao, ".setVAO(", w.drawVAO.append(m, y), ");") : y(m.shared.vao, ".setVAO(", m.shared.vao, ".targetVAO);") : (y(m.shared.vao, ".setVAO(null);"), Et(m, y, w, P.attributes, F), Et(m, g, w, P.attributes, L)), Ke(m, y, w, P.uniforms, F, false), Ke(m, g, w, P.uniforms, L, true), Ce(m, y, g, w);
        else {
          var V = m.global.def("{}"), X = w.shader.progVar.append(m, g), se = g.def(X, ".id"), Ie = g.def(V, "[", se, "]");
          g(
            m.shared.gl,
            ".useProgram(",
            X,
            ".program);",
            "if(!",
            Ie,
            "){",
            Ie,
            "=",
            V,
            "[",
            se,
            "]=",
            m.link(function(Ae) {
              return He(
                Kt,
                m,
                w,
                Ae,
                2
              );
            }),
            "(",
            X,
            ");}",
            Ie,
            ".call(this,a0[",
            A,
            "],",
            A,
            ");"
          );
        }
      }
      function x(m, c) {
        var w = m.proc("batch", 2);
        m.batchId = "0", ct(m, w);
        var P = false, k = true;
        Object.keys(c.context).forEach(function(V) {
          P = P || c.context[V].propDep;
        }), P || (vt(m, w, c.context), k = false);
        var A = c.framebuffer, T = false;
        A ? (A.propDep ? P = T = true : A.contextDep && P && (T = true), T || gt(m, w, A)) : gt(m, w, null), c.state.viewport && c.state.viewport.propDep && (P = true);
        function E(V) {
          return V.contextDep && P || V.propDep;
        }
        _t(m, w, c), At(m, w, c.state, function(V) {
          return !E(V);
        }), (!c.profile || !E(c.profile)) && Ve(m, w, c, false, "a1"), c.contextDep = P, c.needsContext = k, c.needsFramebuffer = T;
        var p = c.shader.progVar;
        if (p.contextDep && P || p.propDep)
          Rn(
            m,
            w,
            c,
            null
          );
        else {
          var y = p.append(m, w);
          if (w(m.shared.gl, ".useProgram(", y, ".program);"), c.shader.program)
            Rn(
              m,
              w,
              c,
              c.shader.program
            );
          else {
            w(m.shared.vao, ".setVAO(null);");
            var g = m.global.def("{}"), L = w.def(y, ".id"), F = w.def(g, "[", L, "]");
            w(
              m.cond(F).then(F, ".call(this,a0,a1);").else(
                F,
                "=",
                g,
                "[",
                L,
                "]=",
                m.link(function(V) {
                  return He(Rn, m, c, V, 2);
                }),
                "(",
                y,
                ");",
                F,
                ".call(this,a0,a1);"
              )
            );
          }
        }
        Object.keys(c.state).length > 0 && w(m.shared.current, ".dirty=true;"), m.shared.vao && w(m.shared.vao, ".setVAO(null);");
      }
      function D(m, c) {
        var w = m.proc("scope", 3);
        m.batchId = "a2";
        var P = m.shared, k = P.current;
        vt(m, w, c.context), c.framebuffer && c.framebuffer.append(m, w), Af(Object.keys(c.state)).forEach(function(T) {
          var E = c.state[T], p = E.append(m, w);
          ot(p) ? p.forEach(function(y, g) {
            w.set(m.next[T], "[" + g + "]", y);
          }) : w.set(P.next, "." + T, p);
        }), Ve(m, w, c, true, true), [Fn, ai, zn, si, Ln].forEach(
          function(T) {
            var E = c.draw[T];
            E && w.set(P.draw, "." + T, "" + E.append(m, w));
          }
        ), Object.keys(c.uniforms).forEach(function(T) {
          var E = c.uniforms[T].append(m, w);
          Array.isArray(E) && (E = "[" + E.join() + "]"), w.set(
            P.uniforms,
            "[" + h.id(T) + "]",
            E
          );
        }), Object.keys(c.attributes).forEach(function(T) {
          var E = c.attributes[T].append(m, w), p = m.scopeAttrib(T);
          Object.keys(new C()).forEach(function(y) {
            w.set(p, "." + y, E[y]);
          });
        }), c.scopeVAO && w.set(P.vao, ".targetVAO", c.scopeVAO.append(m, w));
        function A(T) {
          var E = c.shader[T];
          E && w.set(P.shader, "." + T, E.append(m, w));
        }
        A(_r), A(Sr), Object.keys(c.state).length > 0 && (w(k, ".dirty=true;"), w.exit(k, ".dirty=true;")), w("a1(", m.shared.context, ",a0,", m.batchId, ");");
      }
      function z(m) {
        if (!(typeof m != "object" || ot(m))) {
          for (var c = Object.keys(m), w = 0; w < c.length; ++w)
            if (Rt.isDynamic(m[c[w]]))
              return true;
          return false;
        }
      }
      function ye(m, c, w) {
        var P = c.static[w];
        if (!P || !z(P))
          return;
        var k = m.global, A = Object.keys(P), T = false, E = false, p = false, y = m.global.def("{}");
        A.forEach(function(L) {
          var F = P[L];
          if (Rt.isDynamic(F)) {
            typeof F == "function" && (F = P[L] = Rt.unbox(F));
            var V = Ct(F, null);
            T = T || V.thisDep, p = p || V.propDep, E = E || V.contextDep;
          } else {
            switch (k(y, ".", L, "="), typeof F) {
              case "number":
                k(F);
                break;
              case "string":
                k('"', F, '"');
                break;
              case "object":
                Array.isArray(F) && k("[", F.join(), "]");
                break;
              default:
                k(m.link(F));
                break;
            }
            k(";");
          }
        });
        function g(L, F) {
          A.forEach(function(V) {
            var X = P[V];
            if (Rt.isDynamic(X)) {
              var se = L.invoke(F, X);
              F(y, ".", V, "=", se, ";");
            }
          });
        }
        c.dynamic[w] = new Rt.DynamicVariable(ii, {
          thisDep: T,
          contextDep: E,
          propDep: p,
          ref: y,
          append: g
        }), delete c.static[w];
      }
      function Ue(m, c, w, P, k) {
        var A = Re();
        A.stats = A.link(k), Object.keys(c.static).forEach(function(E) {
          ye(A, c, E);
        }), Hh.forEach(function(E) {
          ye(A, m, E);
        });
        var T = mt(m, c, w, P, A);
        return lt(A, T), D(A, T), x(A, T), r(A.compile(), {
          destroy: function() {
            T.shader.program.destroy();
          }
        });
      }
      return {
        next: he,
        current: me,
        procs: function() {
          var m = Re(), c = m.proc("poll"), w = m.proc("refresh"), P = m.block();
          c(P), w(P);
          var k = m.shared, A = k.gl, T = k.next, E = k.current;
          P(E, ".dirty=false;"), gt(m, c), gt(m, w, null, true);
          var p;
          ee && (p = m.link(ee)), _.oes_vertex_array_object && w(m.link(_.oes_vertex_array_object), ".bindVertexArrayOES(null);");
          for (var y = 0; y < R.maxAttributes; ++y) {
            var g = w.def(k.attributes, "[", y, "]"), L = m.cond(g, ".buffer");
            L.then(
              A,
              ".enableVertexAttribArray(",
              y,
              ");",
              A,
              ".bindBuffer(",
              rr,
              ",",
              g,
              ".buffer.buffer);",
              A,
              ".vertexAttribPointer(",
              y,
              ",",
              g,
              ".size,",
              g,
              ".type,",
              g,
              ".normalized,",
              g,
              ".stride,",
              g,
              ".offset);"
            ).else(
              A,
              ".disableVertexAttribArray(",
              y,
              ");",
              A,
              ".vertexAttrib4f(",
              y,
              ",",
              g,
              ".x,",
              g,
              ".y,",
              g,
              ".z,",
              g,
              ".w);",
              g,
              ".buffer=null;"
            ), w(L), ee && w(
              p,
              ".vertexAttribDivisorANGLE(",
              y,
              ",",
              g,
              ".divisor);"
            );
          }
          return w(
            m.shared.vao,
            ".currentVAO=null;",
            m.shared.vao,
            ".setVAO(",
            m.shared.vao,
            ".targetVAO);"
          ), Object.keys(U).forEach(function(F) {
            var V = U[F], X = P.def(T, ".", F), se = m.block();
            se(
              "if(",
              X,
              "){",
              A,
              ".enable(",
              V,
              ")}else{",
              A,
              ".disable(",
              V,
              ")}",
              E,
              ".",
              F,
              "=",
              X,
              ";"
            ), w(se), c(
              "if(",
              X,
              "!==",
              E,
              ".",
              F,
              "){",
              se,
              "}"
            );
          }), Object.keys($).forEach(function(F) {
            var V = $[F], X = me[F], se, Ie, Ae = m.block();
            if (Ae(A, ".", V, "("), ot(X)) {
              var xe = X.length;
              se = m.global.def(T, ".", F), Ie = m.global.def(E, ".", F), Ae(
                Dt(xe, function(H) {
                  return se + "[" + H + "]";
                }),
                ");",
                Dt(xe, function(H) {
                  return Ie + "[" + H + "]=" + se + "[" + H + "];";
                }).join("")
              ), c(
                "if(",
                Dt(xe, function(H) {
                  return se + "[" + H + "]!==" + Ie + "[" + H + "]";
                }).join("||"),
                "){",
                Ae,
                "}"
              );
            } else
              se = P.def(T, ".", F), Ie = P.def(E, ".", F), Ae(
                se,
                ");",
                E,
                ".",
                F,
                "=",
                se,
                ";"
              ), c(
                "if(",
                se,
                "!==",
                Ie,
                "){",
                Ae,
                "}"
              );
            w(Ae);
          }), m.compile();
        }(),
        compile: Ue
      };
    }
    function ld() {
      return {
        vaoCount: 0,
        bufferCount: 0,
        elementsCount: 0,
        framebufferCount: 0,
        shaderCount: 0,
        textureCount: 0,
        cubeCount: 0,
        renderbufferCount: 0,
        maxTextureUnits: 0
      };
    }
    var hd = 34918, dd = 34919, Pf = 35007, md = function(a, h) {
      if (!h.ext_disjoint_timer_query)
        return null;
      var _ = [];
      function R() {
        return _.pop() || h.ext_disjoint_timer_query.createQueryEXT();
      }
      function j(ee) {
        _.push(ee);
      }
      var I = [];
      function G(ee) {
        var ge = R();
        h.ext_disjoint_timer_query.beginQueryEXT(Pf, ge), I.push(ge), Q(I.length - 1, I.length, ee);
      }
      function Z() {
        h.ext_disjoint_timer_query.endQueryEXT(Pf);
      }
      function Y() {
        this.startQueryIndex = -1, this.endQueryIndex = -1, this.sum = 0, this.stats = null;
      }
      var ne = [];
      function ie() {
        return ne.pop() || new Y();
      }
      function re(ee) {
        ne.push(ee);
      }
      var fe = [];
      function Q(ee, ge, W) {
        var me = ie();
        me.startQueryIndex = ee, me.endQueryIndex = ge, me.sum = 0, me.stats = W, fe.push(me);
      }
      var te = [], C = [];
      function O() {
        var ee, ge, W = I.length;
        if (W !== 0) {
          C.length = Math.max(C.length, W + 1), te.length = Math.max(te.length, W + 1), te[0] = 0, C[0] = 0;
          var me = 0;
          for (ee = 0, ge = 0; ge < I.length; ++ge) {
            var he = I[ge];
            h.ext_disjoint_timer_query.getQueryObjectEXT(he, dd) ? (me += h.ext_disjoint_timer_query.getQueryObjectEXT(he, hd), j(he)) : I[ee++] = he, te[ge + 1] = me, C[ge + 1] = ee;
          }
          for (I.length = ee, ee = 0, ge = 0; ge < fe.length; ++ge) {
            var Ee = fe[ge], U = Ee.startQueryIndex, $ = Ee.endQueryIndex;
            Ee.sum += te[$] - te[U];
            var be = C[U], ue = C[$];
            ue === be ? (Ee.stats.gpuTime += Ee.sum / 1e6, re(Ee)) : (Ee.startQueryIndex = be, Ee.endQueryIndex = ue, fe[ee++] = Ee);
          }
          fe.length = ee;
        }
      }
      return {
        beginQuery: G,
        endQuery: Z,
        pushScopeStats: Q,
        update: O,
        getNumPendingQueries: function() {
          return I.length;
        },
        clear: function() {
          _.push.apply(_, I);
          for (var ee = 0; ee < _.length; ee++)
            h.ext_disjoint_timer_query.deleteQueryEXT(_[ee]);
          I.length = 0, _.length = 0;
        },
        restore: function() {
          I.length = 0, _.length = 0;
        }
      };
    }, pd = 16384, vd = 256, gd = 1024, xd = 34962, Cf = "webglcontextlost", kf = "webglcontextrestored", Ff = 1, yd = 2, bd = 3;
    function Lf(a, h) {
      for (var _ = 0; _ < a.length; ++_)
        if (a[_] === h)
          return _;
      return -1;
    }
    function _d(a) {
      var h = yc(a);
      if (!h)
        return null;
      var _ = h.gl, R = _.getContextAttributes(), j = _.isContextLost(), I = bc(_, h);
      if (!I)
        return null;
      var G = mc(), Z = ld(), Y = I.extensions, ne = md(_, Y), ie = Na(), re = _.drawingBufferWidth, fe = _.drawingBufferHeight, Q = {
        tick: 0,
        time: 0,
        viewportWidth: re,
        viewportHeight: fe,
        framebufferWidth: re,
        framebufferHeight: fe,
        drawingBufferWidth: re,
        drawingBufferHeight: fe,
        pixelRatio: h.pixelRatio
      }, te = {}, C = {
        elements: null,
        primitive: 4,
        // GL_TRIANGLES
        count: -1,
        offset: 0,
        instances: -1
      }, O = sl(_, Y), ee = wl(
        _,
        Z,
        h,
        me
      ), ge = Dl(_, Y, ee, Z), W = Dh(
        _,
        Y,
        O,
        Z,
        ee,
        ge,
        C
      );
      function me(Ce) {
        return W.destroyBuffer(Ce);
      }
      var he = Gh(_, G, Z, h), Ee = hh(
        _,
        Y,
        O,
        function() {
          be.procs.poll();
        },
        Q,
        Z,
        h
      ), U = dh(_, Y, O, Z, h), $ = Ih(
        _,
        Y,
        O,
        Ee,
        U,
        Z
      ), be = cd(
        _,
        G,
        Y,
        O,
        ee,
        ge,
        Ee,
        $,
        te,
        W,
        he,
        C,
        Q,
        ne,
        h
      ), ue = $h(
        _,
        $,
        be.procs.poll,
        Q,
        R,
        Y,
        O
      ), J = be.next, ce = _.canvas, le = [], Me = [], Re = [], de = [h.onDestroy], ve = null;
      function Fe() {
        if (le.length === 0) {
          ne && ne.update(), ve = null;
          return;
        }
        ve = Hi.next(Fe), At();
        for (var Ce = le.length - 1; Ce >= 0; --Ce) {
          var He = le[Ce];
          He && He(Q, null, 0);
        }
        _.flush(), ne && ne.update();
      }
      function Oe() {
        !ve && le.length > 0 && (ve = Hi.next(Fe));
      }
      function Xe() {
        ve && (Hi.cancel(Fe), ve = null);
      }
      function at(Ce) {
        Ce.preventDefault(), j = true, Xe(), Me.forEach(function(He) {
          He();
        });
      }
      function ft(Ce) {
        _.getError(), j = false, I.restore(), he.restore(), ee.restore(), Ee.restore(), U.restore(), $.restore(), W.restore(), ne && ne.restore(), be.procs.refresh(), Oe(), Re.forEach(function(He) {
          He();
        });
      }
      ce && (ce.addEventListener(Cf, at, false), ce.addEventListener(kf, ft, false));
      function Ze() {
        le.length = 0, Xe(), ce && (ce.removeEventListener(Cf, at), ce.removeEventListener(kf, ft)), he.clear(), $.clear(), U.clear(), W.clear(), Ee.clear(), ge.clear(), ee.clear(), ne && ne.clear(), de.forEach(function(Ce) {
          Ce();
        });
      }
      function pt(Ce) {
        d(!!Ce, "invalid args to regl({...})"), d.type(Ce, "object", "invalid args to regl({...})");
        function He(k) {
          var A = r({}, k);
          delete A.uniforms, delete A.attributes, delete A.context, delete A.vao, "stencil" in A && A.stencil.op && (A.stencil.opBack = A.stencil.opFront = A.stencil.op, delete A.stencil.op);
          function T(E) {
            if (E in A) {
              var p = A[E];
              delete A[E], Object.keys(p).forEach(function(y) {
                A[E + "." + y] = p[y];
              });
            }
          }
          return T("blend"), T("depth"), T("cull"), T("stencil"), T("polygonOffset"), T("scissor"), T("sample"), "vao" in k && (A.vao = k.vao), A;
        }
        function Qe(k, A) {
          var T = {}, E = {};
          return Object.keys(k).forEach(function(p) {
            var y = k[p];
            if (Rt.isDynamic(y)) {
              E[p] = Rt.unbox(y, p);
              return;
            } else if (A && Array.isArray(y)) {
              for (var g = 0; g < y.length; ++g)
                if (Rt.isDynamic(y[g])) {
                  E[p] = Rt.unbox(y, p);
                  return;
                }
            }
            T[p] = y;
          }), {
            dynamic: E,
            static: T
          };
        }
        var lt = Qe(Ce.context || {}, true), Kt = Qe(Ce.uniforms || {}, true), Rn = Qe(Ce.attributes || {}, false), x = Qe(He(Ce), false), D = {
          gpuTime: 0,
          cpuTime: 0,
          count: 0
        }, z = be.compile(x, Rn, Kt, lt, D), ye = z.draw, Ue = z.batch, m = z.scope, c = [];
        function w(k) {
          for (; c.length < k; )
            c.push(null);
          return c;
        }
        function P(k, A) {
          var T;
          if (j && d.raise("context lost"), typeof k == "function")
            return m.call(this, null, k, 0);
          if (typeof A == "function")
            if (typeof k == "number")
              for (T = 0; T < k; ++T)
                m.call(this, null, A, T);
            else if (Array.isArray(k))
              for (T = 0; T < k.length; ++T)
                m.call(this, k[T], A, T);
            else
              return m.call(this, k, A, 0);
          else if (typeof k == "number") {
            if (k > 0)
              return Ue.call(this, w(k | 0), k | 0);
          } else if (Array.isArray(k)) {
            if (k.length)
              return Ue.call(this, k, k.length);
          } else
            return ye.call(this, k);
        }
        return r(P, {
          stats: D,
          destroy: function() {
            z.destroy();
          }
        });
      }
      var it = $.setFBO = pt({
        framebuffer: Rt.define.call(null, Ff, "framebuffer")
      });
      function mt(Ce, He) {
        var Qe = 0;
        be.procs.poll();
        var lt = He.color;
        lt && (_.clearColor(+lt[0] || 0, +lt[1] || 0, +lt[2] || 0, +lt[3] || 0), Qe |= pd), "depth" in He && (_.clearDepth(+He.depth), Qe |= vd), "stencil" in He && (_.clearStencil(He.stencil | 0), Qe |= gd), d(!!Qe, "called regl.clear with no buffer specified"), _.clear(Qe);
      }
      function vt(Ce) {
        if (d(
          typeof Ce == "object" && Ce,
          "regl.clear() takes an object as input"
        ), "framebuffer" in Ce)
          if (Ce.framebuffer && Ce.framebuffer_reglType === "framebufferCube")
            for (var He = 0; He < 6; ++He)
              it(r({
                framebuffer: Ce.framebuffer.faces[He]
              }, Ce), mt);
          else
            it(Ce, mt);
        else
          mt(null, Ce);
      }
      function gt(Ce) {
        d.type(Ce, "function", "regl.frame() callback must be a function"), le.push(Ce);
        function He() {
          var Qe = Lf(le, Ce);
          d(Qe >= 0, "cannot cancel a frame twice");
          function lt() {
            var Kt = Lf(le, lt);
            le[Kt] = le[le.length - 1], le.length -= 1, le.length <= 0 && Xe();
          }
          le[Qe] = lt;
        }
        return Oe(), {
          cancel: He
        };
      }
      function _t() {
        var Ce = J.viewport, He = J.scissor_box;
        Ce[0] = Ce[1] = He[0] = He[1] = 0, Q.viewportWidth = Q.framebufferWidth = Q.drawingBufferWidth = Ce[2] = He[2] = _.drawingBufferWidth, Q.viewportHeight = Q.framebufferHeight = Q.drawingBufferHeight = Ce[3] = He[3] = _.drawingBufferHeight;
      }
      function At() {
        Q.tick += 1, Q.time = Ve(), _t(), be.procs.poll();
      }
      function ct() {
        Ee.refresh(), _t(), be.procs.refresh(), ne && ne.update();
      }
      function Ve() {
        return (Na() - ie) / 1e3;
      }
      ct();
      function Et(Ce, He) {
        d.type(He, "function", "listener callback must be a function");
        var Qe;
        switch (Ce) {
          case "frame":
            return gt(He);
          case "lost":
            Qe = Me;
            break;
          case "restore":
            Qe = Re;
            break;
          case "destroy":
            Qe = de;
            break;
          default:
            d.raise("invalid event, must be one of frame,lost,restore,destroy");
        }
        return Qe.push(He), {
          cancel: function() {
            for (var lt = 0; lt < Qe.length; ++lt)
              if (Qe[lt] === He) {
                Qe[lt] = Qe[Qe.length - 1], Qe.pop();
                return;
              }
          }
        };
      }
      var Ke = r(pt, {
        // Clear current FBO
        clear: vt,
        // Short cuts for dynamic variables
        prop: Rt.define.bind(null, Ff),
        context: Rt.define.bind(null, yd),
        this: Rt.define.bind(null, bd),
        // executes an empty draw command
        draw: pt({}),
        // Resources
        buffer: function(Ce) {
          return ee.create(Ce, xd, false, false);
        },
        elements: function(Ce) {
          return ge.create(Ce, false);
        },
        texture: Ee.create2D,
        cube: Ee.createCube,
        renderbuffer: U.create,
        framebuffer: $.create,
        framebufferCube: $.createCube,
        vao: W.createVAO,
        // Expose context attributes
        attributes: R,
        // Frame rendering
        frame: gt,
        on: Et,
        // System limits
        limits: O,
        hasExtension: function(Ce) {
          return O.extensions.indexOf(Ce.toLowerCase()) >= 0;
        },
        // Read pixels
        read: ue,
        // Destroy regl and all associated resources
        destroy: Ze,
        // Direct GL state manipulation
        _gl: _,
        _refresh: ct,
        poll: function() {
          At(), ne && ne.update();
        },
        // Current time
        now: Ve,
        // regl Statistics Information
        stats: Z
      });
      return h.onDone(null, Ke), Ke;
    }
    return _d;
  });
})(Ou);
var Z0 = Ou.exports;
var Q0 = ba(Z0);
var K0 = "#b3b3b3";
var J0 = 0.1;
var ev = 4;
var tv = "#666666";
var nv = 0.1;
var rv = 1;
var iv = "#222222";
var We = {
  disableSimulation: false,
  spaceSize: 4096,
  pointSizeScale: 1,
  linkWidthScale: 1,
  arrowSizeScale: 1,
  renderLinks: true,
  curvedLinks: false,
  curvedLinkSegments: 19,
  curvedLinkWeight: 0.8,
  curvedLinkControlPointDistance: 0.5,
  arrowLinks: false,
  linkVisibilityDistanceRange: [50, 150],
  linkVisibilityMinTransparency: 0.25,
  hoveredPointCursor: "auto",
  renderHoveredPointRing: false,
  hoveredPointRingColor: "white",
  focusedPointRingColor: "white",
  focusedPointIndex: void 0,
  useQuadtree: false,
  simulation: {
    decay: 5e3,
    gravity: 0.25,
    center: 0,
    repulsion: 1,
    repulsionTheta: 1.15,
    repulsionQuadtreeLevels: 12,
    linkSpring: 1,
    linkDistance: 10,
    linkDistRandomVariationRange: [1, 1.2],
    repulsionFromMouse: 2,
    friction: 0.85,
    cluster: 0.1
  },
  showFPSMonitor: false,
  pixelRatio: 2,
  scalePointsOnZoom: true,
  disableZoom: false,
  enableDrag: false,
  fitViewOnInit: true,
  fitViewDelay: 250,
  fitViewPadding: 0.1,
  fitViewDuration: 250,
  pointSamplingDistance: 150
};
var ov = 0.7;
var av = 0.95;
var sv = 3;
var fv = (e3) => typeof e3 == "function";
var Nu = (e3) => Array.isArray(e3);
var uv = (e3) => e3 instanceof Object;
var cv = (e3) => e3 instanceof Object ? e3.constructor.name !== "Function" && e3.constructor.name !== "Object" : false;
var Zf = (e3) => uv(e3) && !Nu(e3) && !fv(e3) && !cv(e3);
function ur(e3) {
  let t;
  if (Nu(e3))
    t = e3;
  else {
    const n = Sn(e3), r = n == null ? void 0 : n.rgb();
    t = [(r == null ? void 0 : r.r) || 0, (r == null ? void 0 : r.g) || 0, (r == null ? void 0 : r.b) || 0, (n == null ? void 0 : n.opacity) ?? 1];
  }
  return [
    t[0] / 255,
    t[1] / 255,
    t[2] / 255,
    t[3]
  ];
}
function _n(e3, t) {
  let n = new Float32Array();
  return e3({ framebuffer: t })(() => {
    n = e3.read();
  }), n;
}
function lv(e3, t, n) {
  return Math.min(Math.max(e3, t), n);
}
function en(e3) {
  return e3 != null && !Number.isNaN(e3);
}
var hv = class {
  constructor() {
    this.disableSimulation = We.disableSimulation, this.backgroundColor = iv, this.spaceSize = We.spaceSize, this.pointColor = K0, this.pointGreyoutOpacity = J0, this.pointSize = ev, this.pointSizeScale = We.pointSizeScale, this.hoveredPointCursor = We.hoveredPointCursor, this.renderHoveredPointRing = We.renderHoveredPointRing, this.hoveredPointRingColor = We.hoveredPointRingColor, this.focusedPointRingColor = We.focusedPointRingColor, this.focusedPointIndex = We.focusedPointIndex, this.linkColor = tv, this.linkGreyoutOpacity = nv, this.linkWidth = rv, this.linkWidthScale = We.linkWidthScale, this.renderLinks = We.renderLinks, this.curvedLinks = We.curvedLinks, this.curvedLinkSegments = We.curvedLinkSegments, this.curvedLinkWeight = We.curvedLinkWeight, this.curvedLinkControlPointDistance = We.curvedLinkControlPointDistance, this.linkArrows = We.arrowLinks, this.linkArrowsSizeScale = We.arrowSizeScale, this.linkVisibilityDistanceRange = We.linkVisibilityDistanceRange, this.linkVisibilityMinTransparency = We.linkVisibilityMinTransparency, this.useQuadtree = We.useQuadtree, this.simulationDecay = We.simulation.decay, this.simulationGravity = We.simulation.gravity, this.simulationCenter = We.simulation.center, this.simulationRepulsion = We.simulation.repulsion, this.simulationRepulsionTheta = We.simulation.repulsionTheta, this.simulationRepulsionQuadtreeLevels = We.simulation.repulsionQuadtreeLevels, this.simulationLinkSpring = We.simulation.linkSpring, this.simulationLinkDistance = We.simulation.linkDistance, this.simulationLinkDistRandomVariationRange = We.simulation.linkDistRandomVariationRange, this.simulationRepulsionFromMouse = We.simulation.repulsionFromMouse, this.simulationFriction = We.simulation.friction, this.simulationCluster = We.simulation.cluster, this.onSimulationStart = void 0, this.onSimulationTick = void 0, this.onSimulationEnd = void 0, this.onSimulationPause = void 0, this.onSimulationRestart = void 0, this.onClick = void 0, this.onMouseMove = void 0, this.onPointMouseOver = void 0, this.onPointMouseOut = void 0, this.onZoomStart = void 0, this.onZoom = void 0, this.onZoomEnd = void 0, this.onDragStart = void 0, this.onDrag = void 0, this.onDragEnd = void 0, this.showFPSMonitor = We.showFPSMonitor, this.pixelRatio = We.pixelRatio, this.scalePointsOnZoom = We.scalePointsOnZoom, this.initialZoomLevel = void 0, this.disableZoom = We.disableZoom, this.enableDrag = We.enableDrag, this.fitViewOnInit = We.fitViewOnInit, this.fitViewDelay = We.fitViewDelay, this.fitViewPadding = We.fitViewPadding, this.fitViewDuration = We.fitViewDuration, this.fitViewByPointsInRect = void 0, this.randomSeed = void 0, this.pointSamplingDistance = We.pointSamplingDistance;
  }
  init(t) {
    Object.keys(t).forEach((n) => {
      this.deepMergeConfig(this.getConfig(), t, n);
    });
  }
  deepMergeConfig(t, n, r) {
    Zf(t[r]) && Zf(n[r]) ? Object.keys(n[r]).forEach((i) => {
      this.deepMergeConfig(t[r], n[r], i);
    }) : t[r] = n[r];
  }
  getConfig() {
    return this;
  }
};
var dn = class {
  constructor(t, n, r, i, o) {
    this.reglInstance = t, this.config = n, this.store = r, this.data = i, o && (this.points = o);
  }
};
var dv = `#ifdef GL_ES
precision highp float;
#endif

varying vec4 rgba;

void main() {
  gl_FragColor = rgba;
}`;
var mv = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform float pointsTextureSize;

attribute vec2 pointIndices;

varying vec4 rgba;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, pointIndices / pointsTextureSize);
  rgba = vec4(pointPosition.xy, 1.0, 0.0);

  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
  gl_PointSize = 1.0;
}`;
var pv = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D centermassTexture;
uniform float centerForce;
uniform float alpha;

varying vec2 textureCoords;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 velocity = vec4(0.0);
  vec4 centermassValues = texture2D(centermassTexture, vec2(0.0));
  vec2 centermassPosition = centermassValues.xy / centermassValues.b;
  vec2 distVector = centermassPosition - pointPosition.xy;
  float dist = sqrt(dot(distVector, distVector));
  if (dist > 0.0) {
    float angle = atan(distVector.y, distVector.x);
    float addV = alpha * centerForce * dist * 0.01;
    velocity.rg += addV * vec2(cos(angle), sin(angle));
  }

  gl_FragColor = velocity;
}`;
function yt(e3) {
  return {
    buffer: e3.buffer(new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1])),
    size: 2
  };
}
function Bn(e3) {
  const t = new Float32Array(e3 * e3 * 2);
  for (let n = 0; n < e3; n++)
    for (let r = 0; r < e3; r++) {
      const i = n * e3 * 2 + r * 2;
      t[i + 0] = r, t[i + 1] = n;
    }
  return t;
}
function wi(e3) {
  var t;
  e3 && (t = e3 == null ? void 0 : e3._framebuffer) != null && t.framebuffer && e3.destroy();
}
var $n = `#ifdef GL_ES
precision highp float;
#endif

void main() {
  gl_FragColor = vec4(0.0);
}`;
var wt = `#ifdef GL_ES
precision highp float;
#endif

attribute vec2 vertexCoord; 
varying vec2 textureCoords; 

void main() {
    
    textureCoords = (vertexCoord + 1.0) / 2.0;
    gl_Position = vec4(vertexCoord, 0, 1);
}`;
var vv = class extends dn {
  create() {
    const { reglInstance: t, store: n } = this;
    this.centermassTexture || (this.centermassTexture = t.texture()), this.centermassTexture({
      data: new Float32Array(4).fill(0),
      shape: [1, 1, 4],
      type: "float"
    }), this.centermassFbo || (this.centermassFbo = t.framebuffer({
      color: this.centermassTexture,
      depth: false,
      stencil: false
    })), this.pointIndices || (this.pointIndices = t.buffer(0)), this.pointIndices(Bn(n.pointsTextureSize));
  }
  initPrograms() {
    const { reglInstance: t, config: n, store: r, data: i, points: o } = this;
    this.clearCentermassCommand || (this.clearCentermassCommand = t({
      frag: $n,
      vert: wt,
      framebuffer: () => this.centermassFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) }
    })), this.calculateCentermassCommand || (this.calculateCentermassCommand = t({
      frag: dv,
      vert: mv,
      framebuffer: () => this.centermassFbo,
      primitive: "points",
      count: () => i.pointsNumber ?? 0,
      attributes: {
        pointIndices: {
          buffer: this.pointIndices,
          size: 2
        }
      },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        pointsTextureSize: () => r.pointsTextureSize
      },
      blend: {
        enable: true,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: false, mask: false },
      stencil: { enable: false }
    })), this.runCommand || (this.runCommand = t({
      frag: pv,
      vert: wt,
      framebuffer: () => o == null ? void 0 : o.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        centermassTexture: () => this.centermassFbo,
        centerForce: () => n.simulationCenter,
        alpha: () => r.alpha
      }
    }));
  }
  run() {
    var t, n, r;
    (t = this.clearCentermassCommand) == null || t.call(this), (n = this.calculateCentermassCommand) == null || n.call(this), (r = this.runCommand) == null || r.call(this);
  }
};
var gv = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform float gravity;
uniform float spaceSize;
uniform float alpha;

varying vec2 textureCoords;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);

  vec4 velocity = vec4(0.0);

  vec2 centerPosition = vec2(spaceSize / 2.0);
  vec2 distVector = centerPosition - pointPosition.rg;
  float dist = sqrt(dot(distVector, distVector));
  if (dist > 0.0) {
    float angle = atan(distVector.y, distVector.x);
    float additionalVelocity = alpha * gravity * dist * 0.1;
    velocity.rg += additionalVelocity * vec2(cos(angle), sin(angle));
  }

  gl_FragColor = velocity;
}`;
var xv = class extends dn {
  initPrograms() {
    const { reglInstance: t, config: n, store: r, points: i } = this;
    this.runCommand || (this.runCommand = t({
      frag: gv,
      vert: wt,
      framebuffer: () => i == null ? void 0 : i.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) },
      uniforms: {
        positionsTexture: () => i == null ? void 0 : i.previousPositionFbo,
        gravity: () => n.simulationGravity,
        spaceSize: () => r.adjustedSpaceSize,
        alpha: () => r.alpha
      }
    }));
  }
  run() {
    var t;
    (t = this.runCommand) == null || t.call(this);
  }
};
function yv(e3) {
  return `
#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform float linkSpring;
uniform float linkDistance;
uniform vec2 linkDistRandomVariationRange;

uniform sampler2D linkInfoTexture; // Texture storing first link indices and amount
uniform sampler2D linkIndicesTexture;
uniform sampler2D linkPropertiesTexture; // Texture storing link bias and strength
uniform sampler2D linkRandomDistanceTexture;

uniform float pointsTextureSize;
uniform float linksTextureSize;
uniform float alpha;

varying vec2 textureCoords;

const float MAX_LINKS = ${e3}.0;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 velocity = vec4(0.0);

  vec4 linkInfo = texture2D(linkInfoTexture, textureCoords);
  float iCount = linkInfo.r;
  float jCount = linkInfo.g;
  float linkAmount = linkInfo.b;
  if (linkAmount > 0.0) {
    for (float i = 0.0; i < MAX_LINKS; i += 1.0) {
      if (i < linkAmount) {
        if (iCount >= linksTextureSize) {
          iCount = 0.0;
          jCount += 1.0;
        }
        vec2 linkTextureIndex = (vec2(iCount, jCount) + 0.5) / linksTextureSize;
        vec4 connectedPointIndex = texture2D(linkIndicesTexture, linkTextureIndex);
        vec4 biasAndStrength = texture2D(linkPropertiesTexture, linkTextureIndex);
        vec4 randomMinDistance = texture2D(linkRandomDistanceTexture, linkTextureIndex);
        float bias = biasAndStrength.r;
        float strength = biasAndStrength.g;
        float randomMinLinkDist = randomMinDistance.r * (linkDistRandomVariationRange.g - linkDistRandomVariationRange.r) + linkDistRandomVariationRange.r;
        randomMinLinkDist *= linkDistance;

        iCount += 1.0;

        vec4 connectedPointPosition = texture2D(positionsTexture, (connectedPointIndex.rg + 0.5) / pointsTextureSize);
        float x = connectedPointPosition.x - (pointPosition.x + velocity.x);
        float y = connectedPointPosition.y - (pointPosition.y + velocity.y);
        float l = sqrt(x * x + y * y);

        // Apply the link force
        l = max(l, randomMinLinkDist * 0.99);
        l = (l - randomMinLinkDist) / l;
        l *= linkSpring * alpha;
        l *= strength;
        l *= bias;
        x *= l;
        y *= l;
        velocity.x += x;
        velocity.y += y;
      }
    }
  }

  gl_FragColor = vec4(velocity.rg, 0.0, 0.0);
}
  `;
}
var na = ((e3) => (e3.OUTGOING = "outgoing", e3.INCOMING = "incoming", e3))(na || {});
var Qf = class extends dn {
  constructor() {
    super(...arguments), this.linkFirstIndicesAndAmount = new Float32Array(), this.indices = new Float32Array(), this.maxPointDegree = 0;
  }
  create(t) {
    const { reglInstance: n, store: { pointsTextureSize: r, linksTextureSize: i }, data: o } = this;
    if (!r || !i) return;
    this.linkFirstIndicesAndAmount = new Float32Array(r * r * 4), this.indices = new Float32Array(i * i * 4);
    const f = new Float32Array(i * i * 4), s = new Float32Array(i * i * 4), u = t === "incoming" ? o.sourceIndexToTargetIndices : o.targetIndexToSourceIndices;
    this.maxPointDegree = 0;
    let l = 0;
    u == null || u.forEach((v, b) => {
      v && (this.linkFirstIndicesAndAmount[b * 4 + 0] = l % i, this.linkFirstIndicesAndAmount[b * 4 + 1] = Math.floor(l / i), this.linkFirstIndicesAndAmount[b * 4 + 2] = v.length ?? 0, v.forEach(([S, M]) => {
        var Ne, je, q;
        this.indices[l * 4 + 0] = S % r, this.indices[l * 4 + 1] = Math.floor(S / r);
        const K = ((Ne = o.degree) == null ? void 0 : Ne[S]) ?? 0, we = ((je = o.degree) == null ? void 0 : je[b]) ?? 0, ke = K / (K + we);
        let ae = ((q = o.linkStrength) == null ? void 0 : q[M]) ?? 1 / Math.min(K, we);
        ae = Math.sqrt(ae), f[l * 4 + 0] = ke, f[l * 4 + 1] = ae, s[l * 4] = this.store.getRandomFloat(0, 1), l += 1;
      }), this.maxPointDegree = Math.max(this.maxPointDegree, v.length ?? 0));
    }), this.linkFirstIndicesAndAmountTexture || (this.linkFirstIndicesAndAmountTexture = n.texture()), this.linkFirstIndicesAndAmountTexture({
      data: this.linkFirstIndicesAndAmount,
      shape: [r, r, 4],
      type: "float"
    }), this.linkFirstIndicesAndAmountFbo || (this.linkFirstIndicesAndAmountFbo = n.framebuffer({
      color: this.linkFirstIndicesAndAmountTexture,
      depth: false,
      stencil: false
    })), this.indicesTexture || (this.indicesTexture = n.texture()), this.indicesTexture({
      data: this.indices,
      shape: [i, i, 4],
      type: "float"
    }), this.indicesFbo || (this.indicesFbo = n.framebuffer({
      color: this.indicesTexture,
      depth: false,
      stencil: false
    })), this.biasAndStrengthTexture || (this.biasAndStrengthTexture = n.texture()), this.biasAndStrengthTexture({
      data: f,
      shape: [i, i, 4],
      type: "float"
    }), this.biasAndStrengthFbo || (this.biasAndStrengthFbo = n.framebuffer({
      color: this.biasAndStrengthTexture,
      depth: false,
      stencil: false
    })), this.randomDistanceTexture || (this.randomDistanceTexture = n.texture()), this.randomDistanceTexture({
      data: s,
      shape: [i, i, 4],
      type: "float"
    }), this.randomDistanceFbo || (this.randomDistanceFbo = n.framebuffer({
      color: this.randomDistanceTexture,
      depth: false,
      stencil: false
    }));
  }
  initPrograms() {
    const { reglInstance: t, config: n, store: r, points: i } = this;
    this.runCommand || (this.runCommand = t({
      frag: () => yv(this.maxPointDegree),
      vert: wt,
      framebuffer: () => i == null ? void 0 : i.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) },
      uniforms: {
        positionsTexture: () => i == null ? void 0 : i.previousPositionFbo,
        linkSpring: () => n.simulationLinkSpring,
        linkDistance: () => n.simulationLinkDistance,
        linkDistRandomVariationRange: () => n.simulationLinkDistRandomVariationRange,
        linkInfoTexture: () => this.linkFirstIndicesAndAmountFbo,
        linkIndicesTexture: () => this.indicesFbo,
        linkPropertiesTexture: () => this.biasAndStrengthFbo,
        linkRandomDistanceTexture: () => this.randomDistanceFbo,
        pointsTextureSize: () => r.pointsTextureSize,
        linksTextureSize: () => r.linksTextureSize,
        alpha: () => r.alpha
      }
    }));
  }
  run() {
    var t;
    (t = this.runCommand) == null || t.call(this);
  }
};
var Gu = `#ifdef GL_ES
precision highp float;
#endif

varying vec4 rgba;

void main() {
  gl_FragColor = rgba;
}`;
var Bu = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform float pointsTextureSize;
uniform float levelTextureSize;
uniform float cellSize;

attribute vec2 pointIndices;

varying vec4 rgba;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, pointIndices / pointsTextureSize);
  rgba = vec4(pointPosition.rg, 1.0, 0.0);

  float n = floor(pointPosition.x / cellSize);
  float m = floor(pointPosition.y / cellSize);
  
  vec2 levelPosition = 2.0 * (vec2(n, m) + 0.5) / levelTextureSize - 1.0;

  gl_Position = vec4(levelPosition, 0.0, 1.0);
  gl_PointSize = 1.0;
}`;
var bv = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D levelFbo;

uniform float level;
uniform float levels;
uniform float levelTextureSize;
uniform float repulsion;
uniform float alpha;
uniform float spaceSize;
uniform float theta;

varying vec2 textureCoords;

const float MAX_LEVELS_NUM = 14.0;

vec2 calculateAdditionalVelocity (vec2 ij, vec2 pp) {
  vec2 add = vec2(0.0);
  vec4 centermass = texture2D(levelFbo, ij);
  if (centermass.r > 0.0 && centermass.g > 0.0 && centermass.b > 0.0) {
    vec2 centermassPosition = vec2(centermass.rg / centermass.b);
    vec2 distVector = pp - centermassPosition;
    float l = dot(distVector, distVector);
    float dist = sqrt(l);
    if (l > 0.0) {
      float angle = atan(distVector.y, distVector.x);
      float c = alpha * repulsion * centermass.b;

      float distanceMin2 = 1.0;
      if (l < distanceMin2) l = sqrt(distanceMin2 * l);
      float addV = c / sqrt(l);
      add = addV * vec2(cos(angle), sin(angle));
    }
  }
  return add;
}

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  float x = pointPosition.x;
  float y = pointPosition.y;

  float left = 0.0;
  float top = 0.0;
  float right = spaceSize;
  float bottom = spaceSize;

  float n_left = 0.0;
  float n_top = 0.0;
  float n_right = 0.0;
  float n_bottom = 0.0;

  float cellSize = 0.0;

  
  for (float i = 0.0; i < MAX_LEVELS_NUM; i += 1.0) {
    if (i <= level) {
      left += cellSize * n_left;
      top += cellSize * n_top;
      right -= cellSize * n_right;
      bottom -= cellSize * n_bottom;

      cellSize = pow(2.0 , levels - i - 1.0);

      float dist_left = x - left;
      n_left = max(0.0, floor(dist_left / cellSize - theta));

      float dist_top = y - top;
      n_top = max(0.0, floor(dist_top / cellSize - theta));
      
      float dist_right = right - x;
      n_right = max(0.0, floor(dist_right / cellSize - theta));

      float dist_bottom = bottom - y;
      n_bottom = max(0.0, floor(dist_bottom / cellSize - theta));

    }
  }

  vec4 velocity = vec4(vec2(0.0), 1.0, 0.0);

  
  for (float i = 0.0; i < 12.0; i += 1.0) {
    for (float j = 0.0; j < 4.0; j += 1.0) {
      float n = left + cellSize * j;
      float m = top + cellSize * n_top + cellSize * i;

      if (n < (left + n_left * cellSize) && m < bottom) {
        velocity.xy += calculateAdditionalVelocity(vec2(n / cellSize, m / cellSize) / levelTextureSize, pointPosition.xy);
      }

      n = left + cellSize * i;
      m = top + cellSize * j;

      if (n < (right - n_right * cellSize) && m < (top + n_top * cellSize)) {
        velocity.xy += calculateAdditionalVelocity(vec2(n / cellSize, m / cellSize) / levelTextureSize, pointPosition.xy);
      }

      n = right - n_right * cellSize + cellSize * j;
      m = top + cellSize * i;

      if (n < right && m < (bottom - n_bottom * cellSize)) {
        velocity.xy += calculateAdditionalVelocity(vec2(n / cellSize, m / cellSize) / levelTextureSize, pointPosition.xy);
      }

      n = left + n_left * cellSize + cellSize * i;
      m = bottom - n_bottom * cellSize + cellSize * j;

      if (n < right && m < bottom) {
        velocity.xy += calculateAdditionalVelocity(vec2(n / cellSize, m / cellSize) / levelTextureSize, pointPosition.xy);
      }
    }
  }

  gl_FragColor = velocity;
}`;
var _v = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D levelFbo;
uniform sampler2D randomValues;

uniform float levelTextureSize;
uniform float repulsion;
uniform float alpha;

varying vec2 textureCoords;

vec2 calculateAdditionalVelocity (vec2 ij, vec2 pp) {
  vec2 add = vec2(0.0);
  vec4 centermass = texture2D(levelFbo, ij);
  if (centermass.r > 0.0 && centermass.g > 0.0 && centermass.b > 0.0) {
    vec2 centermassPosition = vec2(centermass.rg / centermass.b);
    vec2 distVector = pp - centermassPosition;
    float l = dot(distVector, distVector);
    float dist = sqrt(l);
    if (l > 0.0) {
      float angle = atan(distVector.y, distVector.x);
      float c = alpha * repulsion * centermass.b;

      float distanceMin2 = 1.0;
      if (l < distanceMin2) l = sqrt(distanceMin2 * l);
      float addV = c / sqrt(l);
      add = addV * vec2(cos(angle), sin(angle));
    }
  }
  return add;
}

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 random = texture2D(randomValues, textureCoords);

  vec4 velocity = vec4(0.0);

  
  velocity.xy += calculateAdditionalVelocity(pointPosition.xy / levelTextureSize, pointPosition.xy);
  
  velocity.xy += velocity.xy * random.rg;

  gl_FragColor = velocity;
}`;
var Sv = class extends dn {
  constructor() {
    super(...arguments), this.levelsFbos = /* @__PURE__ */ new Map(), this.quadtreeLevels = 0;
  }
  create() {
    const { reglInstance: t, store: n } = this;
    if (!n.pointsTextureSize) return;
    this.quadtreeLevels = Math.log2(n.adjustedSpaceSize);
    for (let i = 0; i < this.quadtreeLevels; i += 1) {
      const o = Math.pow(2, i + 1);
      this.levelsFbos.has(`level[${i}]`) || this.levelsFbos.set(`level[${i}]`, t.framebuffer());
      const f = this.levelsFbos.get(`level[${i}]`);
      f && f({
        shape: [o, o],
        colorType: "float",
        depth: false,
        stencil: false
      });
    }
    const r = new Float32Array(n.pointsTextureSize * n.pointsTextureSize * 4);
    for (let i = 0; i < n.pointsTextureSize * n.pointsTextureSize; ++i)
      r[i * 4] = n.getRandomFloat(-1, 1) * 1e-5, r[i * 4 + 1] = n.getRandomFloat(-1, 1) * 1e-5;
    this.randomValuesTexture || (this.randomValuesTexture = t.texture()), this.randomValuesTexture({
      data: r,
      shape: [n.pointsTextureSize, n.pointsTextureSize, 4],
      type: "float"
    }), this.randomValuesFbo || (this.randomValuesFbo = t.framebuffer({
      color: this.randomValuesTexture,
      depth: false,
      stencil: false
    })), this.pointIndices || (this.pointIndices = t.buffer(0)), this.pointIndices(Bn(n.pointsTextureSize));
  }
  initPrograms() {
    const { reglInstance: t, config: n, store: r, data: i, points: o } = this;
    this.clearLevelsCommand || (this.clearLevelsCommand = t({
      frag: $n,
      vert: wt,
      framebuffer: (f, s) => s.levelFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) }
    })), this.calculateLevelsCommand || (this.calculateLevelsCommand = t({
      frag: Gu,
      vert: Bu,
      framebuffer: (f, s) => s.levelFbo,
      primitive: "points",
      count: () => i.pointsNumber ?? 0,
      attributes: {
        pointIndices: {
          buffer: this.pointIndices,
          size: 2
        }
      },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        pointsTextureSize: () => r.pointsTextureSize,
        levelTextureSize: (f, s) => s.levelTextureSize,
        cellSize: (f, s) => s.cellSize
      },
      blend: {
        enable: true,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: false, mask: false },
      stencil: { enable: false }
    })), this.forceCommand || (this.forceCommand = t({
      frag: bv,
      vert: wt,
      framebuffer: () => o == null ? void 0 : o.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        level: (f, s) => s.level,
        levels: this.quadtreeLevels,
        levelFbo: (f, s) => s.levelFbo,
        levelTextureSize: (f, s) => s.levelTextureSize,
        alpha: () => r.alpha,
        repulsion: () => n.simulationRepulsion,
        spaceSize: () => r.adjustedSpaceSize,
        theta: () => n.simulationRepulsionTheta
      },
      blend: {
        enable: true,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: false, mask: false },
      stencil: { enable: false }
    })), this.forceFromItsOwnCentermassCommand || (this.forceFromItsOwnCentermassCommand = t({
      frag: _v,
      vert: wt,
      framebuffer: () => o == null ? void 0 : o.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        randomValues: () => this.randomValuesFbo,
        levelFbo: (f, s) => s.levelFbo,
        levelTextureSize: (f, s) => s.levelTextureSize,
        alpha: () => r.alpha,
        repulsion: () => n.simulationRepulsion,
        spaceSize: () => r.adjustedSpaceSize
      },
      blend: {
        enable: true,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: false, mask: false },
      stencil: { enable: false }
    })), this.clearVelocityCommand || (this.clearVelocityCommand = t({
      frag: $n,
      vert: wt,
      framebuffer: () => o == null ? void 0 : o.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) }
    }));
  }
  run() {
    var n, r, i, o, f;
    const { store: t } = this;
    for (let s = 0; s < this.quadtreeLevels; s += 1) {
      (n = this.clearLevelsCommand) == null || n.call(this, { levelFbo: this.levelsFbos.get(`level[${s}]`) });
      const u = Math.pow(2, s + 1), l = t.adjustedSpaceSize / u;
      (r = this.calculateLevelsCommand) == null || r.call(this, {
        levelFbo: this.levelsFbos.get(`level[${s}]`),
        levelTextureSize: u,
        cellSize: l
      });
    }
    (i = this.clearVelocityCommand) == null || i.call(this);
    for (let s = 0; s < this.quadtreeLevels; s += 1) {
      const u = Math.pow(2, s + 1);
      (o = this.forceCommand) == null || o.call(this, {
        levelFbo: this.levelsFbos.get(`level[${s}]`),
        levelTextureSize: u,
        level: s
      }), s === this.quadtreeLevels - 1 && ((f = this.forceFromItsOwnCentermassCommand) == null || f.call(this, {
        levelFbo: this.levelsFbos.get(`level[${s}]`),
        levelTextureSize: u,
        level: s
      }));
    }
  }
};
function wv(e3, t) {
  e3 = Math.min(e3, t);
  const n = t - e3, r = `
    float dist = sqrt(l);
    if (dist > 0.0) {
      float c = alpha * repulsion * centermass.b;
      addVelocity += calcAdd(vec2(x, y), l, c);
      addVelocity += addVelocity * random.rg;
    }
  `;
  function i(o) {
    if (o >= t)
      return r;
    {
      const f = Math.pow(2, o + 1), s = new Array(o + 1 - n).fill(0).map((l, v) => `pow(2.0, ${o - (v + n)}.0) * i${v + n}`).join("+"), u = new Array(o + 1 - n).fill(0).map((l, v) => `pow(2.0, ${o - (v + n)}.0) * j${v + n}`).join("+");
      return `
      for (float ij${o} = 0.0; ij${o} < 4.0; ij${o} += 1.0) {
        float i${o} = 0.0;
        float j${o} = 0.0;
        if (ij${o} == 1.0 || ij${o} == 3.0) i${o} = 1.0;
        if (ij${o} == 2.0 || ij${o} == 3.0) j${o} = 1.0;
        float i = pow(2.0, ${e3}.0) * n / width${o + 1} + ${s};
        float j = pow(2.0, ${e3}.0) * m / width${o + 1} + ${u};
        float groupPosX = (i + 0.5) / ${f}.0;
        float groupPosY = (j + 0.5) / ${f}.0;
        
        vec4 centermass = texture2D(level[${o}], vec2(groupPosX, groupPosY));
        if (centermass.r > 0.0 && centermass.g > 0.0 && centermass.b > 0.0) {
          float x = centermass.r / centermass.b - pointPosition.r;
          float y = centermass.g / centermass.b - pointPosition.g;
          float l = x * x + y * y;
          if ((width${o + 1} * width${o + 1}) / theta < l) {
            ${r}
          } else {
            ${i(o + 1)}
          }
        }
      }
      `;
    }
  }
  return `
#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D randomValues;
uniform float spaceSize;
uniform float repulsion;
uniform float theta;
uniform float alpha;
uniform sampler2D level[${t}];
varying vec2 textureCoords;

vec2 calcAdd(vec2 xy, float l, float c) {
  float distanceMin2 = 1.0;
  if (l < distanceMin2) l = sqrt(distanceMin2 * l);
  float add = c / l;
  return add * xy;
}

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 random = texture2D(randomValues, textureCoords);

  float width0 = spaceSize;

  vec2 velocity = vec2(0.0);
  vec2 addVelocity = vec2(0.0);

  ${new Array(t).fill(0).map((o, f) => `float width${f + 1} = width${f} / 2.0;`).join(`
`)}

  for (float n = 0.0; n < pow(2.0, ${n}.0); n += 1.0) {
    for (float m = 0.0; m < pow(2.0, ${n}.0); m += 1.0) {
      ${i(n)}
    }
  }

  velocity -= addVelocity;

  gl_FragColor = vec4(velocity, 0.0, 0.0);
}
`;
}
var Tv = class extends dn {
  constructor() {
    super(...arguments), this.levelsTextures = /* @__PURE__ */ new Map(), this.levelsFbos = /* @__PURE__ */ new Map(), this.quadtreeLevels = 0;
  }
  create() {
    const { reglInstance: t, store: n } = this;
    if (!n.pointsTextureSize) return;
    this.quadtreeLevels = Math.log2(n.adjustedSpaceSize);
    for (let i = 0; i < this.quadtreeLevels; i += 1) {
      const o = Math.pow(2, i + 1), f = `level[${i}]`;
      this.levelsTextures.has(f) || this.levelsTextures.set(f, t.texture());
      const s = this.levelsTextures.get(f);
      s && s({
        data: new Float32Array(o * o * 4),
        shape: [o, o, 4],
        type: "float"
      }), this.levelsFbos.has(f) || this.levelsFbos.set(f, t.framebuffer({
        color: this.levelsTextures.get(f),
        depth: false,
        stencil: false
      }));
    }
    const r = new Float32Array(n.pointsTextureSize * n.pointsTextureSize * 4);
    for (let i = 0; i < n.pointsTextureSize * n.pointsTextureSize; ++i)
      r[i * 4] = n.getRandomFloat(-1, 1) * 1e-5, r[i * 4 + 1] = n.getRandomFloat(-1, 1) * 1e-5;
    this.randomValuesTexture || (this.randomValuesTexture = t.texture()), this.randomValuesTexture({
      data: r,
      shape: [n.pointsTextureSize, n.pointsTextureSize, 4],
      type: "float"
    }), this.randomValuesFbo || (this.randomValuesFbo = t.framebuffer({
      color: this.randomValuesTexture,
      depth: false,
      stencil: false
    })), this.pointIndices || (this.pointIndices = t.buffer(0)), this.pointIndices(Bn(n.pointsTextureSize));
  }
  initPrograms() {
    const { reglInstance: t, config: n, store: r, data: i, points: o } = this;
    this.clearLevelsCommand || (this.clearLevelsCommand = t({
      frag: $n,
      vert: wt,
      framebuffer: (f, s) => s.levelFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) }
    })), this.calculateLevelsCommand || (this.calculateLevelsCommand = t({
      frag: Gu,
      vert: Bu,
      framebuffer: (f, s) => s.levelFbo,
      primitive: "points",
      count: () => i.pointsNumber ?? 0,
      attributes: {
        pointIndices: {
          buffer: this.pointIndices,
          size: 2
        }
      },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        pointsTextureSize: () => r.pointsTextureSize,
        levelTextureSize: (f, s) => s.levelTextureSize,
        cellSize: (f, s) => s.cellSize
      },
      blend: {
        enable: true,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: false, mask: false },
      stencil: { enable: false }
    })), this.quadtreeCommand = t({
      frag: wv(n.simulationRepulsionQuadtreeLevels ?? this.quadtreeLevels, this.quadtreeLevels),
      vert: wt,
      framebuffer: () => o == null ? void 0 : o.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        randomValues: () => this.randomValuesFbo,
        spaceSize: () => r.adjustedSpaceSize,
        repulsion: () => n.simulationRepulsion,
        theta: () => n.simulationRepulsionTheta,
        alpha: () => r.alpha,
        ...Object.fromEntries(this.levelsFbos)
      }
    });
  }
  run() {
    var n, r, i;
    const { store: t } = this;
    for (let o = 0; o < this.quadtreeLevels; o += 1) {
      (n = this.clearLevelsCommand) == null || n.call(this, { levelFbo: this.levelsFbos.get(`level[${o}]`) });
      const f = Math.pow(2, o + 1), s = t.adjustedSpaceSize / f;
      (r = this.calculateLevelsCommand) == null || r.call(this, {
        levelFbo: this.levelsFbos.get(`level[${o}]`),
        levelTextureSize: f,
        cellSize: s
      });
    }
    (i = this.quadtreeCommand) == null || i.call(this);
  }
};
var Av = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform float repulsion;
uniform vec2 mousePos;

varying vec2 textureCoords;

void main() {  
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 velocity = vec4(0.0);
  vec2 mouse = mousePos;
  
  vec2 distVector = mouse - pointPosition.rg;
  float dist = sqrt(dot(distVector, distVector));
  dist = max(dist, 10.0);
  float angle = atan(distVector.y, distVector.x);
  float addV = 100.0 * repulsion / (dist * dist);
  velocity.rg -= addV * vec2(cos(angle), sin(angle));

  gl_FragColor = velocity;
}`;
var Ev = class extends dn {
  initPrograms() {
    const { reglInstance: t, config: n, store: r, points: i } = this;
    this.runCommand || (this.runCommand = t({
      frag: Av,
      vert: wt,
      framebuffer: () => i == null ? void 0 : i.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) },
      uniforms: {
        positionsTexture: () => i == null ? void 0 : i.previousPositionFbo,
        mousePos: () => r.mousePosition,
        repulsion: () => n.simulationRepulsionFromMouse
      }
    }));
  }
  run() {
    var t;
    (t = this.runCommand) == null || t.call(this);
  }
};
var Pv = `#ifdef GL_ES
precision highp float;
#endif

varying vec4 rgba;

void main() {
  gl_FragColor = rgba;
}`;
var Cv = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D clusterTexture;
uniform float pointsTextureSize;
uniform float clustersTextureSize;

attribute vec2 pointIndices;

varying vec4 rgba;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, pointIndices / pointsTextureSize);
  rgba = vec4(pointPosition.xy, 1.0, 0.0);

  vec4 pointClusterIndices = texture2D(clusterTexture, pointIndices / pointsTextureSize);
  vec2 xy = vec2(0.0);
  if (pointClusterIndices.x >= 0.0 && pointClusterIndices.y >= 0.0) {
    xy = 2.0 * (pointClusterIndices.xy + 0.5) / clustersTextureSize - 1.0;
  }
  
  gl_Position = vec4(xy, 0.0, 1.0);
  gl_PointSize = 1.0;
}`;
var kv = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D centermassTexture;
uniform sampler2D clusterTexture;
uniform sampler2D clusterPositionsTexture;
uniform sampler2D clusterForceCoefficient;
uniform float alpha;
uniform float clustersTextureSize;
uniform float clusterCoefficient;

varying vec2 textureCoords;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 velocity = vec4(0.0);
  vec4 pointClusterIndices = texture2D(clusterTexture, textureCoords);
  
  if (pointClusterIndices.x >= 0.0 && pointClusterIndices.y >= 0.0) {
    
    vec2 clusterPositions = texture2D(clusterPositionsTexture, pointClusterIndices.xy / clustersTextureSize).xy;
    if (clusterPositions.x < 0.0 || clusterPositions.y < 0.0) {
      vec4 centermassValues = texture2D(centermassTexture, pointClusterIndices.xy / clustersTextureSize);
      clusterPositions = centermassValues.xy / centermassValues.b;
    }
    vec4 clusterCustomCoeff = texture2D(clusterForceCoefficient, textureCoords);
    vec2 distVector = clusterPositions.xy - pointPosition.xy;
    float dist = sqrt(dot(distVector, distVector));
    if (dist > 0.0) {
      float angle = atan(distVector.y, distVector.x);
      float addV = alpha * dist * clusterCoefficient * clusterCustomCoeff.r;
      velocity.rg += addV * vec2(cos(angle), sin(angle));
    }
  }

  gl_FragColor = velocity;
}`;
var Fv = class extends dn {
  create() {
    var l;
    const { reglInstance: t, store: n, data: r } = this, { pointsTextureSize: i } = n;
    if (r.pointsNumber === void 0 || !r.pointClusters && !r.clusterPositions) return;
    const o = (r.pointClusters ?? []).reduce((v, b) => b === void 0 ? v : Math.max(v, b), 0) + 1;
    this.clustersTextureSize = Math.ceil(Math.sqrt(o)), this.clusterTexture || (this.clusterTexture = t.texture()), this.clusterPositionsTexture || (this.clusterPositionsTexture = t.texture()), this.clusterForceCoefficientTexture || (this.clusterForceCoefficientTexture = t.texture());
    const f = new Float32Array(i * i * 4), s = new Float32Array(this.clustersTextureSize * this.clustersTextureSize * 4).fill(-1), u = new Float32Array(i * i * 4).fill(1);
    if (r.clusterPositions)
      for (let v = 0; v < o; ++v)
        s[v * 4 + 0] = r.clusterPositions[v * 2 + 0] ?? -1, s[v * 4 + 1] = r.clusterPositions[v * 2 + 1] ?? -1;
    for (let v = 0; v < r.pointsNumber; ++v) {
      const b = (l = r.pointClusters) == null ? void 0 : l[v];
      b === void 0 ? (f[v * 4 + 0] = -1, f[v * 4 + 1] = -1) : (f[v * 4 + 0] = b % this.clustersTextureSize, f[v * 4 + 1] = Math.floor(b / this.clustersTextureSize)), r.clusterStrength && (u[v * 4 + 0] = r.clusterStrength[v] ?? 1);
    }
    this.clusterTexture({
      data: f,
      shape: [i, i, 4],
      type: "float"
    }), this.clusterFbo || (this.clusterFbo = t.framebuffer({
      color: this.clusterTexture,
      depth: false,
      stencil: false
    })), this.clusterPositionsTexture({
      data: s,
      shape: [this.clustersTextureSize, this.clustersTextureSize, 4],
      type: "float"
    }), this.clusterPositionsFbo || (this.clusterPositionsFbo = t.framebuffer({
      color: this.clusterPositionsTexture,
      depth: false,
      stencil: false
    })), this.clusterForceCoefficientTexture({
      data: u,
      shape: [i, i, 4],
      type: "float"
    }), this.clusterForceCoefficientFbo || (this.clusterForceCoefficientFbo = t.framebuffer({
      color: this.clusterForceCoefficientTexture,
      depth: false,
      stencil: false
    })), this.centermassTexture || (this.centermassTexture = t.texture()), this.centermassTexture({
      data: new Float32Array(this.clustersTextureSize * this.clustersTextureSize * 4).fill(0),
      shape: [this.clustersTextureSize, this.clustersTextureSize, 4],
      type: "float"
    }), this.centermassFbo || (this.centermassFbo = t.framebuffer({
      color: this.centermassTexture,
      depth: false,
      stencil: false
    })), this.pointIndices || (this.pointIndices = t.buffer(0)), this.pointIndices(Bn(n.pointsTextureSize));
  }
  initPrograms() {
    const { reglInstance: t, store: n, data: r, points: i } = this;
    r.pointClusters !== void 0 && (this.clearCentermassCommand || (this.clearCentermassCommand = t({
      frag: $n,
      vert: wt,
      framebuffer: () => this.centermassFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) }
    })), this.calculateCentermassCommand || (this.calculateCentermassCommand = t({
      frag: Pv,
      vert: Cv,
      framebuffer: () => this.centermassFbo,
      primitive: "points",
      count: () => r.pointsNumber ?? 0,
      attributes: {
        pointIndices: {
          buffer: this.pointIndices,
          size: 2
        }
      },
      uniforms: {
        positionsTexture: () => i == null ? void 0 : i.previousPositionFbo,
        pointsTextureSize: () => n.pointsTextureSize,
        clusterTexture: () => this.clusterFbo,
        clustersTextureSize: () => this.clustersTextureSize
      },
      blend: {
        enable: true,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: false, mask: false },
      stencil: { enable: false }
    })), this.applyForcesCommand || (this.applyForcesCommand = t({
      frag: kv,
      vert: wt,
      framebuffer: () => i == null ? void 0 : i.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) },
      uniforms: {
        positionsTexture: () => i == null ? void 0 : i.previousPositionFbo,
        clusterTexture: () => this.clusterFbo,
        centermassTexture: () => this.centermassFbo,
        clusterPositionsTexture: () => this.clusterPositionsFbo,
        clusterForceCoefficient: () => this.clusterForceCoefficientFbo,
        alpha: () => n.alpha,
        clustersTextureSize: () => this.clustersTextureSize,
        clusterCoefficient: () => this.config.simulationCluster
      }
    })));
  }
  run() {
    var t, n, r;
    !this.data.pointClusters && !this.data.clusterPositions || ((t = this.clearCentermassCommand) == null || t.call(this), (n = this.calculateCentermassCommand) == null || n.call(this), (r = this.applyForcesCommand) == null || r.call(this));
  }
};
var Vu = { exports: {} };
(function(e3, t) {
  (function(n, r) {
    e3.exports = r();
  })(hn, function() {
    var n = `<div class="gl-box">
  <svg viewBox="0 0 55 60">
    <text x="27" y="56" class="gl-fps">00 FPS</text>
    <text x="28" y="8" class="gl-mem"></text>
    <rect x="0" y="14" rx="4" ry="4" width="55" height="32"></rect>
    <polyline class="gl-chart"></polyline>
  </svg>
  <svg viewBox="0 0 14 60" class="gl-cpu-svg">
    <line x1="7" y1="38" x2="7" y2="11" class="opacity"/>
    <line x1="7" y1="38" x2="7" y2="11" class="gl-cpu" stroke-dasharray="0 27"/>
    <path d="M5.35 43c-.464 0-.812.377-.812.812v1.16c-.783.1972-1.421.812-1.595 1.624h-1.16c-.435 0-.812.348-.812.812s.348.812.812.812h1.102v1.653H1.812c-.464 0-.812.377-.812.812 0 .464.377.812.812.812h1.131c.1943.783.812 1.392 1.595 1.595v1.131c0 .464.377.812.812.812.464 0 .812-.377.812-.812V53.15h1.653v1.073c0 .464.377.812.812.812.464 0 .812-.377.812-.812v-1.131c.783-.1943 1.392-.812 1.595-1.595h1.131c.464 0 .812-.377.812-.812 0-.464-.377-.812-.812-.812h-1.073V48.22h1.102c.435 0 .812-.348.812-.812s-.348-.812-.812-.812h-1.16c-.1885-.783-.812-1.421-1.595-1.624v-1.131c0-.464-.377-.812-.812-.812-.464 0-.812.377-.812.812v1.073H6.162v-1.073c0-.464-.377-.812-.812-.812zm.58 3.48h2.088c.754 0 1.363.609 1.363 1.363v2.088c0 .754-.609 1.363-1.363 1.363H5.93c-.754 0-1.363-.609-1.363-1.363v-2.088c0-.754.609-1.363 1.363-1.363z"/>
  </svg>
  <svg viewBox="0 0 14 60" class="gl-gpu-svg">
    <line x1="7" y1="38" x2="7" y2="11" class="opacity"/>
    <line x1="7" y1="38" x2="7" y2="11" class="gl-gpu" stroke-dasharray="0 27"/>
    <path d="M1.94775 43.3772a.736.736 0 10-.00416 1.472c.58535.00231.56465.1288.6348.3197.07015.18975.04933.43585.04933.43585l-.00653.05405v8.671a.736.736 0 101.472 0v-1.4145c.253.09522.52785.1495.81765.1495h5.267c1.2535 0 2.254-.9752 2.254-2.185v-3.105c0-1.2075-1.00625-2.185-2.254-2.185h-5.267c-.28865 0-.5635.05405-.8165.1495.01806-.16445.04209-.598-.1357-1.0787-.22425-.6072-.9499-1.2765-2.0125-1.2765zm2.9095 3.6455c.42435 0 .7659.36225.7659.8119v2.9785c0 .44965-.34155.8119-.7659.8119s-.7659-.36225-.7659-.8119v-2.9785c0-.44965.34155-.8119.7659-.8119zm4.117 0a2.3 2.3 0 012.3 2.3 2.3 2.3 0 01-2.3 2.3 2.3 2.3 0 01-2.3-2.3 2.3 2.3 0 012.3-2.3z"/>
  </svg>
</div>`, r = `#gl-bench {
  position:absolute;
  left:0;
  top:0;
  z-index:1000;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
}

#gl-bench div {
  position: relative;
  display: block;
  margin: 4px;
  padding: 0 7px 0 10px;
  background: #6c6;
  border-radius: 15px;
  cursor: pointer;
  opacity: 0.9;
}

#gl-bench svg {
  height: 60px;
  margin: 0 -1px;
}

#gl-bench text {
  font-size: 12px;
  font-family: Helvetica,Arial,sans-serif;
  font-weight: 700;
  dominant-baseline: middle;
  text-anchor: middle;
}

#gl-bench .gl-mem {
  font-size: 9px;
}

#gl-bench line {
  stroke-width: 5;
  stroke: #112211;
  stroke-linecap: round;
}

#gl-bench polyline {
  fill: none;
  stroke: #112211;
  stroke-linecap: round;
  stroke-linejoin: round;
  stroke-width: 3.5;
}

#gl-bench rect {
  fill: #448844;
}

#gl-bench .opacity {
  stroke: #448844;
}
`;
    class i {
      /** GLBench constructor
       * @param { WebGLRenderingContext | WebGL2RenderingContext } gl context
       * @param { Object | undefined } settings additional settings
       */
      constructor(f, s = {}) {
        this.css = r, this.svg = n, this.paramLogger = () => {
        }, this.chartLogger = () => {
        }, this.chartLen = 20, this.chartHz = 20, this.names = [], this.cpuAccums = [], this.gpuAccums = [], this.activeAccums = [], this.chart = new Array(this.chartLen), this.now = () => performance && performance.now ? performance.now() : Date.now(), this.updateUI = () => {
          [].forEach.call(this.nodes["gl-gpu-svg"], (S) => {
            S.style.display = this.trackGPU ? "inline" : "none";
          });
        }, Object.assign(this, s), this.detected = 0, this.finished = [], this.isFramebuffer = 0, this.frameId = 0;
        let u, l = 0, v, b = (S) => {
          ++l < 20 ? u = requestAnimationFrame(b) : (this.detected = Math.ceil(1e3 * l / (S - v) / 70), cancelAnimationFrame(u)), v || (v = S);
        };
        if (requestAnimationFrame(b), f) {
          const S = async (K, we) => Promise.resolve(setTimeout(() => {
            f.getError();
            const ke = this.now() - K;
            we.forEach((ae, Ne) => {
              ae && (this.gpuAccums[Ne] += ke);
            });
          }, 0)), M = (K, we, ke) => function() {
            const ae = we.now();
            K.apply(ke, arguments), we.trackGPU && we.finished.push(S(ae, we.activeAccums.slice(0)));
          };
          [
            "drawArrays",
            "drawElements",
            "drawArraysInstanced",
            "drawBuffers",
            "drawElementsInstanced",
            "drawRangeElements"
          ].forEach((K) => {
            f[K] && (f[K] = M(f[K], this, f));
          }), f.getExtension = /* @__PURE__ */ ((K, we) => function() {
            let ke = K.apply(f, arguments);
            return ke && ["drawElementsInstancedANGLE", "drawBuffersWEBGL"].forEach((ae) => {
              ke[ae] && (ke[ae] = M(ke[ae], we, ke));
            }), ke;
          })(f.getExtension, this);
        }
        if (!this.withoutUI) {
          this.dom || (this.dom = document.body);
          let S = document.createElement("div");
          S.id = "gl-bench", this.dom.appendChild(S), this.dom.insertAdjacentHTML("afterbegin", '<style id="gl-bench-style">' + this.css + "</style>"), this.dom = S, this.dom.addEventListener("click", () => {
            this.trackGPU = !this.trackGPU, this.updateUI();
          }), this.paramLogger = ((M, K, we) => {
            const ke = ["gl-cpu", "gl-gpu", "gl-mem", "gl-fps", "gl-gpu-svg", "gl-chart"], ae = Object.assign({}, ke);
            return ke.forEach((Ne) => ae[Ne] = K.getElementsByClassName(Ne)), this.nodes = ae, (Ne, je, q, pe, De, Ge, qe) => {
              ae["gl-cpu"][Ne].style.strokeDasharray = (je * 0.27).toFixed(0) + " 100", ae["gl-gpu"][Ne].style.strokeDasharray = (q * 0.27).toFixed(0) + " 100", ae["gl-mem"][Ne].innerHTML = we[Ne] ? we[Ne] : pe ? "mem: " + pe.toFixed(0) + "mb" : "", ae["gl-fps"][Ne].innerHTML = De.toFixed(0) + " FPS", M(we[Ne], je, q, pe, De, Ge, qe);
            };
          })(this.paramLogger, this.dom, this.names), this.chartLogger = ((M, K) => {
            let we = { "gl-chart": K.getElementsByClassName("gl-chart") };
            return (ke, ae, Ne) => {
              let je = "", q = ae.length;
              for (let pe = 0; pe < q; pe++) {
                let De = (Ne + pe + 1) % q;
                ae[De] != null && (je = je + " " + (55 * pe / (q - 1)).toFixed(1) + "," + (45 - ae[De] * 22 / 60 / this.detected).toFixed(1));
              }
              we["gl-chart"][ke].setAttribute("points", je), M(this.names[ke], ae, Ne);
            };
          })(this.chartLogger, this.dom);
        }
      }
      /**
       * Explicit UI add
       * @param { string | undefined } name 
       */
      addUI(f) {
        this.names.indexOf(f) == -1 && (this.names.push(f), this.dom && (this.dom.insertAdjacentHTML("beforeend", this.svg), this.updateUI()), this.cpuAccums.push(0), this.gpuAccums.push(0), this.activeAccums.push(false));
      }
      /**
       * Increase frameID
       * @param { number | undefined } now
       */
      nextFrame(f) {
        this.frameId++;
        const s = f || this.now();
        if (this.frameId <= 1)
          this.paramFrame = this.frameId, this.paramTime = s;
        else {
          let u = s - this.paramTime;
          if (u >= 1e3) {
            const l = this.frameId - this.paramFrame, v = l / u * 1e3;
            for (let b = 0; b < this.names.length; b++) {
              const S = this.cpuAccums[b] / u * 100, M = this.gpuAccums[b] / u * 100, K = performance && performance.memory ? performance.memory.usedJSHeapSize / (1 << 20) : 0;
              this.paramLogger(b, S, M, K, v, u, l), this.cpuAccums[b] = 0, Promise.all(this.finished).then(() => {
                this.gpuAccums[b] = 0, this.finished = [];
              });
            }
            this.paramFrame = this.frameId, this.paramTime = s;
          }
        }
        if (!this.detected || !this.chartFrame)
          this.chartFrame = this.frameId, this.chartTime = s, this.circularId = 0;
        else {
          let u = s - this.chartTime, l = this.chartHz * u / 1e3;
          for (; --l > 0 && this.detected; ) {
            const b = (this.frameId - this.chartFrame) / u * 1e3;
            this.chart[this.circularId % this.chartLen] = b;
            for (let S = 0; S < this.names.length; S++)
              this.chartLogger(S, this.chart, this.circularId);
            this.circularId++, this.chartFrame = this.frameId, this.chartTime = s;
          }
        }
      }
      /**
       * Begin named measurement
       * @param { string | undefined } name
       */
      begin(f) {
        this.updateAccums(f);
      }
      /**
       * End named measure
       * @param { string | undefined } name
       */
      end(f) {
        this.updateAccums(f);
      }
      updateAccums(f) {
        let s = this.names.indexOf(f);
        s == -1 && (s = this.names.length, this.addUI(f));
        const u = this.now(), l = u - this.t0;
        for (let v = 0; v < s + 1; v++)
          this.activeAccums[v] && (this.cpuAccums[v] += l);
        this.activeAccums[s] = !this.activeAccums[s], this.t0 = u;
      }
    }
    return i;
  });
})(Vu);
var Lv = Vu.exports;
var zv = ba(Lv);
var Iv = `
  #gl-bench {
    position:absolute;
    right:0;
    top:0;
    z-index:1000;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
  }
  #gl-bench div {
    position: relative;
    display: block;
    margin: 4px;
    padding: 0 7px 0 10px;
    background: #5f69de;
    border-radius: 15px;
    cursor: pointer;
    opacity: 0.9;
  }
  #gl-bench svg {
    height: 60px;
    margin: 0 -1px;
  }
  #gl-bench text {
    font-size: 12px;
    font-family: Helvetica,Arial,sans-serif;
    font-weight: 700;
    dominant-baseline: middle;
    text-anchor: middle;
  }
  #gl-bench .gl-mem {
    font-size: 9px;
  }
  #gl-bench line {
    stroke-width: 5;
    stroke: #112211;
    stroke-linecap: round;
  }
  #gl-bench polyline {
    fill: none;
    stroke: #112211;
    stroke-linecap: round;
    stroke-linejoin: round;
    stroke-width: 3.5;
  }
  #gl-bench rect {
    fill: #8288e4;
  }
  #gl-bench .opacity {
    stroke: #8288e4;
  }
`;
var Kf = class {
  constructor(t) {
    this.destroy();
    const n = t.getContext("webgl") || t.getContext("experimental-webgl");
    this.bench = new zv(n, { css: Iv });
  }
  begin() {
    var t;
    (t = this.bench) == null || t.begin("frame");
  }
  end(t) {
    var n, r;
    (n = this.bench) == null || n.end("frame"), (r = this.bench) == null || r.nextFrame(t);
  }
  destroy() {
    this.bench = void 0, St("#gl-bench").remove();
  }
};
var Rv = class {
  constructor(t) {
    this._config = t;
  }
  get pointsNumber() {
    return this.pointPositions && this.pointPositions.length / 2;
  }
  get linksNumber() {
    return this.links && this.links.length / 2;
  }
  updatePoints() {
    this.pointPositions = this.inputPointPositions;
  }
  /**
   * Updates the point colors based on the input data or default config value.
   */
  updatePointColor() {
    if (this.pointsNumber === void 0) {
      this.pointColors = void 0;
      return;
    }
    const t = ur(this._config.pointColor);
    if (this.inputPointColors === void 0 || this.inputPointColors.length / 4 !== this.pointsNumber) {
      this.pointColors = new Float32Array(this.pointsNumber * 4);
      for (let n = 0; n < this.pointColors.length / 4; n++)
        this.pointColors[n * 4] = t[0], this.pointColors[n * 4 + 1] = t[1], this.pointColors[n * 4 + 2] = t[2], this.pointColors[n * 4 + 3] = t[3];
    } else {
      this.pointColors = this.inputPointColors;
      for (let n = 0; n < this.pointColors.length / 4; n++)
        en(this.pointColors[n * 4]) || (this.pointColors[n * 4] = t[0]), en(this.pointColors[n * 4 + 1]) || (this.pointColors[n * 4 + 1] = t[1]), en(this.pointColors[n * 4 + 2]) || (this.pointColors[n * 4 + 2] = t[2]), en(this.pointColors[n * 4 + 3]) || (this.pointColors[n * 4 + 3] = t[3]);
    }
  }
  /**
   * Updates the point sizes based on the input data or default config value.
   */
  updatePointSize() {
    if (this.pointsNumber === void 0) {
      this.pointSizes = void 0;
      return;
    }
    if (this.inputPointSizes === void 0 || this.inputPointSizes.length !== this.pointsNumber)
      this.pointSizes = new Float32Array(this.pointsNumber).fill(this._config.pointSize);
    else {
      this.pointSizes = this.inputPointSizes;
      for (let t = 0; t < this.pointSizes.length; t++)
        en(this.pointSizes[t]) || (this.pointSizes[t] = this._config.pointSize);
    }
  }
  updateLinks() {
    this.links = this.inputLinks;
  }
  /**
   * Updates the link colors based on the input data or default config value.
   */
  updateLinkColor() {
    if (this.linksNumber === void 0) {
      this.linkColors = void 0;
      return;
    }
    const t = ur(this._config.linkColor);
    if (this.inputLinkColors === void 0 || this.inputLinkColors.length / 4 !== this.linksNumber) {
      this.linkColors = new Float32Array(this.linksNumber * 4);
      for (let n = 0; n < this.linkColors.length / 4; n++)
        this.linkColors[n * 4] = t[0], this.linkColors[n * 4 + 1] = t[1], this.linkColors[n * 4 + 2] = t[2], this.linkColors[n * 4 + 3] = t[3];
    } else {
      this.linkColors = this.inputLinkColors;
      for (let n = 0; n < this.linkColors.length / 4; n++)
        en(this.linkColors[n * 4]) || (this.linkColors[n * 4] = t[0]), en(this.linkColors[n * 4 + 1]) || (this.linkColors[n * 4 + 1] = t[1]), en(this.linkColors[n * 4 + 2]) || (this.linkColors[n * 4 + 2] = t[2]), en(this.linkColors[n * 4 + 3]) || (this.linkColors[n * 4 + 3] = t[3]);
    }
  }
  /**
   * Updates the link width based on the input data or default config value.
   */
  updateLinkWidth() {
    if (this.linksNumber === void 0) {
      this.linkWidths = void 0;
      return;
    }
    if (this.inputLinkWidths === void 0 || this.inputLinkWidths.length !== this.linksNumber)
      this.linkWidths = new Float32Array(this.linksNumber).fill(this._config.linkWidth);
    else {
      this.linkWidths = this.inputLinkWidths;
      for (let t = 0; t < this.linkWidths.length; t++)
        en(this.linkWidths[t]) || (this.linkWidths[t] = this._config.linkWidth);
    }
  }
  /**
   * Updates the link arrows based on the input data or default config value.
   */
  updateArrows() {
    if (this.linksNumber === void 0) {
      this.linkArrows = void 0;
      return;
    }
    this.linkArrowsBoolean === void 0 || this.linkArrowsBoolean.length !== this.linksNumber ? this.linkArrows = new Array(this.linksNumber).fill(+this._config.linkArrows) : this.linkArrows = this.linkArrowsBoolean.map((t) => +t);
  }
  updateLinkStrength() {
    this.linksNumber === void 0 && (this.linkStrength = void 0), this.inputLinkStrength === void 0 || this.inputLinkStrength.length !== this.linksNumber ? this.linkStrength = void 0 : this.linkStrength = this.inputLinkStrength;
  }
  updateClusters() {
    if (this.pointsNumber === void 0) {
      this.pointClusters = void 0, this.clusterPositions = void 0;
      return;
    }
    this.inputPointClusters === void 0 || this.inputPointClusters.length !== this.pointsNumber ? this.pointClusters = void 0 : this.pointClusters = this.inputPointClusters, this.inputClusterPositions === void 0 ? this.clusterPositions = void 0 : this.clusterPositions = this.inputClusterPositions, this.inputClusterStrength === void 0 || this.inputClusterStrength.length !== this.pointsNumber ? this.clusterStrength = void 0 : this.clusterStrength = this.inputClusterStrength;
  }
  update() {
    this.updatePoints(), this.updatePointColor(), this.updatePointSize(), this.updateLinks(), this.updateLinkColor(), this.updateLinkWidth(), this.updateArrows(), this.updateLinkStrength(), this.updateClusters(), this._createAdjacencyLists(), this._calculateDegrees();
  }
  getAdjacentIndices(t) {
    var n, r, i, o;
    return [...((r = (n = this.sourceIndexToTargetIndices) == null ? void 0 : n[t]) == null ? void 0 : r.map((f) => f[0])) || [], ...((o = (i = this.targetIndexToSourceIndices) == null ? void 0 : i[t]) == null ? void 0 : o.map((f) => f[0])) || []];
  }
  _createAdjacencyLists() {
    var t, n;
    if (this.linksNumber === void 0 || this.links === void 0) {
      this.sourceIndexToTargetIndices = void 0, this.targetIndexToSourceIndices = void 0;
      return;
    }
    this.sourceIndexToTargetIndices = new Array(this.pointsNumber).fill(void 0), this.targetIndexToSourceIndices = new Array(this.pointsNumber).fill(void 0);
    for (let r = 0; r < this.linksNumber; r++) {
      const i = this.links[r * 2], o = this.links[r * 2 + 1];
      i !== void 0 && o !== void 0 && (this.sourceIndexToTargetIndices[i] === void 0 && (this.sourceIndexToTargetIndices[i] = []), (t = this.sourceIndexToTargetIndices[i]) == null || t.push([o, r]), this.targetIndexToSourceIndices[o] === void 0 && (this.targetIndexToSourceIndices[o] = []), (n = this.targetIndexToSourceIndices[o]) == null || n.push([i, r]));
    }
  }
  _calculateDegrees() {
    var t, n, r, i;
    if (this.pointsNumber === void 0) {
      this.degree = void 0, this.inDegree = void 0, this.outDegree = void 0;
      return;
    }
    this.degree = new Array(this.pointsNumber).fill(0), this.inDegree = new Array(this.pointsNumber).fill(0), this.outDegree = new Array(this.pointsNumber).fill(0);
    for (let o = 0; o < this.pointsNumber; o++)
      this.inDegree[o] = ((n = (t = this.targetIndexToSourceIndices) == null ? void 0 : t[o]) == null ? void 0 : n.length) ?? 0, this.outDegree[o] = ((i = (r = this.sourceIndexToTargetIndices) == null ? void 0 : r[o]) == null ? void 0 : i.length) ?? 0, this.degree[o] = (this.inDegree[o] ?? 0) + (this.outDegree[o] ?? 0);
  }
};
var Dv = `precision highp float;

varying vec4 rgbaColor;
varying vec2 pos;
varying float arrowLength;
varying float linkWidthArrowWidthRatio;
varying float smoothWidthRatio;
varying float useArrow;

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

void main() {
  float opacity = 1.0;
  vec3 color = rgbaColor.rgb;
  float smoothDelta = smoothWidthRatio / 2.0;
  if (useArrow > 0.5) {
    float end_arrow = 0.5 + arrowLength / 2.0;
    float start_arrow = end_arrow - arrowLength;
    float arrowWidthDelta = linkWidthArrowWidthRatio / 2.0;
    float linkOpacity = rgbaColor.a * smoothstep(0.5 - arrowWidthDelta, 0.5 - arrowWidthDelta - smoothDelta, abs(pos.y));
    float arrowOpacity = 1.0;
    if (pos.x > start_arrow && pos.x < start_arrow + arrowLength) {
      float xmapped = map(pos.x, start_arrow, end_arrow, 0.0, 1.0);
      arrowOpacity = rgbaColor.a * smoothstep(xmapped - smoothDelta, xmapped, map(abs(pos.y), 0.5, 0.0, 0.0, 1.0));
      if (linkOpacity != arrowOpacity) {
        linkOpacity += arrowOpacity;
      }
    }
    opacity = linkOpacity;
  } else opacity = rgbaColor.a * smoothstep(0.5, 0.5 - smoothDelta, abs(pos.y));
  
  gl_FragColor = vec4(color, opacity);
}`;
var Mv = `precision highp float;
attribute vec2 position, pointA, pointB;
attribute vec4 color;
attribute float width;
attribute float arrow;
uniform sampler2D positionsTexture;
uniform sampler2D pointGreyoutStatus;
uniform mat3 transformationMatrix;
uniform float pointsTextureSize;
uniform float widthScale;
uniform float arrowSizeScale;
uniform float spaceSize;
uniform vec2 screenSize;
uniform float ratio;
uniform vec2 linkVisibilityDistanceRange;
uniform float linkVisibilityMinTransparency;
uniform float greyoutOpacity;
uniform float curvedWeight;
uniform float curvedLinkControlPointDistance;
uniform float curvedLinkSegments;

varying vec4 rgbaColor;
varying vec2 pos;
varying float arrowLength;
varying float linkWidthArrowWidthRatio;
varying float smoothWidthRatio;
varying float useArrow;

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec2 conicParametricCurve(vec2 A, vec2 B, vec2 ControlPoint, float t, float w) {
  vec2 divident = (1.0 - t) * (1.0 - t) * A + 2.0 * (1.0 - t) * t * w * ControlPoint + t * t * B;
  float divisor = (1.0 - t) * (1.0 - t) + 2.0 * (1.0 - t) * t * w + t * t;
  return divident / divisor;
}

void main() {
  pos = position;

  vec2 pointTexturePosA = (pointA + 0.5) / pointsTextureSize;
  vec2 pointTexturePosB = (pointB + 0.5) / pointsTextureSize;
  
  vec4 greyoutStatusA = texture2D(pointGreyoutStatus, pointTexturePosA);
  vec4 greyoutStatusB = texture2D(pointGreyoutStatus, pointTexturePosB);
  
  vec4 pointPositionA = texture2D(positionsTexture, pointTexturePosA);
  vec4 pointPositionB = texture2D(positionsTexture, pointTexturePosB);
  vec2 a = pointPositionA.xy;
  vec2 b = pointPositionB.xy;
  vec2 xBasis = b - a;
  vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));

  
  float linkDist = length(xBasis);
  float h = curvedLinkControlPointDistance;
  vec2 controlPoint = (a + b) / 2.0 + yBasis * linkDist * h;

  float linkDistPx = linkDist * transformationMatrix[0][0];
  
  float linkWidth = width * widthScale;
  float k = 2.0;
  float arrowWidth = max(5.0, linkWidth * k);
  arrowWidth *= arrowSizeScale;

  float arrowWidthPx = arrowWidth / transformationMatrix[0][0];
  arrowLength = min(0.3, (0.866 * arrowWidthPx * 2.0) / linkDist);

  float smoothWidth = 2.0;
  float arrowExtraWidth = arrowWidth - linkWidth;
  linkWidth += smoothWidth / 2.0;
  useArrow = arrow;
  if (useArrow > 0.5) {
    linkWidth += arrowExtraWidth;
  }
  smoothWidthRatio = smoothWidth / linkWidth;
  linkWidthArrowWidthRatio = arrowExtraWidth / linkWidth;

  float linkWidthPx = linkWidth / transformationMatrix[0][0];

  
  vec3 rgbColor = color.rgb;
  float opacity = color.a * max(linkVisibilityMinTransparency, map(linkDistPx, linkVisibilityDistanceRange.g, linkVisibilityDistanceRange.r, 0.0, 1.0));

  if (greyoutStatusA.r > 0.0 || greyoutStatusB.r > 0.0) {
    opacity *= greyoutOpacity;
  }

  rgbaColor = vec4(rgbColor, opacity);

  float t = position.x;
  float w = curvedWeight;
  float tPrev = t - 1.0 / curvedLinkSegments;
  float tNext = t + 1.0 / curvedLinkSegments;
  vec2 pointCurr = conicParametricCurve(a, b, controlPoint, t, w);
  vec2 pointPrev = conicParametricCurve(a, b, controlPoint, max(0.0, tPrev), w);
  vec2 pointNext = conicParametricCurve(a, b, controlPoint, min(tNext, 1.0), w);
  vec2 xBasisCurved = pointNext - pointPrev;
  vec2 yBasisCurved = normalize(vec2(-xBasisCurved.y, xBasisCurved.x));
  pointCurr += yBasisCurved * linkWidthPx * position.y;
  vec2 p = 2.0 * pointCurr / spaceSize - 1.0;
  p *= spaceSize / screenSize;
  vec3 final =  transformationMatrix * vec3(p, 1);
  gl_Position = vec4(final.rg, 0, 1);
}`;
function Li(e3, t) {
  return e3 == null || t == null ? NaN : e3 < t ? -1 : e3 > t ? 1 : e3 >= t ? 0 : NaN;
}
function Ov(e3, t) {
  return e3 == null || t == null ? NaN : t < e3 ? -1 : t > e3 ? 1 : t >= e3 ? 0 : NaN;
}
function $u(e3) {
  let t, n, r;
  e3.length !== 2 ? (t = Li, n = (s, u) => Li(e3(s), u), r = (s, u) => e3(s) - u) : (t = e3 === Li || e3 === Ov ? e3 : Nv, n = e3, r = e3);
  function i(s, u, l = 0, v = s.length) {
    if (l < v) {
      if (t(u, u) !== 0) return v;
      do {
        const b = l + v >>> 1;
        n(s[b], u) < 0 ? l = b + 1 : v = b;
      } while (l < v);
    }
    return l;
  }
  function o(s, u, l = 0, v = s.length) {
    if (l < v) {
      if (t(u, u) !== 0) return v;
      do {
        const b = l + v >>> 1;
        n(s[b], u) <= 0 ? l = b + 1 : v = b;
      } while (l < v);
    }
    return l;
  }
  function f(s, u, l = 0, v = s.length) {
    const b = i(s, u, l, v - 1);
    return b > l && r(s[b - 1], u) > -r(s[b], u) ? b - 1 : b;
  }
  return { left: i, center: f, right: o };
}
function Nv() {
  return 0;
}
function Gv(e3) {
  return e3 === null ? NaN : +e3;
}
var Bv = $u(Li);
var Vv = Bv.right;
$u(Gv).center;
function Jf(e3, t) {
  let n, r;
  for (const i of e3)
    i != null && (n === void 0 ? i >= i && (n = r = i) : (n > i && (n = i), r < i && (r = i)));
  return [n, r];
}
var ra = Math.sqrt(50);
var ia = Math.sqrt(10);
var oa = Math.sqrt(2);
function $v(e3, t, n) {
  var r, i = -1, o, f, s;
  if (t = +t, e3 = +e3, n = +n, e3 === t && n > 0) return [e3];
  if ((r = t < e3) && (o = e3, e3 = t, t = o), (s = ju(e3, t, n)) === 0 || !isFinite(s)) return [];
  if (s > 0) {
    let u = Math.round(e3 / s), l = Math.round(t / s);
    for (u * s < e3 && ++u, l * s > t && --l, f = new Array(o = l - u + 1); ++i < o; ) f[i] = (u + i) * s;
  } else {
    s = -s;
    let u = Math.round(e3 * s), l = Math.round(t * s);
    for (u / s < e3 && ++u, l / s > t && --l, f = new Array(o = l - u + 1); ++i < o; ) f[i] = (u + i) / s;
  }
  return r && f.reverse(), f;
}
function ju(e3, t, n) {
  var r = (t - e3) / Math.max(0, n), i = Math.floor(Math.log(r) / Math.LN10), o = r / Math.pow(10, i);
  return i >= 0 ? (o >= ra ? 10 : o >= ia ? 5 : o >= oa ? 2 : 1) * Math.pow(10, i) : -Math.pow(10, -i) / (o >= ra ? 10 : o >= ia ? 5 : o >= oa ? 2 : 1);
}
function jv(e3, t, n) {
  var r = Math.abs(t - e3) / Math.max(0, n), i = Math.pow(10, Math.floor(Math.log(r) / Math.LN10)), o = r / i;
  return o >= ra ? i *= 10 : o >= ia ? i *= 5 : o >= oa && (i *= 2), t < e3 ? -i : i;
}
function Uv(e3, t, n) {
  e3 = +e3, t = +t, n = (i = arguments.length) < 2 ? (t = e3, e3 = 0, 1) : i < 3 ? 1 : +n;
  for (var r = -1, i = Math.max(0, Math.ceil((t - e3) / n)) | 0, o = new Array(i); ++r < i; )
    o[r] = e3 + r * n;
  return o;
}
function Uu(e3, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e3);
      break;
    default:
      this.range(t).domain(e3);
      break;
  }
  return this;
}
function Xv(e3) {
  return function() {
    return e3;
  };
}
function Hv(e3) {
  return +e3;
}
var eu = [0, 1];
function tn(e3) {
  return e3;
}
function aa(e3, t) {
  return (t -= e3 = +e3) ? function(n) {
    return (n - e3) / t;
  } : Xv(isNaN(t) ? NaN : 0.5);
}
function Wv(e3, t) {
  var n;
  return e3 > t && (n = e3, e3 = t, t = n), function(r) {
    return Math.max(e3, Math.min(t, r));
  };
}
function qv(e3, t, n) {
  var r = e3[0], i = e3[1], o = t[0], f = t[1];
  return i < r ? (r = aa(i, r), o = n(f, o)) : (r = aa(r, i), o = n(o, f)), function(s) {
    return o(r(s));
  };
}
function Yv(e3, t, n) {
  var r = Math.min(e3.length, t.length) - 1, i = new Array(r), o = new Array(r), f = -1;
  for (e3[r] < e3[0] && (e3 = e3.slice().reverse(), t = t.slice().reverse()); ++f < r; )
    i[f] = aa(e3[f], e3[f + 1]), o[f] = n(t[f], t[f + 1]);
  return function(s) {
    var u = Vv(e3, s, 1, r) - 1;
    return o[u](i[u](s));
  };
}
function Xu(e3, t) {
  return t.domain(e3.domain()).range(e3.range()).interpolate(e3.interpolate()).clamp(e3.clamp()).unknown(e3.unknown());
}
function Hu() {
  var e3 = eu, t = eu, n = xa, r, i, o, f = tn, s, u, l;
  function v() {
    var S = Math.min(e3.length, t.length);
    return f !== tn && (f = Wv(e3[0], e3[S - 1])), s = S > 2 ? Yv : qv, u = l = null, b;
  }
  function b(S) {
    return S == null || isNaN(S = +S) ? o : (u || (u = s(e3.map(r), t, n)))(r(f(S)));
  }
  return b.invert = function(S) {
    return f(i((l || (l = s(t, e3.map(r), Ht)))(S)));
  }, b.domain = function(S) {
    return arguments.length ? (e3 = Array.from(S, Hv), v()) : e3.slice();
  }, b.range = function(S) {
    return arguments.length ? (t = Array.from(S), v()) : t.slice();
  }, b.rangeRound = function(S) {
    return t = Array.from(S), n = Rp, v();
  }, b.clamp = function(S) {
    return arguments.length ? (f = S ? true : tn, v()) : f !== tn;
  }, b.interpolate = function(S) {
    return arguments.length ? (n = S, v()) : n;
  }, b.unknown = function(S) {
    return arguments.length ? (o = S, b) : o;
  }, function(S, M) {
    return r = S, i = M, v();
  };
}
function Zv() {
  return Hu()(tn, tn);
}
function Qv(e3) {
  return Math.abs(e3 = Math.round(e3)) >= 1e21 ? e3.toLocaleString("en").replace(/,/g, "") : e3.toString(10);
}
function Gi(e3, t) {
  if ((n = (e3 = t ? e3.toExponential(t - 1) : e3.toExponential()).indexOf("e")) < 0) return null;
  var n, r = e3.slice(0, n);
  return [
    r.length > 1 ? r[0] + r.slice(2) : r,
    +e3.slice(n + 1)
  ];
}
function cr(e3) {
  return e3 = Gi(Math.abs(e3)), e3 ? e3[1] : NaN;
}
function Kv(e3, t) {
  return function(n, r) {
    for (var i = n.length, o = [], f = 0, s = e3[0], u = 0; i > 0 && s > 0 && (u + s + 1 > r && (s = Math.max(1, r - u)), o.push(n.substring(i -= s, i + s)), !((u += s + 1) > r)); )
      s = e3[f = (f + 1) % e3.length];
    return o.reverse().join(t);
  };
}
function Jv(e3) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e3[+n];
    });
  };
}
var eg = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Bi(e3) {
  if (!(t = eg.exec(e3))) throw new Error("invalid format: " + e3);
  var t;
  return new _a({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
Bi.prototype = _a.prototype;
function _a(e3) {
  this.fill = e3.fill === void 0 ? " " : e3.fill + "", this.align = e3.align === void 0 ? ">" : e3.align + "", this.sign = e3.sign === void 0 ? "-" : e3.sign + "", this.symbol = e3.symbol === void 0 ? "" : e3.symbol + "", this.zero = !!e3.zero, this.width = e3.width === void 0 ? void 0 : +e3.width, this.comma = !!e3.comma, this.precision = e3.precision === void 0 ? void 0 : +e3.precision, this.trim = !!e3.trim, this.type = e3.type === void 0 ? "" : e3.type + "";
}
_a.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function tg(e3) {
  e: for (var t = e3.length, n = 1, r = -1, i; n < t; ++n)
    switch (e3[n]) {
      case ".":
        r = i = n;
        break;
      case "0":
        r === 0 && (r = n), i = n;
        break;
      default:
        if (!+e3[n]) break e;
        r > 0 && (r = 0);
        break;
    }
  return r > 0 ? e3.slice(0, r) + e3.slice(i + 1) : e3;
}
var Wu;
function ng(e3, t) {
  var n = Gi(e3, t);
  if (!n) return e3 + "";
  var r = n[0], i = n[1], o = i - (Wu = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, f = r.length;
  return o === f ? r : o > f ? r + new Array(o - f + 1).join("0") : o > 0 ? r.slice(0, o) + "." + r.slice(o) : "0." + new Array(1 - o).join("0") + Gi(e3, Math.max(0, t + o - 1))[0];
}
function tu(e3, t) {
  var n = Gi(e3, t);
  if (!n) return e3 + "";
  var r = n[0], i = n[1];
  return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0");
}
var nu = {
  "%": (e3, t) => (e3 * 100).toFixed(t),
  b: (e3) => Math.round(e3).toString(2),
  c: (e3) => e3 + "",
  d: Qv,
  e: (e3, t) => e3.toExponential(t),
  f: (e3, t) => e3.toFixed(t),
  g: (e3, t) => e3.toPrecision(t),
  o: (e3) => Math.round(e3).toString(8),
  p: (e3, t) => tu(e3 * 100, t),
  r: tu,
  s: ng,
  X: (e3) => Math.round(e3).toString(16).toUpperCase(),
  x: (e3) => Math.round(e3).toString(16)
};
function ru(e3) {
  return e3;
}
var iu = Array.prototype.map;
var ou = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function rg(e3) {
  var t = e3.grouping === void 0 || e3.thousands === void 0 ? ru : Kv(iu.call(e3.grouping, Number), e3.thousands + ""), n = e3.currency === void 0 ? "" : e3.currency[0] + "", r = e3.currency === void 0 ? "" : e3.currency[1] + "", i = e3.decimal === void 0 ? "." : e3.decimal + "", o = e3.numerals === void 0 ? ru : Jv(iu.call(e3.numerals, String)), f = e3.percent === void 0 ? "%" : e3.percent + "", s = e3.minus === void 0 ? "−" : e3.minus + "", u = e3.nan === void 0 ? "NaN" : e3.nan + "";
  function l(b) {
    b = Bi(b);
    var S = b.fill, M = b.align, K = b.sign, we = b.symbol, ke = b.zero, ae = b.width, Ne = b.comma, je = b.precision, q = b.trim, pe = b.type;
    pe === "n" ? (Ne = true, pe = "g") : nu[pe] || (je === void 0 && (je = 12), q = true, pe = "g"), (ke || S === "0" && M === "=") && (ke = true, S = "0", M = "=");
    var De = we === "$" ? n : we === "#" && /[boxX]/.test(pe) ? "0" + pe.toLowerCase() : "", Ge = we === "$" ? r : /[%p]/.test(pe) ? f : "", qe = nu[pe], et = /[defgprs%]/.test(pe);
    je = je === void 0 ? 6 : /[gprs]/.test(pe) ? Math.max(1, Math.min(21, je)) : Math.max(0, Math.min(20, je));
    function rt(ze) {
      var st = De, tt = Ge, N, Te, oe;
      if (pe === "c")
        tt = qe(ze) + tt, ze = "";
      else {
        ze = +ze;
        var Pe = ze < 0 || 1 / ze < 0;
        if (ze = isNaN(ze) ? u : qe(Math.abs(ze), je), q && (ze = tg(ze)), Pe && +ze == 0 && K !== "+" && (Pe = false), st = (Pe ? K === "(" ? K : s : K === "-" || K === "(" ? "" : K) + st, tt = (pe === "s" ? ou[8 + Wu / 3] : "") + tt + (Pe && K === "(" ? ")" : ""), et) {
          for (N = -1, Te = ze.length; ++N < Te; )
            if (oe = ze.charCodeAt(N), 48 > oe || oe > 57) {
              tt = (oe === 46 ? i + ze.slice(N + 1) : ze.slice(N)) + tt, ze = ze.slice(0, N);
              break;
            }
        }
      }
      Ne && !ke && (ze = t(ze, 1 / 0));
      var $e = st.length + ze.length + tt.length, Be = $e < ae ? new Array(ae - $e + 1).join(S) : "";
      switch (Ne && ke && (ze = t(Be + ze, Be.length ? ae - tt.length : 1 / 0), Be = ""), M) {
        case "<":
          ze = st + ze + tt + Be;
          break;
        case "=":
          ze = st + Be + ze + tt;
          break;
        case "^":
          ze = Be.slice(0, $e = Be.length >> 1) + st + ze + tt + Be.slice($e);
          break;
        default:
          ze = Be + st + ze + tt;
          break;
      }
      return o(ze);
    }
    return rt.toString = function() {
      return b + "";
    }, rt;
  }
  function v(b, S) {
    var M = l((b = Bi(b), b.type = "f", b)), K = Math.max(-8, Math.min(8, Math.floor(cr(S) / 3))) * 3, we = Math.pow(10, -K), ke = ou[8 + K / 3];
    return function(ae) {
      return M(we * ae) + ke;
    };
  }
  return {
    format: l,
    formatPrefix: v
  };
}
var Ti;
var qu;
var Yu;
ig({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function ig(e3) {
  return Ti = rg(e3), qu = Ti.format, Yu = Ti.formatPrefix, Ti;
}
function og(e3) {
  return Math.max(0, -cr(Math.abs(e3)));
}
function ag(e3, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(cr(t) / 3))) * 3 - cr(Math.abs(e3)));
}
function sg(e3, t) {
  return e3 = Math.abs(e3), t = Math.abs(t) - e3, Math.max(0, cr(t) - cr(e3)) + 1;
}
function fg(e3, t, n, r) {
  var i = jv(e3, t, n), o;
  switch (r = Bi(r ?? ",f"), r.type) {
    case "s": {
      var f = Math.max(Math.abs(e3), Math.abs(t));
      return r.precision == null && !isNaN(o = ag(i, f)) && (r.precision = o), Yu(r, f);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      r.precision == null && !isNaN(o = sg(i, Math.max(Math.abs(e3), Math.abs(t)))) && (r.precision = o - (r.type === "e"));
      break;
    }
    case "f":
    case "%": {
      r.precision == null && !isNaN(o = og(i)) && (r.precision = o - (r.type === "%") * 2);
      break;
    }
  }
  return qu(r);
}
function Zu(e3) {
  var t = e3.domain;
  return e3.ticks = function(n) {
    var r = t();
    return $v(r[0], r[r.length - 1], n ?? 10);
  }, e3.tickFormat = function(n, r) {
    var i = t();
    return fg(i[0], i[i.length - 1], n ?? 10, r);
  }, e3.nice = function(n) {
    n == null && (n = 10);
    var r = t(), i = 0, o = r.length - 1, f = r[i], s = r[o], u, l, v = 10;
    for (s < f && (l = f, f = s, s = l, l = i, i = o, o = l); v-- > 0; ) {
      if (l = ju(f, s, n), l === u)
        return r[i] = f, r[o] = s, t(r);
      if (l > 0)
        f = Math.floor(f / l) * l, s = Math.ceil(s / l) * l;
      else if (l < 0)
        f = Math.ceil(f * l) / l, s = Math.floor(s * l) / l;
      else
        break;
      u = l;
    }
    return e3;
  }, e3;
}
function sa() {
  var e3 = Zv();
  return e3.copy = function() {
    return Xu(e3, sa());
  }, Uu.apply(e3, arguments), Zu(e3);
}
function au(e3) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e3) : Math.pow(t, e3);
  };
}
function ug(e3) {
  return e3 < 0 ? -Math.sqrt(-e3) : Math.sqrt(e3);
}
function cg(e3) {
  return e3 < 0 ? -e3 * e3 : e3 * e3;
}
function lg(e3) {
  var t = e3(tn, tn), n = 1;
  function r() {
    return n === 1 ? e3(tn, tn) : n === 0.5 ? e3(ug, cg) : e3(au(n), au(1 / n));
  }
  return t.exponent = function(i) {
    return arguments.length ? (n = +i, r()) : n;
  }, Zu(t);
}
function Qu() {
  var e3 = lg(Hu());
  return e3.copy = function() {
    return Xu(e3, Qu()).exponent(e3.exponent());
  }, Uu.apply(e3, arguments), e3;
}
var hg = (e3) => {
  const t = Qu().exponent(2).range([0, 1]).domain([-1, 1]), n = Uv(0, e3).map((i) => -0.5 + i / e3);
  n.push(0.5);
  const r = new Array(n.length * 2);
  return n.forEach((i, o) => {
    r[o * 2] = [t(i * 2), 0.5], r[o * 2 + 1] = [t(i * 2), -0.5];
  }), r;
};
var dg = class extends dn {
  initPrograms() {
    const { reglInstance: t, config: n, store: r } = this;
    this.drawCurveCommand || (this.drawCurveCommand = t({
      vert: Mv,
      frag: Dv,
      attributes: {
        position: {
          buffer: () => this.curveLineBuffer,
          divisor: 0
        },
        pointA: {
          buffer: () => this.pointsBuffer,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 0,
          stride: Float32Array.BYTES_PER_ELEMENT * 4
        },
        pointB: {
          buffer: () => this.pointsBuffer,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 2,
          stride: Float32Array.BYTES_PER_ELEMENT * 4
        },
        color: {
          buffer: () => this.colorBuffer,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 0,
          stride: Float32Array.BYTES_PER_ELEMENT * 4
        },
        width: {
          buffer: () => this.widthBuffer,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 0,
          stride: Float32Array.BYTES_PER_ELEMENT * 1
        },
        arrow: {
          buffer: () => this.arrowBuffer,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 0,
          stride: Float32Array.BYTES_PER_ELEMENT * 1
        }
      },
      uniforms: {
        positionsTexture: () => {
          var i;
          return (i = this.points) == null ? void 0 : i.currentPositionFbo;
        },
        pointGreyoutStatus: () => {
          var i;
          return (i = this.points) == null ? void 0 : i.greyoutStatusFbo;
        },
        transformationMatrix: () => r.transform,
        pointsTextureSize: () => r.pointsTextureSize,
        pointSizeScale: () => n.pointSizeScale,
        widthScale: () => n.linkWidthScale,
        arrowSizeScale: () => n.linkArrowsSizeScale,
        spaceSize: () => r.adjustedSpaceSize,
        screenSize: () => r.screenSize,
        ratio: () => n.pixelRatio,
        linkVisibilityDistanceRange: () => n.linkVisibilityDistanceRange,
        linkVisibilityMinTransparency: () => n.linkVisibilityMinTransparency,
        greyoutOpacity: () => n.linkGreyoutOpacity,
        scalePointsOnZoom: () => n.scalePointsOnZoom,
        curvedWeight: () => n.curvedLinkWeight,
        curvedLinkControlPointDistance: () => n.curvedLinkControlPointDistance,
        curvedLinkSegments: () => n.curvedLinks ? n.curvedLinkSegments ?? We.curvedLinkSegments : 1
      },
      cull: {
        enable: true,
        face: "back"
      },
      blend: {
        enable: true,
        func: {
          dstRGB: "one minus src alpha",
          srcRGB: "src alpha",
          dstAlpha: "one minus src alpha",
          srcAlpha: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: {
        enable: false,
        mask: false
      },
      count: () => {
        var i;
        return ((i = this.curveLineGeometry) == null ? void 0 : i.length) ?? 0;
      },
      instances: () => this.data.linksNumber ?? 0,
      primitive: "triangle strip"
    }));
  }
  draw() {
    var t;
    !this.pointsBuffer || !this.curveLineBuffer || (this.colorBuffer || this.updateColor(), this.widthBuffer || this.updateWidth(), this.arrowBuffer || this.updateArrow(), (t = this.drawCurveCommand) == null || t.call(this));
  }
  updatePointsBuffer() {
    const { reglInstance: t, data: n, store: r } = this;
    if (n.linksNumber === void 0 || n.links === void 0) return;
    const i = [];
    for (let o = 0; o < n.linksNumber; o++) {
      const f = n.links[o * 2], s = n.links[o * 2 + 1], u = f % r.pointsTextureSize, l = Math.floor(f / r.pointsTextureSize), v = s % r.pointsTextureSize, b = Math.floor(s / r.pointsTextureSize);
      i[o * 2] = [u, l], i[o * 2 + 1] = [v, b];
    }
    this.pointsBuffer || (this.pointsBuffer = t.buffer(0)), this.pointsBuffer(i);
  }
  updateColor() {
    const { reglInstance: t, data: n } = this;
    this.colorBuffer || (this.colorBuffer = t.buffer(0)), this.colorBuffer(n.linkColors ?? new Float32Array());
  }
  updateWidth() {
    const { reglInstance: t, data: n } = this;
    this.widthBuffer || (this.widthBuffer = t.buffer(0)), this.widthBuffer(n.linkWidths ?? new Float32Array());
  }
  updateArrow() {
    const { reglInstance: t, data: n } = this;
    this.arrowBuffer || (this.arrowBuffer = t.buffer(0)), this.arrowBuffer(n.linkArrows ?? new Float32Array());
  }
  updateCurveLineGeometry() {
    const { reglInstance: t, config: { curvedLinks: n, curvedLinkSegments: r } } = this;
    this.curveLineGeometry = hg(n ? r ?? We.curvedLinkSegments : 1), this.curveLineBuffer || (this.curveLineBuffer = t.buffer(0)), this.curveLineBuffer(this.curveLineGeometry);
  }
};
var mg = `#ifdef GL_ES
precision highp float;
#endif

varying vec3 rgbColor;
varying float alpha;

const float smoothing = 0.9;

void main() {
    
    if (alpha == 0.0) { discard; }

    
    vec2 pointCoord = 2.0 * gl_PointCoord - 1.0;
    
    float pointCenterDistance = dot(pointCoord, pointCoord);
    
    float opacity = alpha * (1.0 - smoothstep(smoothing, 1.0, pointCenterDistance));

    gl_FragColor = vec4(rgbColor, opacity);
}`;
var pg = `#ifdef GL_ES
precision highp float;
#endif

attribute vec2 pointIndices;
attribute float size;
attribute vec4 color;

uniform sampler2D positionsTexture;
uniform sampler2D pointGreyoutStatus;
uniform float ratio;
uniform mat3 transformationMatrix;
uniform float pointsTextureSize;
uniform float sizeScale;
uniform float spaceSize;
uniform vec2 screenSize;
uniform float greyoutOpacity;
uniform bool scalePointsOnZoom;
uniform float maxPointSize;

varying vec2 textureCoords;
varying vec3 rgbColor;
varying float alpha;

float calculatePointSize(float size) {
  float pSize;
  if (scalePointsOnZoom) { 
    pSize = size * ratio * transformationMatrix[0][0];
  } else {
    pSize = size * ratio * min(5.0, max(1.0, transformationMatrix[0][0] * 0.01));
  }

  return min(pSize, maxPointSize * ratio);
}

void main() {  
  textureCoords = pointIndices;
  
  vec4 pointPosition = texture2D(positionsTexture, (textureCoords + 0.5) / pointsTextureSize);
  vec2 point = pointPosition.rg;

  
  vec2 normalizedPosition = 2.0 * point / spaceSize - 1.0;
  normalizedPosition *= spaceSize / screenSize;
  vec3 finalPosition = transformationMatrix * vec3(normalizedPosition, 1);
  gl_Position = vec4(finalPosition.rg, 0, 1);

  gl_PointSize = calculatePointSize(size * sizeScale);

  rgbColor = color.rgb;
  alpha = color.a;

  
  vec4 greyoutStatus = texture2D(pointGreyoutStatus, (textureCoords + 0.5) / pointsTextureSize);
  if (greyoutStatus.r > 0.0) {
    alpha *= greyoutOpacity;
  }
}`;
var vg = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D pointSize;
uniform float sizeScale;
uniform float spaceSize;
uniform vec2 screenSize;
uniform float ratio;
uniform mat3 transformationMatrix;
uniform vec2 selection[2];
uniform bool scalePointsOnZoom;
uniform float maxPointSize;

varying vec2 textureCoords;

float pointSizeF(float size) {
  float pSize;
  if (scalePointsOnZoom) { 
    pSize = size * ratio * transformationMatrix[0][0];
  } else {
    pSize = size * ratio * min(5.0, max(1.0, transformationMatrix[0][0] * 0.01));
  }
  return min(pSize, maxPointSize * ratio);
}

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec2 p = 2.0 * pointPosition.rg / spaceSize - 1.0;
  p *= spaceSize / screenSize;
  vec3 final = transformationMatrix * vec3(p, 1);

  vec4 pSize = texture2D(pointSize, textureCoords);
  float size = pSize.r * sizeScale;

  float left = 2.0 * (selection[0].x - 0.5 * pointSizeF(size)) / screenSize.x - 1.0;
  float right = 2.0 * (selection[1].x + 0.5 * pointSizeF(size)) / screenSize.x - 1.0;
  float top =  2.0 * (selection[0].y - 0.5 * pointSizeF(size)) / screenSize.y - 1.0;
  float bottom =  2.0 * (selection[1].y + 0.5 * pointSizeF(size)) / screenSize.y - 1.0;

  gl_FragColor = vec4(0.0, 0.0, pointPosition.rg);
  if (final.x >= left && final.x <= right && final.y >= top && final.y <= bottom) {
    gl_FragColor.r = 1.0;
  }
}`;
var gg = `precision mediump float;

uniform vec4 color;
uniform float width;

varying vec2 vertexPosition;
varying float pointOpacity;

const float smoothing = 1.05;

void main () {
  float r = dot(vertexPosition, vertexPosition);
  float opacity = smoothstep(r, r * smoothing, 1.0);
  float stroke = smoothstep(width, width * smoothing, r);
  gl_FragColor = vec4(color.rgb, opacity * stroke * color.a * pointOpacity);
}`;
var xg = `precision mediump float;

attribute vec2 vertexCoord;

uniform sampler2D positionsTexture;
uniform sampler2D pointGreyoutStatusTexture;
uniform float size;
uniform mat3 transformationMatrix;
uniform float pointsTextureSize;
uniform float sizeScale;
uniform float spaceSize;
uniform vec2 screenSize;
uniform bool scalePointsOnZoom;
uniform float pointIndex;
uniform float maxPointSize;
uniform vec4 color;
uniform float greyoutOpacity;

varying vec2 vertexPosition;
varying float pointOpacity;

float calculatePointSize(float size) {
  float pSize;
  if (scalePointsOnZoom) { 
    pSize = size * transformationMatrix[0][0];
  } else {
    pSize = size * min(5.0, max(1.0, transformationMatrix[0][0] * 0.01));
  }
  return min(pSize, maxPointSize);
}

const float relativeRingRadius = 1.3;

void main () {
  vertexPosition = vertexCoord;

  vec2 textureCoordinates = vec2(mod(pointIndex, pointsTextureSize), floor(pointIndex / pointsTextureSize)) + 0.5;
  vec4 pointPosition = texture2D(positionsTexture, textureCoordinates / pointsTextureSize);

  
  pointOpacity = color.a;
  vec4 greyoutStatus = texture2D(pointGreyoutStatusTexture, textureCoordinates / pointsTextureSize);
  if (greyoutStatus.r > 0.0) {
    pointOpacity *= greyoutOpacity;
  }

  
  float pointSize = (calculatePointSize(size * sizeScale) * relativeRingRadius) / transformationMatrix[0][0];
  float radius = pointSize * 0.5;

  
  vec2 a = pointPosition.xy;
  vec2 b = pointPosition.xy + vec2(0.0, radius);
  vec2 xBasis = b - a;
  vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));
  vec2 pointPositionInScreenSpace = a + xBasis * vertexCoord.x + yBasis * radius * vertexCoord.y;

  
  vec2 p = 2.0 * pointPositionInScreenSpace / spaceSize - 1.0;
  p *= spaceSize / screenSize;
  vec3 final =  transformationMatrix * vec3(p, 1);
  
  gl_Position = vec4(final.rg, 0, 1);
}`;
var yg = `#ifdef GL_ES
precision highp float;
#endif

varying vec4 rgba;

void main() {
  gl_FragColor = rgba;
}`;
var bg = `#ifdef GL_ES
precision highp float;
#endif

attribute float size;

uniform sampler2D positionsTexture;
uniform float pointsTextureSize;
uniform float sizeScale;
uniform float spaceSize;
uniform vec2 screenSize;
uniform float ratio;
uniform mat3 transformationMatrix;
uniform vec2 mousePosition;
uniform bool scalePointsOnZoom;
uniform float maxPointSize;

attribute vec2 pointIndices;

varying vec4 rgba;

float calculatePointSize(float size) {
  float pSize;
  if (scalePointsOnZoom) { 
    pSize = size * ratio * transformationMatrix[0][0];
  } else {
    pSize = size * ratio * min(5.0, max(1.0, transformationMatrix[0][0] * 0.01));
  }
  return min(pSize, maxPointSize * ratio);
}

float euclideanDistance (float x1, float x2, float y1, float y2) {
  return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
}

void main() {
  vec4 pointPosition = texture2D(positionsTexture, (pointIndices + 0.5) / pointsTextureSize);

  
  vec2 normalizedPoint = 2.0 * pointPosition.rg / spaceSize - 1.0;
  normalizedPoint *= spaceSize / screenSize;
  vec3 finalPosition = transformationMatrix * vec3(normalizedPoint, 1);

  float pointRadius = 0.5 * calculatePointSize(size * sizeScale);

  vec2 pointScreenPosition = (finalPosition.xy + 1.0) * screenSize / 2.0;
  rgba = vec4(0.0);
  gl_Position = vec4(0.5, 0.5, 0.0, 1.0);
  
  if (euclideanDistance(pointScreenPosition.x, mousePosition.x, pointScreenPosition.y, mousePosition.y) < pointRadius / ratio) {
    float index = pointIndices.g * pointsTextureSize + pointIndices.r;
    rgba = vec4(index, size, pointPosition.xy);
    gl_Position = vec4(-0.5, -0.5, 0.0, 1.0);
  }

  gl_PointSize = 1.0;
}`;
var _g = `#ifdef GL_ES
precision highp float;
#endif

varying vec4 rgba;

void main() {
  gl_FragColor = rgba;
}`;
var Sg = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform float pointsTextureSize;
uniform float spaceSize;
uniform vec2 screenSize;
uniform mat3 transformationMatrix;

attribute vec2 pointIndices;

varying vec4 rgba;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, (pointIndices + 0.5) / pointsTextureSize);
  vec2 p = 2.0 * pointPosition.rg / spaceSize - 1.0;
  p *= spaceSize / screenSize;
  vec3 final = transformationMatrix * vec3(p, 1);

  vec2 pointScreenPosition = (final.xy + 1.0) * screenSize / 2.0;
  float index = pointIndices.g * pointsTextureSize + pointIndices.r;
  rgba = vec4(index, 1.0, pointPosition.xy);
  float i = (pointScreenPosition.x + 0.5) / screenSize.x;
  float j = (pointScreenPosition.y + 0.5) / screenSize.y;
  gl_Position = vec4(2.0 * vec2(i, j) - 1.0, 0.0, 1.0);

  gl_PointSize = 1.0;
}`;
var wg = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D velocity;
uniform float friction;
uniform float spaceSize;

varying vec2 textureCoords;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 pointVelocity = texture2D(velocity, textureCoords);

  
  pointVelocity.rg *= friction;

  pointPosition.rg += pointVelocity.rg;

  pointPosition.r = clamp(pointPosition.r, 0.0, spaceSize);
  pointPosition.g = clamp(pointPosition.g, 0.0, spaceSize);
  
  gl_FragColor = pointPosition;
}`;
var Tg = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D trackedIndices;
uniform float pointsTextureSize;

varying vec2 textureCoords;

void main() {
  vec4 trackedPointIndices = texture2D(trackedIndices, textureCoords);
  if (trackedPointIndices.r < 0.0) discard;
  vec4 pointPosition = texture2D(positionsTexture, (trackedPointIndices.rg + 0.5) / pointsTextureSize);

  gl_FragColor = vec4(pointPosition.rg, 1.0, 1.0);
}`;
var Ag = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform vec2 mousePos;
uniform float index;

varying vec2 textureCoords;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);

  
  if (index >= 0.0 && index == pointPosition.b) {
    pointPosition.rg = mousePos.rg;
  }

  gl_FragColor = pointPosition;
}`;
var Eg = class extends dn {
  updatePositions() {
    const { reglInstance: t, store: n, data: r } = this, { pointsTextureSize: i } = n;
    if (!i || !r.pointPositions || r.pointsNumber === void 0) return;
    const o = new Float32Array(i * i * 4);
    for (let f = 0; f < r.pointsNumber; ++f)
      o[f * 4 + 0] = r.pointPositions[f * 2 + 0], o[f * 4 + 1] = r.pointPositions[f * 2 + 1], o[f * 4 + 2] = f;
    wi(this.currentPositionFbo), this.currentPositionFbo = t.framebuffer({
      color: t.texture({
        data: o,
        shape: [i, i, 4],
        type: "float"
      }),
      depth: false,
      stencil: false
    }), wi(this.previousPositionFbo), this.previousPositionFbo = t.framebuffer({
      color: t.texture({
        data: o,
        shape: [i, i, 4],
        type: "float"
      }),
      depth: false,
      stencil: false
    }), this.config.disableSimulation || (wi(this.velocityFbo), this.velocityFbo = t.framebuffer({
      color: t.texture({
        data: new Float32Array(i * i * 4).fill(0),
        shape: [i, i, 4],
        type: "float"
      }),
      depth: false,
      stencil: false
    })), this.selectedTexture || (this.selectedTexture = t.texture()), this.selectedTexture({
      data: o,
      shape: [i, i, 4],
      type: "float"
    }), this.selectedFbo || (this.selectedFbo = t.framebuffer({
      color: this.selectedTexture,
      depth: false,
      stencil: false
    })), this.hoveredFbo || (this.hoveredFbo = t.framebuffer({
      shape: [2, 2],
      colorType: "float",
      depth: false,
      stencil: false
    })), this.drawPointIndices || (this.drawPointIndices = t.buffer(0)), this.drawPointIndices(Bn(n.pointsTextureSize)), this.hoveredPointIndices || (this.hoveredPointIndices = t.buffer(0)), this.hoveredPointIndices(Bn(n.pointsTextureSize)), this.sampledPointIndices || (this.sampledPointIndices = t.buffer(0)), this.sampledPointIndices(Bn(n.pointsTextureSize)), this.updateGreyoutStatus(), this.updateSampledPointsGrid();
  }
  initPrograms() {
    const { reglInstance: t, config: n, store: r, data: i } = this;
    n.disableSimulation || this.updatePositionCommand || (this.updatePositionCommand = t({
      frag: wg,
      vert: wt,
      framebuffer: () => this.currentPositionFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) },
      uniforms: {
        positionsTexture: () => this.previousPositionFbo,
        velocity: () => this.velocityFbo,
        friction: () => n.simulationFriction,
        spaceSize: () => r.adjustedSpaceSize
      }
    })), this.dragPointCommand || (this.dragPointCommand = t({
      frag: Ag,
      vert: wt,
      framebuffer: () => this.currentPositionFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) },
      uniforms: {
        positionsTexture: () => this.previousPositionFbo,
        mousePos: () => r.mousePosition,
        index: () => {
          var o;
          return ((o = r.hoveredPoint) == null ? void 0 : o.index) ?? -1;
        }
      }
    })), this.drawCommand || (this.drawCommand = t({
      frag: mg,
      vert: pg,
      primitive: "points",
      count: () => i.pointsNumber ?? 0,
      attributes: {
        pointIndices: {
          buffer: this.drawPointIndices,
          size: 2
        },
        size: {
          buffer: () => this.sizeBuffer,
          size: 1
        },
        color: {
          buffer: () => this.colorBuffer,
          size: 4
        }
      },
      uniforms: {
        positionsTexture: () => this.currentPositionFbo,
        pointGreyoutStatus: () => this.greyoutStatusFbo,
        ratio: () => n.pixelRatio,
        sizeScale: () => n.pointSizeScale,
        pointsTextureSize: () => r.pointsTextureSize,
        transformationMatrix: () => r.transform,
        spaceSize: () => r.adjustedSpaceSize,
        screenSize: () => r.screenSize,
        greyoutOpacity: () => n.pointGreyoutOpacity,
        scalePointsOnZoom: () => n.scalePointsOnZoom,
        maxPointSize: () => r.maxPointSize
      },
      blend: {
        enable: true,
        func: {
          dstRGB: "one minus src alpha",
          srcRGB: "src alpha",
          dstAlpha: "one minus src alpha",
          srcAlpha: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: {
        enable: false,
        mask: false
      }
    })), this.findPointsOnAreaSelectionCommand || (this.findPointsOnAreaSelectionCommand = t({
      frag: vg,
      vert: wt,
      framebuffer: () => this.selectedFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: {
        vertexCoord: yt(t)
      },
      uniforms: {
        positionsTexture: () => this.currentPositionFbo,
        pointSize: () => this.sizeFbo,
        spaceSize: () => r.adjustedSpaceSize,
        screenSize: () => r.screenSize,
        sizeScale: () => n.pointSizeScale,
        transformationMatrix: () => r.transform,
        ratio: () => n.pixelRatio,
        "selection[0]": () => r.selectedArea[0],
        "selection[1]": () => r.selectedArea[1],
        scalePointsOnZoom: () => n.scalePointsOnZoom,
        maxPointSize: () => r.maxPointSize
      }
    })), this.clearHoveredFboCommand || (this.clearHoveredFboCommand = t({
      frag: $n,
      vert: wt,
      framebuffer: this.hoveredFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) }
    })), this.findHoveredPointCommand || (this.findHoveredPointCommand = t({
      frag: yg,
      vert: bg,
      primitive: "points",
      count: () => i.pointsNumber ?? 0,
      framebuffer: () => this.hoveredFbo,
      attributes: {
        pointIndices: {
          buffer: this.hoveredPointIndices,
          size: 2
        },
        size: {
          buffer: () => this.sizeBuffer,
          size: 1
        }
      },
      uniforms: {
        positionsTexture: () => this.currentPositionFbo,
        ratio: () => n.pixelRatio,
        sizeScale: () => n.pointSizeScale,
        pointsTextureSize: () => r.pointsTextureSize,
        transformationMatrix: () => r.transform,
        spaceSize: () => r.adjustedSpaceSize,
        screenSize: () => r.screenSize,
        scalePointsOnZoom: () => n.scalePointsOnZoom,
        mousePosition: () => r.screenMousePosition,
        maxPointSize: () => r.maxPointSize
      },
      depth: {
        enable: false,
        mask: false
      }
    })), this.clearSampledPointsFboCommand || (this.clearSampledPointsFboCommand = t({
      frag: $n,
      vert: wt,
      framebuffer: () => this.sampledPointsFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) }
    })), this.fillSampledPointsFboCommand || (this.fillSampledPointsFboCommand = t({
      frag: _g,
      vert: Sg,
      primitive: "points",
      count: () => i.pointsNumber ?? 0,
      framebuffer: () => this.sampledPointsFbo,
      attributes: {
        pointIndices: {
          buffer: this.sampledPointIndices,
          size: 2
        }
      },
      uniforms: {
        positionsTexture: () => this.currentPositionFbo,
        pointsTextureSize: () => r.pointsTextureSize,
        transformationMatrix: () => r.transform,
        spaceSize: () => r.adjustedSpaceSize,
        screenSize: () => r.screenSize
      },
      depth: {
        enable: false,
        mask: false
      }
    })), this.drawHighlightedCommand || (this.drawHighlightedCommand = t({
      frag: gg,
      vert: xg,
      attributes: { vertexCoord: yt(t) },
      primitive: "triangle strip",
      count: 4,
      uniforms: {
        color: t.prop("color"),
        width: t.prop("width"),
        pointIndex: t.prop("pointIndex"),
        size: t.prop("size"),
        positionsTexture: () => this.currentPositionFbo,
        sizeScale: () => n.pointSizeScale,
        pointsTextureSize: () => r.pointsTextureSize,
        transformationMatrix: () => r.transform,
        spaceSize: () => r.adjustedSpaceSize,
        screenSize: () => r.screenSize,
        scalePointsOnZoom: () => n.scalePointsOnZoom,
        maxPointSize: () => r.maxPointSize,
        pointGreyoutStatusTexture: () => this.greyoutStatusFbo,
        greyoutOpacity: () => n.pointGreyoutOpacity
      },
      blend: {
        enable: true,
        func: {
          dstRGB: "one minus src alpha",
          srcRGB: "src alpha",
          dstAlpha: "one minus src alpha",
          srcAlpha: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: {
        enable: false,
        mask: false
      }
    })), this.trackPointsCommand || (this.trackPointsCommand = t({
      frag: Tg,
      vert: wt,
      framebuffer: () => this.trackedPositionsFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: yt(t) },
      uniforms: {
        positionsTexture: () => this.currentPositionFbo,
        trackedIndices: () => this.trackedIndicesFbo,
        pointsTextureSize: () => r.pointsTextureSize
      }
    }));
  }
  updateColor() {
    const { reglInstance: t, store: { pointsTextureSize: n }, data: r } = this;
    n && (this.colorBuffer || (this.colorBuffer = t.buffer(0)), this.colorBuffer(r.pointColors));
  }
  updateGreyoutStatus() {
    const { reglInstance: t, store: { selectedIndices: n, pointsTextureSize: r } } = this;
    if (!r) return;
    const i = new Float32Array(r * r * 4).fill(n ? 1 : 0);
    if (n)
      for (const o of n)
        i[o * 4] = 0;
    this.greyoutStatusTexture || (this.greyoutStatusTexture = t.texture()), this.greyoutStatusTexture({
      data: i,
      width: r,
      height: r,
      type: "float"
    }), this.greyoutStatusFbo || (this.greyoutStatusFbo = t.framebuffer({
      color: this.greyoutStatusTexture,
      depth: false,
      stencil: false
    }));
  }
  updateSize() {
    const { reglInstance: t, store: { pointsTextureSize: n }, data: r } = this;
    if (!n || r.pointsNumber === void 0 || r.pointSizes === void 0) return;
    this.sizeBuffer || (this.sizeBuffer = t.buffer(0)), this.sizeBuffer(r.pointSizes);
    const i = new Float32Array(n * n * 4);
    for (let o = 0; o < r.pointsNumber; o++)
      i[o * 4] = r.pointSizes[o];
    this.sizeTexture || (this.sizeTexture = t.texture()), this.sizeTexture({
      data: i,
      width: n,
      height: n,
      type: "float"
    }), this.sizeFbo || (this.sizeFbo = t.framebuffer({
      color: this.sizeTexture,
      depth: false,
      stencil: false
    }));
  }
  updateSampledPointsGrid() {
    const { store: { screenSize: t }, config: { pointSamplingDistance: n }, reglInstance: r } = this, i = n ?? Math.min(...t) / 2, o = Math.ceil(t[0] / i), f = Math.ceil(t[1] / i);
    wi(this.sampledPointsFbo), this.sampledPointsFbo = r.framebuffer({
      shape: [o, f],
      depth: false,
      stencil: false,
      colorType: "float"
    });
  }
  trackPoints() {
    var t, n;
    (t = this.trackedIndices) != null && t.length && ((n = this.trackPointsCommand) == null || n.call(this));
  }
  draw() {
    var o, f, s, u, l;
    const { config: { renderHoveredPointRing: t, pointSize: n }, store: r, data: i } = this;
    this.colorBuffer || this.updateColor(), this.sizeBuffer || this.updateSize(), (o = this.drawCommand) == null || o.call(this), t && r.hoveredPoint && ((s = this.drawHighlightedCommand) == null || s.call(this, {
      width: 0.85,
      color: r.hoveredPointRingColor,
      pointIndex: r.hoveredPoint.index,
      size: ((f = i.pointSizes) == null ? void 0 : f[r.hoveredPoint.index]) ?? n
    })), r.focusedPoint && ((l = this.drawHighlightedCommand) == null || l.call(this, {
      width: 0.75,
      color: r.focusedPointRingColor,
      pointIndex: r.focusedPoint.index,
      size: ((u = i.pointSizes) == null ? void 0 : u[r.focusedPoint.index]) ?? n
    }));
  }
  updatePosition() {
    var t;
    (t = this.updatePositionCommand) == null || t.call(this), this.swapFbo();
  }
  drag() {
    var t;
    (t = this.dragPointCommand) == null || t.call(this), this.swapFbo();
  }
  findPointsOnAreaSelection() {
    var t;
    (t = this.findPointsOnAreaSelectionCommand) == null || t.call(this);
  }
  findHoveredPoint() {
    var t, n;
    (t = this.clearHoveredFboCommand) == null || t.call(this), (n = this.findHoveredPointCommand) == null || n.call(this);
  }
  trackPointsByIndices(t) {
    const { store: { pointsTextureSize: n }, reglInstance: r } = this;
    if (this.trackedIndices = t, !(t != null && t.length)) return;
    const i = Math.ceil(Math.sqrt(t.length)), o = new Float32Array(i * i * 4).fill(-1);
    for (const [f, s] of t.entries())
      s !== void 0 && (o[f * 4] = s % n, o[f * 4 + 1] = Math.floor(s / n), o[f * 4 + 2] = 0, o[f * 4 + 3] = 0);
    this.trackedIndicesTexture || (this.trackedIndicesTexture = r.texture()), this.trackedIndicesTexture({
      data: o,
      width: i,
      height: i,
      type: "float"
    }), this.trackedIndicesFbo || (this.trackedIndicesFbo = r.framebuffer({
      color: this.trackedIndicesTexture,
      depth: false,
      stencil: false
    })), this.trackedPositionsFbo || (this.trackedPositionsFbo = r.framebuffer()), this.trackedPositionsFbo({
      shape: [i, i],
      depth: false,
      stencil: false,
      colorType: "float"
    }), this.trackPoints();
  }
  getTrackedPositionsMap() {
    const t = /* @__PURE__ */ new Map();
    if (!this.trackedIndices) return t;
    const n = _n(this.reglInstance, this.trackedPositionsFbo);
    for (let r = 0; r < n.length / 4; r += 1) {
      const i = n[r * 4], o = n[r * 4 + 1], f = this.trackedIndices[r];
      i !== void 0 && o !== void 0 && f !== void 0 && t.set(f, [i, o]);
    }
    return t;
  }
  getSampledPointPositionsMap() {
    var r, i;
    const t = /* @__PURE__ */ new Map();
    if (!this.sampledPointsFbo) return t;
    (r = this.clearSampledPointsFboCommand) == null || r.call(this), (i = this.fillSampledPointsFboCommand) == null || i.call(this);
    const n = _n(this.reglInstance, this.sampledPointsFbo);
    for (let o = 0; o < n.length / 4; o++) {
      const f = n[o * 4], s = !!n[o * 4 + 1], u = n[o * 4 + 2], l = n[o * 4 + 3];
      s && f !== void 0 && u !== void 0 && l !== void 0 && t.set(f, [u, l]);
    }
    return t;
  }
  swapFbo() {
    const t = this.previousPositionFbo;
    this.previousPositionFbo = this.currentPositionFbo, this.currentPositionFbo = t;
  }
  // private rescaleInitialNodePositions (): void {
  //   const { nodes } = this.data
  //   const { spaceSize } = this.config
  //   if (nodes.length === 0) return
  //   const xs = nodes.map(n => n.x).filter((n): n is number => n !== undefined)
  //   if (xs.length === 0) return
  //   const ys = nodes.map(n => n.y).filter((n): n is number => n !== undefined)
  //   if (ys.length === 0) return
  //   const [minX, maxX] = extent(xs)
  //   if (minX === undefined || maxX === undefined) return
  //   const [minY, maxY] = extent(ys)
  //   if (minY === undefined || maxY === undefined) return
  //   const w = maxX - minX
  //   const h = maxY - minY
  //   const size = Math.max(w, h)
  //   const dw = (size - w) / 2
  //   const dh = (size - h) / 2
  //   const scaleX = scaleLinear()
  //     .range([0, spaceSize ?? defaultConfigValues.spaceSize])
  //     .domain([minX - dw, maxX + dw])
  //   const scaleY = scaleLinear()
  //     .range([0, spaceSize ?? defaultConfigValues.spaceSize])
  //     .domain([minY - dh, maxY + dh])
  //   nodes.forEach(n => {
  //     n.x = scaleX(n.x as number)
  //     n.y = scaleY(n.y as number)
  //   })
  // }
};
var su = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var e3 = 0, t = arguments.length; t--; )
    e3 += arguments[t] * arguments[t];
  return Math.sqrt(e3);
});
function Pg() {
  var e3 = new su(9);
  return su != Float32Array && (e3[1] = 0, e3[2] = 0, e3[3] = 0, e3[5] = 0, e3[6] = 0, e3[7] = 0), e3[0] = 1, e3[4] = 1, e3[8] = 1, e3;
}
function fu(e3, t, n) {
  var r = t[0], i = t[1], o = t[2], f = t[3], s = t[4], u = t[5], l = t[6], v = t[7], b = t[8], S = n[0], M = n[1];
  return e3[0] = r, e3[1] = i, e3[2] = o, e3[3] = f, e3[4] = s, e3[5] = u, e3[6] = S * r + M * f + l, e3[7] = S * i + M * s + v, e3[8] = S * o + M * u + b, e3;
}
function Ho(e3, t, n) {
  var r = n[0], i = n[1];
  return e3[0] = r * t[0], e3[1] = r * t[1], e3[2] = r * t[2], e3[3] = i * t[3], e3[4] = i * t[4], e3[5] = i * t[5], e3[6] = t[6], e3[7] = t[7], e3[8] = t[8], e3;
}
function Cg(e3, t, n) {
  return e3[0] = 2 / t, e3[1] = 0, e3[2] = 0, e3[3] = 0, e3[4] = -2 / n, e3[5] = 0, e3[6] = -1, e3[7] = 1, e3[8] = 1, e3;
}
var Sa = { exports: {} };
Sa.exports;
(function(e3) {
  (function(t, n, r) {
    function i(u) {
      var l = this, v = s();
      l.next = function() {
        var b = 2091639 * l.s0 + l.c * 23283064365386963e-26;
        return l.s0 = l.s1, l.s1 = l.s2, l.s2 = b - (l.c = b | 0);
      }, l.c = 1, l.s0 = v(" "), l.s1 = v(" "), l.s2 = v(" "), l.s0 -= v(u), l.s0 < 0 && (l.s0 += 1), l.s1 -= v(u), l.s1 < 0 && (l.s1 += 1), l.s2 -= v(u), l.s2 < 0 && (l.s2 += 1), v = null;
    }
    function o(u, l) {
      return l.c = u.c, l.s0 = u.s0, l.s1 = u.s1, l.s2 = u.s2, l;
    }
    function f(u, l) {
      var v = new i(u), b = l && l.state, S = v.next;
      return S.int32 = function() {
        return v.next() * 4294967296 | 0;
      }, S.double = function() {
        return S() + (S() * 2097152 | 0) * 11102230246251565e-32;
      }, S.quick = S, b && (typeof b == "object" && o(b, v), S.state = function() {
        return o(v, {});
      }), S;
    }
    function s() {
      var u = 4022871197, l = function(v) {
        v = String(v);
        for (var b = 0; b < v.length; b++) {
          u += v.charCodeAt(b);
          var S = 0.02519603282416938 * u;
          u = S >>> 0, S -= u, S *= u, u = S >>> 0, S -= u, u += S * 4294967296;
        }
        return (u >>> 0) * 23283064365386963e-26;
      };
      return l;
    }
    n && n.exports ? n.exports = f : this.alea = f;
  })(
    hn,
    e3
  );
})(Sa);
var kg = Sa.exports;
var wa = { exports: {} };
wa.exports;
(function(e3) {
  (function(t, n, r) {
    function i(s) {
      var u = this, l = "";
      u.x = 0, u.y = 0, u.z = 0, u.w = 0, u.next = function() {
        var b = u.x ^ u.x << 11;
        return u.x = u.y, u.y = u.z, u.z = u.w, u.w ^= u.w >>> 19 ^ b ^ b >>> 8;
      }, s === (s | 0) ? u.x = s : l += s;
      for (var v = 0; v < l.length + 64; v++)
        u.x ^= l.charCodeAt(v) | 0, u.next();
    }
    function o(s, u) {
      return u.x = s.x, u.y = s.y, u.z = s.z, u.w = s.w, u;
    }
    function f(s, u) {
      var l = new i(s), v = u && u.state, b = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return b.double = function() {
        do
          var S = l.next() >>> 11, M = (l.next() >>> 0) / 4294967296, K = (S + M) / (1 << 21);
        while (K === 0);
        return K;
      }, b.int32 = l.next, b.quick = b, v && (typeof v == "object" && o(v, l), b.state = function() {
        return o(l, {});
      }), b;
    }
    n && n.exports ? n.exports = f : this.xor128 = f;
  })(
    hn,
    e3
  );
})(wa);
var Fg = wa.exports;
var Ta = { exports: {} };
Ta.exports;
(function(e3) {
  (function(t, n, r) {
    function i(s) {
      var u = this, l = "";
      u.next = function() {
        var b = u.x ^ u.x >>> 2;
        return u.x = u.y, u.y = u.z, u.z = u.w, u.w = u.v, (u.d = u.d + 362437 | 0) + (u.v = u.v ^ u.v << 4 ^ (b ^ b << 1)) | 0;
      }, u.x = 0, u.y = 0, u.z = 0, u.w = 0, u.v = 0, s === (s | 0) ? u.x = s : l += s;
      for (var v = 0; v < l.length + 64; v++)
        u.x ^= l.charCodeAt(v) | 0, v == l.length && (u.d = u.x << 10 ^ u.x >>> 4), u.next();
    }
    function o(s, u) {
      return u.x = s.x, u.y = s.y, u.z = s.z, u.w = s.w, u.v = s.v, u.d = s.d, u;
    }
    function f(s, u) {
      var l = new i(s), v = u && u.state, b = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return b.double = function() {
        do
          var S = l.next() >>> 11, M = (l.next() >>> 0) / 4294967296, K = (S + M) / (1 << 21);
        while (K === 0);
        return K;
      }, b.int32 = l.next, b.quick = b, v && (typeof v == "object" && o(v, l), b.state = function() {
        return o(l, {});
      }), b;
    }
    n && n.exports ? n.exports = f : this.xorwow = f;
  })(
    hn,
    e3
  );
})(Ta);
var Lg = Ta.exports;
var Aa = { exports: {} };
Aa.exports;
(function(e3) {
  (function(t, n, r) {
    function i(s) {
      var u = this;
      u.next = function() {
        var v = u.x, b = u.i, S, M;
        return S = v[b], S ^= S >>> 7, M = S ^ S << 24, S = v[b + 1 & 7], M ^= S ^ S >>> 10, S = v[b + 3 & 7], M ^= S ^ S >>> 3, S = v[b + 4 & 7], M ^= S ^ S << 7, S = v[b + 7 & 7], S = S ^ S << 13, M ^= S ^ S << 9, v[b] = M, u.i = b + 1 & 7, M;
      };
      function l(v, b) {
        var S, M = [];
        if (b === (b | 0))
          M[0] = b;
        else
          for (b = "" + b, S = 0; S < b.length; ++S)
            M[S & 7] = M[S & 7] << 15 ^ b.charCodeAt(S) + M[S + 1 & 7] << 13;
        for (; M.length < 8; ) M.push(0);
        for (S = 0; S < 8 && M[S] === 0; ++S) ;
        for (S == 8 ? M[7] = -1 : M[S], v.x = M, v.i = 0, S = 256; S > 0; --S)
          v.next();
      }
      l(u, s);
    }
    function o(s, u) {
      return u.x = s.x.slice(), u.i = s.i, u;
    }
    function f(s, u) {
      s == null && (s = +/* @__PURE__ */ new Date());
      var l = new i(s), v = u && u.state, b = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return b.double = function() {
        do
          var S = l.next() >>> 11, M = (l.next() >>> 0) / 4294967296, K = (S + M) / (1 << 21);
        while (K === 0);
        return K;
      }, b.int32 = l.next, b.quick = b, v && (v.x && o(v, l), b.state = function() {
        return o(l, {});
      }), b;
    }
    n && n.exports ? n.exports = f : this.xorshift7 = f;
  })(
    hn,
    e3
  );
})(Aa);
var zg = Aa.exports;
var Ea = { exports: {} };
Ea.exports;
(function(e3) {
  (function(t, n, r) {
    function i(s) {
      var u = this;
      u.next = function() {
        var v = u.w, b = u.X, S = u.i, M, K;
        return u.w = v = v + 1640531527 | 0, K = b[S + 34 & 127], M = b[S = S + 1 & 127], K ^= K << 13, M ^= M << 17, K ^= K >>> 15, M ^= M >>> 12, K = b[S] = K ^ M, u.i = S, K + (v ^ v >>> 16) | 0;
      };
      function l(v, b) {
        var S, M, K, we, ke, ae = [], Ne = 128;
        for (b === (b | 0) ? (M = b, b = null) : (b = b + "\0", M = 0, Ne = Math.max(Ne, b.length)), K = 0, we = -32; we < Ne; ++we)
          b && (M ^= b.charCodeAt((we + 32) % b.length)), we === 0 && (ke = M), M ^= M << 10, M ^= M >>> 15, M ^= M << 4, M ^= M >>> 13, we >= 0 && (ke = ke + 1640531527 | 0, S = ae[we & 127] ^= M + ke, K = S == 0 ? K + 1 : 0);
        for (K >= 128 && (ae[(b && b.length || 0) & 127] = -1), K = 127, we = 4 * 128; we > 0; --we)
          M = ae[K + 34 & 127], S = ae[K = K + 1 & 127], M ^= M << 13, S ^= S << 17, M ^= M >>> 15, S ^= S >>> 12, ae[K] = M ^ S;
        v.w = ke, v.X = ae, v.i = K;
      }
      l(u, s);
    }
    function o(s, u) {
      return u.i = s.i, u.w = s.w, u.X = s.X.slice(), u;
    }
    function f(s, u) {
      s == null && (s = +/* @__PURE__ */ new Date());
      var l = new i(s), v = u && u.state, b = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return b.double = function() {
        do
          var S = l.next() >>> 11, M = (l.next() >>> 0) / 4294967296, K = (S + M) / (1 << 21);
        while (K === 0);
        return K;
      }, b.int32 = l.next, b.quick = b, v && (v.X && o(v, l), b.state = function() {
        return o(l, {});
      }), b;
    }
    n && n.exports ? n.exports = f : this.xor4096 = f;
  })(
    hn,
    // window object or global
    e3
  );
})(Ea);
var Ig = Ea.exports;
var Pa = { exports: {} };
Pa.exports;
(function(e3) {
  (function(t, n, r) {
    function i(s) {
      var u = this, l = "";
      u.next = function() {
        var b = u.b, S = u.c, M = u.d, K = u.a;
        return b = b << 25 ^ b >>> 7 ^ S, S = S - M | 0, M = M << 24 ^ M >>> 8 ^ K, K = K - b | 0, u.b = b = b << 20 ^ b >>> 12 ^ S, u.c = S = S - M | 0, u.d = M << 16 ^ S >>> 16 ^ K, u.a = K - b | 0;
      }, u.a = 0, u.b = 0, u.c = -1640531527, u.d = 1367130551, s === Math.floor(s) ? (u.a = s / 4294967296 | 0, u.b = s | 0) : l += s;
      for (var v = 0; v < l.length + 20; v++)
        u.b ^= l.charCodeAt(v) | 0, u.next();
    }
    function o(s, u) {
      return u.a = s.a, u.b = s.b, u.c = s.c, u.d = s.d, u;
    }
    function f(s, u) {
      var l = new i(s), v = u && u.state, b = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return b.double = function() {
        do
          var S = l.next() >>> 11, M = (l.next() >>> 0) / 4294967296, K = (S + M) / (1 << 21);
        while (K === 0);
        return K;
      }, b.int32 = l.next, b.quick = b, v && (typeof v == "object" && o(v, l), b.state = function() {
        return o(l, {});
      }), b;
    }
    n && n.exports ? n.exports = f : this.tychei = f;
  })(
    hn,
    e3
  );
})(Pa);
var Rg = Pa.exports;
var Ku = { exports: {} };
var Dg = {};
var Mg = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Dg
}, Symbol.toStringTag, { value: "Module" }));
var Og = Y0(Mg);
(function(e3) {
  (function(t, n, r) {
    var i = 256, o = 6, f = 52, s = "random", u = r.pow(i, o), l = r.pow(2, f), v = l * 2, b = i - 1, S;
    function M(q, pe, De) {
      var Ge = [];
      pe = pe == true ? { entropy: true } : pe || {};
      var qe = ae(ke(
        pe.entropy ? [q, je(n)] : q ?? Ne(),
        3
      ), Ge), et = new K(Ge), rt = function() {
        for (var ze = et.g(o), st = u, tt = 0; ze < l; )
          ze = (ze + tt) * i, st *= i, tt = et.g(1);
        for (; ze >= v; )
          ze /= 2, st /= 2, tt >>>= 1;
        return (ze + tt) / st;
      };
      return rt.int32 = function() {
        return et.g(4) | 0;
      }, rt.quick = function() {
        return et.g(4) / 4294967296;
      }, rt.double = rt, ae(je(et.S), n), (pe.pass || De || function(ze, st, tt, N) {
        return N && (N.S && we(N, et), ze.state = function() {
          return we(et, {});
        }), tt ? (r[s] = ze, st) : ze;
      })(
        rt,
        qe,
        "global" in pe ? pe.global : this == r,
        pe.state
      );
    }
    function K(q) {
      var pe, De = q.length, Ge = this, qe = 0, et = Ge.i = Ge.j = 0, rt = Ge.S = [];
      for (De || (q = [De++]); qe < i; )
        rt[qe] = qe++;
      for (qe = 0; qe < i; qe++)
        rt[qe] = rt[et = b & et + q[qe % De] + (pe = rt[qe])], rt[et] = pe;
      (Ge.g = function(ze) {
        for (var st, tt = 0, N = Ge.i, Te = Ge.j, oe = Ge.S; ze--; )
          st = oe[N = b & N + 1], tt = tt * i + oe[b & (oe[N] = oe[Te = b & Te + st]) + (oe[Te] = st)];
        return Ge.i = N, Ge.j = Te, tt;
      })(i);
    }
    function we(q, pe) {
      return pe.i = q.i, pe.j = q.j, pe.S = q.S.slice(), pe;
    }
    function ke(q, pe) {
      var De = [], Ge = typeof q, qe;
      if (pe && Ge == "object")
        for (qe in q)
          try {
            De.push(ke(q[qe], pe - 1));
          } catch {
          }
      return De.length ? De : Ge == "string" ? q : q + "\0";
    }
    function ae(q, pe) {
      for (var De = q + "", Ge, qe = 0; qe < De.length; )
        pe[b & qe] = b & (Ge ^= pe[b & qe] * 19) + De.charCodeAt(qe++);
      return je(pe);
    }
    function Ne() {
      try {
        var q;
        return S && (q = S.randomBytes) ? q = q(i) : (q = new Uint8Array(i), (t.crypto || t.msCrypto).getRandomValues(q)), je(q);
      } catch {
        var pe = t.navigator, De = pe && pe.plugins;
        return [+/* @__PURE__ */ new Date(), t, De, t.screen, je(n)];
      }
    }
    function je(q) {
      return String.fromCharCode.apply(0, q);
    }
    if (ae(r.random(), n), e3.exports) {
      e3.exports = M;
      try {
        S = Og;
      } catch {
      }
    } else
      r["seed" + s] = M;
  })(
    // global: `self` in browsers (including strict mode and web workers),
    // otherwise `this` in Node and other environments
    typeof self < "u" ? self : hn,
    [],
    // pool: entropy pool starts empty
    Math
    // math: package containing random, pow, and seedrandom
  );
})(Ku);
var Ng = Ku.exports;
var Gg = kg;
var Bg = Fg;
var Vg = Lg;
var $g = zg;
var jg = Ig;
var Ug = Rg;
var jn = Ng;
jn.alea = Gg;
jn.xor128 = Bg;
jn.xorwow = Vg;
jn.xorshift7 = $g;
jn.xor4096 = jg;
jn.tychei = Ug;
var Xg = jn;
var Hg = ba(Xg);
function Wg(e3, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || false, r.configurable = true, "value" in r && (r.writable = true), Object.defineProperty(e3, Yg(r.key), r);
  }
}
function Ca(e3, t, n) {
  return t && Wg(e3.prototype, t), Object.defineProperty(e3, "prototype", {
    writable: false
  }), e3;
}
function Ju(e3, t) {
  e3.prototype = Object.create(t.prototype), e3.prototype.constructor = e3, fa(e3, t);
}
function fa(e3, t) {
  return fa = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, fa(e3, t);
}
function qg(e3, t) {
  if (typeof e3 != "object" || e3 === null) return e3;
  var n = e3[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e3, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e3);
}
function Yg(e3) {
  var t = qg(e3, "string");
  return typeof t == "symbol" ? t : String(t);
}
var Xi = function() {
  function e3() {
  }
  var t = e3.prototype;
  return t._seed = function(r, i) {
    if (r === (r || 0))
      return r;
    for (var o = "" + r, f = 0, s = 0; s < o.length; ++s)
      f ^= o.charCodeAt(s) | 0;
    return f;
  }, e3;
}();
var uu = function(e3) {
  Ju(t, e3);
  function t(r, i) {
    var o;
    return o = e3.call(this) || this, o._rng = void 0, o.seed(r, i), o;
  }
  var n = t.prototype;
  return n.next = function() {
    return this._rng();
  }, n.seed = function(i, o) {
    this._rng = i;
  }, n.clone = function(i, o) {
    return new t(this._rng, o);
  }, Ca(t, [{
    key: "name",
    get: function() {
      return "function";
    }
  }]), t;
}(Xi);
var cu = function() {
  var e3 = [].slice.call(arguments), t = e3, n = t[0], r = n === void 0 ? "default" : n;
  switch (typeof r) {
    case "object":
      if (r instanceof Xi)
        return r;
      break;
    case "function":
      return new uu(r);
    case "number":
    case "string":
    default:
      return new uu(Hg.apply(void 0, e3));
  }
  throw new Error('invalid RNG "' + r + '"');
};
var Zg = function(e3, t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = 1), function() {
    return e3.next() * (n - t) + t;
  };
};
function qt(e3) {
  return new Qg(e3);
}
var Qg = function(t) {
  var n = this;
  this.n = void 0, this.isInt = function() {
    if (Number.isInteger(n.n))
      return n;
    throw new Error("Expected number to be an integer, got " + n.n);
  }, this.isPositive = function() {
    if (n.n > 0)
      return n;
    throw new Error("Expected number to be positive, got " + n.n);
  }, this.lessThan = function(r) {
    if (n.n < r)
      return n;
    throw new Error("Expected number to be less than " + r + ", got " + n.n);
  }, this.greaterThanOrEqual = function(r) {
    if (n.n >= r)
      return n;
    throw new Error("Expected number to be greater than or equal to " + r + ", got " + n.n);
  }, this.greaterThan = function(r) {
    if (n.n > r)
      return n;
    throw new Error("Expected number to be greater than " + r + ", got " + n.n);
  }, this.n = t;
};
var Kg = function(e3, t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = 1), n === void 0 && (n = t === void 0 ? 1 : t, t = 0), qt(t).isInt(), qt(n).isInt(), function() {
    return Math.floor(e3.next() * (n - t + 1) + t);
  };
};
var Jg = function(e3) {
  return function() {
    return e3.next() >= 0.5;
  };
};
var ex = function(e3, t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = 1), function() {
    var r, i, o;
    do
      r = e3.next() * 2 - 1, i = e3.next() * 2 - 1, o = r * r + i * i;
    while (!o || o > 1);
    return t + n * i * Math.sqrt(-2 * Math.log(o) / o);
  };
};
var tx = function(e3, t, n) {
  t === void 0 && (t = 0), n === void 0 && (n = 1);
  var r = e3.normal(t, n);
  return function() {
    return Math.exp(r());
  };
};
var nx = function(e3, t) {
  return t === void 0 && (t = 0.5), qt(t).greaterThanOrEqual(0).lessThan(1), function() {
    return Math.floor(e3.next() + t);
  };
};
var rx = function(e3, t, n) {
  return t === void 0 && (t = 1), n === void 0 && (n = 0.5), qt(t).isInt().isPositive(), qt(n).greaterThanOrEqual(0).lessThan(1), function() {
    for (var r = 0, i = 0; r++ < t; )
      e3.next() < n && i++;
    return i;
  };
};
var ix = function(e3, t) {
  t === void 0 && (t = 0.5), qt(t).greaterThan(0).lessThan(1);
  var n = 1 / Math.log(1 - t);
  return function() {
    return Math.floor(1 + Math.log(e3.next()) * n);
  };
};
var ox = [0, 0, 0.6931471805599453, 1.791759469228055, 3.1780538303479458, 4.787491742782046, 6.579251212010101, 8.525161361065415, 10.60460290274525, 12.801827480081469];
var ax = function(t) {
  return ox[t];
};
var sx = 0.9189385332046727;
var fx = function(e3, t) {
  if (t === void 0 && (t = 1), qt(t).isPositive(), t < 10) {
    var n = Math.exp(-t);
    return function() {
      for (var u = n, l = 0, v = e3.next(); v > u; )
        v = v - u, u = t * u / ++l;
      return l;
    };
  } else {
    var r = Math.sqrt(t), i = 0.931 + 2.53 * r, o = -0.059 + 0.02483 * i, f = 1.1239 + 1.1328 / (i - 3.4), s = 0.9277 - 3.6224 / (i - 2);
    return function() {
      for (; ; ) {
        var u = void 0, l = e3.next();
        if (l <= 0.86 * s)
          return u = l / s - 0.43, Math.floor((2 * o / (0.5 - Math.abs(u)) + i) * u + t + 0.445);
        l >= s ? u = e3.next() - 0.5 : (u = l / s - 0.93, u = (u < 0 ? -0.5 : 0.5) - u, l = e3.next() * s);
        var v = 0.5 - Math.abs(u);
        if (!(v < 0.013 && l > v)) {
          var b = Math.floor((2 * o / v + i) * u + t + 0.445);
          if (l = l * f / (o / (v * v) + i), b >= 10) {
            var S = (b + 0.5) * Math.log(t / b) - t - sx + b - (0.08333333333333333 - (0.002777777777777778 - 1 / (1260 * b * b)) / (b * b)) / b;
            if (Math.log(l * r) <= S)
              return b;
          } else if (b >= 0) {
            var M, K = (M = ax(b)) != null ? M : 0;
            if (Math.log(l) <= b * Math.log(t) - t - K)
              return b;
          }
        }
      }
    };
  }
};
var ux = function(e3, t) {
  return t === void 0 && (t = 1), qt(t).isPositive(), function() {
    return -Math.log(1 - e3.next()) / t;
  };
};
var cx = function(e3, t) {
  return t === void 0 && (t = 1), qt(t).isInt().greaterThanOrEqual(0), function() {
    for (var n = 0, r = 0; r < t; ++r)
      n += e3.next();
    return n;
  };
};
var lx = function(e3, t) {
  t === void 0 && (t = 1), qt(t).isInt().isPositive();
  var n = e3.irwinHall(t);
  return function() {
    return n() / t;
  };
};
var hx = function(e3, t) {
  t === void 0 && (t = 1), qt(t).greaterThanOrEqual(0);
  var n = 1 / t;
  return function() {
    return 1 / Math.pow(1 - e3.next(), n);
  };
};
var dx = function(e3) {
  Ju(t, e3);
  function t() {
    return e3.apply(this, arguments) || this;
  }
  var n = t.prototype;
  return n.next = function() {
    return Math.random();
  }, n.seed = function(i, o) {
  }, n.clone = function() {
    return new t();
  }, Ca(t, [{
    key: "name",
    get: function() {
      return "default";
    }
  }]), t;
}(Xi);
var ec = function() {
  function e3(n) {
    var r = this;
    this._rng = void 0, this._patch = void 0, this._cache = {}, this.next = function() {
      return r._rng.next();
    }, this.float = function(i, o) {
      return r.uniform(i, o)();
    }, this.int = function(i, o) {
      return r.uniformInt(i, o)();
    }, this.integer = function(i, o) {
      return r.uniformInt(i, o)();
    }, this.bool = function() {
      return r.uniformBoolean()();
    }, this.boolean = function() {
      return r.uniformBoolean()();
    }, this.uniform = function(i, o) {
      return r._memoize("uniform", Zg, i, o);
    }, this.uniformInt = function(i, o) {
      return r._memoize("uniformInt", Kg, i, o);
    }, this.uniformBoolean = function() {
      return r._memoize("uniformBoolean", Jg);
    }, this.normal = function(i, o) {
      return ex(r, i, o);
    }, this.logNormal = function(i, o) {
      return tx(r, i, o);
    }, this.bernoulli = function(i) {
      return nx(r, i);
    }, this.binomial = function(i, o) {
      return rx(r, i, o);
    }, this.geometric = function(i) {
      return ix(r, i);
    }, this.poisson = function(i) {
      return fx(r, i);
    }, this.exponential = function(i) {
      return ux(r, i);
    }, this.irwinHall = function(i) {
      return cx(r, i);
    }, this.bates = function(i) {
      return lx(r, i);
    }, this.pareto = function(i) {
      return hx(r, i);
    }, n && n instanceof Xi ? this.use(n) : this.use(new dx()), this._cache = {};
  }
  var t = e3.prototype;
  return t.clone = function() {
    var r = [].slice.call(arguments);
    return r.length ? new e3(cu.apply(void 0, r)) : new e3(this.rng.clone());
  }, t.use = function() {
    this._rng = cu.apply(void 0, [].slice.call(arguments));
  }, t.patch = function() {
    if (this._patch)
      throw new Error("Math.random already patched");
    this._patch = Math.random, Math.random = this.uniform();
  }, t.unpatch = function() {
    this._patch && (Math.random = this._patch, delete this._patch);
  }, t.choice = function(r) {
    if (!Array.isArray(r))
      throw new Error("Random.choice expected input to be an array, got " + typeof r);
    var i = r == null ? void 0 : r.length;
    if (i > 0) {
      var o = this.uniformInt(0, i - 1)();
      return r[o];
    } else
      return;
  }, t._memoize = function(r, i) {
    var o = [].slice.call(arguments, 2), f = "" + o.join(";"), s = this._cache[r];
    return (s === void 0 || s.key !== f) && (s = {
      key: f,
      distribution: i.apply(void 0, [this].concat(o))
    }, this._cache[r] = s), s.distribution;
  }, Ca(e3, [{
    key: "rng",
    get: function() {
      return this._rng;
    }
  }]), e3;
}();
new ec();
var ua = 1e-3;
var ca = 64;
var mx = class {
  constructor() {
    this.pointsTextureSize = 0, this.linksTextureSize = 0, this.alpha = 1, this.transform = Pg(), this.backgroundColor = [0, 0, 0, 0], this.screenSize = [0, 0], this.mousePosition = [0, 0], this.screenMousePosition = [0, 0], this.selectedArea = [[0, 0], [0, 0]], this.isSimulationRunning = false, this.simulationProgress = 0, this.selectedIndices = null, this.maxPointSize = ca, this.hoveredPoint = void 0, this.focusedPoint = void 0, this.draggingPointIndex = void 0, this.adjustedSpaceSize = We.spaceSize, this.isSpaceKeyPressed = false, this.hoveredPointRingColor = [1, 1, 1, ov], this.focusedPointRingColor = [1, 1, 1, av], this.alphaTarget = 0, this.scalePointX = sa(), this.scalePointY = sa(), this.random = new ec(), this.alphaDecay = (t) => 1 - Math.pow(ua, 1 / t);
  }
  addRandomSeed(t) {
    this.random = this.random.clone(t);
  }
  getRandomFloat(t, n) {
    return this.random.float(t, n);
  }
  /**
   * If the config parameter `spaceSize` exceeds the limits of WebGL,
   * it reduces the space size without changing the config parameter.
   */
  adjustSpaceSize(t, n) {
    t >= n ? (this.adjustedSpaceSize = n / 2, console.warn(`The \`spaceSize\` has been reduced to ${this.adjustedSpaceSize} due to WebGL limits`)) : this.adjustedSpaceSize = t;
  }
  updateScreenSize(t, n) {
    const { adjustedSpaceSize: r } = this;
    this.screenSize = [t, n], this.scalePointX.domain([0, r]).range([(t - r) / 2, (t + r) / 2]), this.scalePointY.domain([r, 0]).range([(n - r) / 2, (n + r) / 2]);
  }
  scaleX(t) {
    return this.scalePointX(t);
  }
  scaleY(t) {
    return this.scalePointY(t);
  }
  setHoveredPointRingColor(t) {
    const n = ur(t);
    this.hoveredPointRingColor[0] = n[0], this.hoveredPointRingColor[1] = n[1], this.hoveredPointRingColor[2] = n[2];
  }
  setFocusedPointRingColor(t) {
    const n = ur(t);
    this.focusedPointRingColor[0] = n[0], this.focusedPointRingColor[1] = n[1], this.focusedPointRingColor[2] = n[2];
  }
  setFocusedPoint(t) {
    t !== void 0 ? this.focusedPoint = { index: t } : this.focusedPoint = void 0;
  }
  addAlpha(t) {
    return (this.alphaTarget - this.alpha) * this.alphaDecay(t);
  }
};
var px = { passive: false };
var Nr = { capture: true, passive: false };
function Wo(e3) {
  e3.stopImmediatePropagation();
}
function ar(e3) {
  e3.preventDefault(), e3.stopImmediatePropagation();
}
function tc(e3) {
  var t = e3.document.documentElement, n = St(e3).on("dragstart.drag", ar, Nr);
  "onselectstart" in t ? n.on("selectstart.drag", ar, Nr) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function nc(e3, t) {
  var n = e3.document.documentElement, r = St(e3).on("dragstart.drag", null);
  t && (r.on("click.drag", ar, Nr), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
var Ai = (e3) => () => e3;
function la(e3, {
  sourceEvent: t,
  subject: n,
  target: r,
  identifier: i,
  active: o,
  x: f,
  y: s,
  dx: u,
  dy: l,
  dispatch: v
}) {
  Object.defineProperties(this, {
    type: { value: e3, enumerable: true, configurable: true },
    sourceEvent: { value: t, enumerable: true, configurable: true },
    subject: { value: n, enumerable: true, configurable: true },
    target: { value: r, enumerable: true, configurable: true },
    identifier: { value: i, enumerable: true, configurable: true },
    active: { value: o, enumerable: true, configurable: true },
    x: { value: f, enumerable: true, configurable: true },
    y: { value: s, enumerable: true, configurable: true },
    dx: { value: u, enumerable: true, configurable: true },
    dy: { value: l, enumerable: true, configurable: true },
    _: { value: v }
  });
}
la.prototype.on = function() {
  var e3 = this._.on.apply(this._, arguments);
  return e3 === this._ ? this : e3;
};
function vx(e3) {
  return !e3.ctrlKey && !e3.button;
}
function gx() {
  return this.parentNode;
}
function xx(e3, t) {
  return t ?? { x: e3.x, y: e3.y };
}
function yx() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function bx() {
  var e3 = vx, t = gx, n = xx, r = yx, i = {}, o = $i("start", "drag", "end"), f = 0, s, u, l, v, b = 0;
  function S(q) {
    q.on("mousedown.drag", M).filter(r).on("touchstart.drag", ke).on("touchmove.drag", ae, px).on("touchend.drag touchcancel.drag", Ne).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function M(q, pe) {
    if (!(v || !e3.call(this, q, pe))) {
      var De = je(this, t.call(this, q, pe), q, pe, "mouse");
      De && (St(q.view).on("mousemove.drag", K, Nr).on("mouseup.drag", we, Nr), tc(q.view), Wo(q), l = false, s = q.clientX, u = q.clientY, De("start", q));
    }
  }
  function K(q) {
    if (ar(q), !l) {
      var pe = q.clientX - s, De = q.clientY - u;
      l = pe * pe + De * De > b;
    }
    i.mouse("drag", q);
  }
  function we(q) {
    St(q.view).on("mousemove.drag mouseup.drag", null), nc(q.view, l), ar(q), i.mouse("end", q);
  }
  function ke(q, pe) {
    if (e3.call(this, q, pe)) {
      var De = q.changedTouches, Ge = t.call(this, q, pe), qe = De.length, et, rt;
      for (et = 0; et < qe; ++et)
        (rt = je(this, Ge, q, pe, De[et].identifier, De[et])) && (Wo(q), rt("start", q, De[et]));
    }
  }
  function ae(q) {
    var pe = q.changedTouches, De = pe.length, Ge, qe;
    for (Ge = 0; Ge < De; ++Ge)
      (qe = i[pe[Ge].identifier]) && (ar(q), qe("drag", q, pe[Ge]));
  }
  function Ne(q) {
    var pe = q.changedTouches, De = pe.length, Ge, qe;
    for (v && clearTimeout(v), v = setTimeout(function() {
      v = null;
    }, 500), Ge = 0; Ge < De; ++Ge)
      (qe = i[pe[Ge].identifier]) && (Wo(q), qe("end", q, pe[Ge]));
  }
  function je(q, pe, De, Ge, qe, et) {
    var rt = o.copy(), ze = un(et || De, pe), st, tt, N;
    if ((N = n.call(q, new la("beforestart", {
      sourceEvent: De,
      target: S,
      identifier: qe,
      active: f,
      x: ze[0],
      y: ze[1],
      dx: 0,
      dy: 0,
      dispatch: rt
    }), Ge)) != null)
      return st = N.x - ze[0] || 0, tt = N.y - ze[1] || 0, function Te(oe, Pe, $e) {
        var Be = ze, Ye;
        switch (oe) {
          case "start":
            i[qe] = Te, Ye = f++;
            break;
          case "end":
            delete i[qe], --f;
          case "drag":
            ze = un($e || Pe, pe), Ye = f;
            break;
        }
        rt.call(
          oe,
          q,
          new la(oe, {
            sourceEvent: Pe,
            subject: N,
            target: S,
            identifier: qe,
            active: Ye,
            x: ze[0] + st,
            y: ze[1] + tt,
            dx: ze[0] - Be[0],
            dy: ze[1] - Be[1],
            dispatch: rt
          }),
          Ge
        );
      };
  }
  return S.filter = function(q) {
    return arguments.length ? (e3 = typeof q == "function" ? q : Ai(!!q), S) : e3;
  }, S.container = function(q) {
    return arguments.length ? (t = typeof q == "function" ? q : Ai(q), S) : t;
  }, S.subject = function(q) {
    return arguments.length ? (n = typeof q == "function" ? q : Ai(q), S) : n;
  }, S.touchable = function(q) {
    return arguments.length ? (r = typeof q == "function" ? q : Ai(!!q), S) : r;
  }, S.on = function() {
    var q = o.on.apply(o, arguments);
    return q === o ? S : q;
  }, S.clickDistance = function(q) {
    return arguments.length ? (b = (q = +q) * q, S) : Math.sqrt(b);
  }, S;
}
var Ei = (e3) => () => e3;
function _x(e3, {
  sourceEvent: t,
  target: n,
  transform: r,
  dispatch: i
}) {
  Object.defineProperties(this, {
    type: { value: e3, enumerable: true, configurable: true },
    sourceEvent: { value: t, enumerable: true, configurable: true },
    target: { value: n, enumerable: true, configurable: true },
    transform: { value: r, enumerable: true, configurable: true },
    _: { value: i }
  });
}
function cn(e3, t, n) {
  this.k = e3, this.x = t, this.y = n;
}
cn.prototype = {
  constructor: cn,
  scale: function(e3) {
    return e3 === 1 ? this : new cn(this.k * e3, this.x, this.y);
  },
  translate: function(e3, t) {
    return e3 === 0 & t === 0 ? this : new cn(this.k, this.x + this.k * e3, this.y + this.k * t);
  },
  apply: function(e3) {
    return [e3[0] * this.k + this.x, e3[1] * this.k + this.y];
  },
  applyX: function(e3) {
    return e3 * this.k + this.x;
  },
  applyY: function(e3) {
    return e3 * this.k + this.y;
  },
  invert: function(e3) {
    return [(e3[0] - this.x) / this.k, (e3[1] - this.y) / this.k];
  },
  invertX: function(e3) {
    return (e3 - this.x) / this.k;
  },
  invertY: function(e3) {
    return (e3 - this.y) / this.k;
  },
  rescaleX: function(e3) {
    return e3.copy().domain(e3.range().map(this.invertX, this).map(e3.invert, e3));
  },
  rescaleY: function(e3) {
    return e3.copy().domain(e3.range().map(this.invertY, this).map(e3.invert, e3));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var Rr = new cn(1, 0, 0);
cn.prototype;
function qo(e3) {
  e3.stopImmediatePropagation();
}
function Lr(e3) {
  e3.preventDefault(), e3.stopImmediatePropagation();
}
function Sx(e3) {
  return (!e3.ctrlKey || e3.type === "wheel") && !e3.button;
}
function wx() {
  var e3 = this;
  return e3 instanceof SVGElement ? (e3 = e3.ownerSVGElement || e3, e3.hasAttribute("viewBox") ? (e3 = e3.viewBox.baseVal, [[e3.x, e3.y], [e3.x + e3.width, e3.y + e3.height]]) : [[0, 0], [e3.width.baseVal.value, e3.height.baseVal.value]]) : [[0, 0], [e3.clientWidth, e3.clientHeight]];
}
function lu() {
  return this.__zoom || Rr;
}
function Tx(e3) {
  return -e3.deltaY * (e3.deltaMode === 1 ? 0.05 : e3.deltaMode ? 1 : 2e-3) * (e3.ctrlKey ? 10 : 1);
}
function Ax() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Ex(e3, t, n) {
  var r = e3.invertX(t[0][0]) - n[0][0], i = e3.invertX(t[1][0]) - n[1][0], o = e3.invertY(t[0][1]) - n[0][1], f = e3.invertY(t[1][1]) - n[1][1];
  return e3.translate(
    i > r ? (r + i) / 2 : Math.min(0, r) || Math.max(0, i),
    f > o ? (o + f) / 2 : Math.min(0, o) || Math.max(0, f)
  );
}
function Px() {
  var e3 = Sx, t = wx, n = Ex, r = Tx, i = Ax, o = [0, 1 / 0], f = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], s = 250, u = $p, l = $i("start", "zoom", "end"), v, b, S, M = 500, K = 150, we = 0, ke = 10;
  function ae(N) {
    N.property("__zoom", lu).on("wheel.zoom", qe, { passive: false }).on("mousedown.zoom", et).on("dblclick.zoom", rt).filter(i).on("touchstart.zoom", ze).on("touchmove.zoom", st).on("touchend.zoom touchcancel.zoom", tt).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  ae.transform = function(N, Te, oe, Pe) {
    var $e = N.selection ? N.selection() : N;
    $e.property("__zoom", lu), N !== $e ? pe(N, Te, oe, Pe) : $e.interrupt().each(function() {
      De(this, arguments).event(Pe).start().zoom(null, typeof Te == "function" ? Te.apply(this, arguments) : Te).end();
    });
  }, ae.scaleBy = function(N, Te, oe, Pe) {
    ae.scaleTo(N, function() {
      var $e = this.__zoom.k, Be = typeof Te == "function" ? Te.apply(this, arguments) : Te;
      return $e * Be;
    }, oe, Pe);
  }, ae.scaleTo = function(N, Te, oe, Pe) {
    ae.transform(N, function() {
      var $e = t.apply(this, arguments), Be = this.__zoom, Ye = oe == null ? q($e) : typeof oe == "function" ? oe.apply(this, arguments) : oe, nt = Be.invert(Ye), ut = typeof Te == "function" ? Te.apply(this, arguments) : Te;
      return n(je(Ne(Be, ut), Ye, nt), $e, f);
    }, oe, Pe);
  }, ae.translateBy = function(N, Te, oe, Pe) {
    ae.transform(N, function() {
      return n(this.__zoom.translate(
        typeof Te == "function" ? Te.apply(this, arguments) : Te,
        typeof oe == "function" ? oe.apply(this, arguments) : oe
      ), t.apply(this, arguments), f);
    }, null, Pe);
  }, ae.translateTo = function(N, Te, oe, Pe, $e) {
    ae.transform(N, function() {
      var Be = t.apply(this, arguments), Ye = this.__zoom, nt = Pe == null ? q(Be) : typeof Pe == "function" ? Pe.apply(this, arguments) : Pe;
      return n(Rr.translate(nt[0], nt[1]).scale(Ye.k).translate(
        typeof Te == "function" ? -Te.apply(this, arguments) : -Te,
        typeof oe == "function" ? -oe.apply(this, arguments) : -oe
      ), Be, f);
    }, Pe, $e);
  };
  function Ne(N, Te) {
    return Te = Math.max(o[0], Math.min(o[1], Te)), Te === N.k ? N : new cn(Te, N.x, N.y);
  }
  function je(N, Te, oe) {
    var Pe = Te[0] - oe[0] * N.k, $e = Te[1] - oe[1] * N.k;
    return Pe === N.x && $e === N.y ? N : new cn(N.k, Pe, $e);
  }
  function q(N) {
    return [(+N[0][0] + +N[1][0]) / 2, (+N[0][1] + +N[1][1]) / 2];
  }
  function pe(N, Te, oe, Pe) {
    N.on("start.zoom", function() {
      De(this, arguments).event(Pe).start();
    }).on("interrupt.zoom end.zoom", function() {
      De(this, arguments).event(Pe).end();
    }).tween("zoom", function() {
      var $e = this, Be = arguments, Ye = De($e, Be).event(Pe), nt = t.apply($e, Be), ut = oe == null ? q(nt) : typeof oe == "function" ? oe.apply($e, Be) : oe, Gt = Math.max(nt[1][0] - nt[0][0], nt[1][1] - nt[0][1]), bt = $e.__zoom, Lt = typeof Te == "function" ? Te.apply($e, Be) : Te, $t = u(bt.invert(ut).concat(Gt / bt.k), Lt.invert(ut).concat(Gt / Lt.k));
      return function(zt) {
        if (zt === 1) zt = Lt;
        else {
          var jt = $t(zt), lr = Gt / jt[2];
          zt = new cn(lr, ut[0] - jt[0] * lr, ut[1] - jt[1] * lr);
        }
        Ye.zoom(null, zt);
      };
    });
  }
  function De(N, Te, oe) {
    return !oe && N.__zooming || new Ge(N, Te);
  }
  function Ge(N, Te) {
    this.that = N, this.args = Te, this.active = 0, this.sourceEvent = null, this.extent = t.apply(N, Te), this.taps = 0;
  }
  Ge.prototype = {
    event: function(N) {
      return N && (this.sourceEvent = N), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(N, Te) {
      return this.mouse && N !== "mouse" && (this.mouse[1] = Te.invert(this.mouse[0])), this.touch0 && N !== "touch" && (this.touch0[1] = Te.invert(this.touch0[0])), this.touch1 && N !== "touch" && (this.touch1[1] = Te.invert(this.touch1[0])), this.that.__zoom = Te, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(N) {
      var Te = St(this.that).datum();
      l.call(
        N,
        this.that,
        new _x(N, {
          sourceEvent: this.sourceEvent,
          target: ae,
          type: N,
          transform: this.that.__zoom,
          dispatch: l
        }),
        Te
      );
    }
  };
  function qe(N, ...Te) {
    if (!e3.apply(this, arguments)) return;
    var oe = De(this, Te).event(N), Pe = this.__zoom, $e = Math.max(o[0], Math.min(o[1], Pe.k * Math.pow(2, r.apply(this, arguments)))), Be = un(N);
    if (oe.wheel)
      (oe.mouse[0][0] !== Be[0] || oe.mouse[0][1] !== Be[1]) && (oe.mouse[1] = Pe.invert(oe.mouse[0] = Be)), clearTimeout(oe.wheel);
    else {
      if (Pe.k === $e) return;
      oe.mouse = [Be, Pe.invert(Be)], Fi(this), oe.start();
    }
    Lr(N), oe.wheel = setTimeout(Ye, K), oe.zoom("mouse", n(je(Ne(Pe, $e), oe.mouse[0], oe.mouse[1]), oe.extent, f));
    function Ye() {
      oe.wheel = null, oe.end();
    }
  }
  function et(N, ...Te) {
    if (S || !e3.apply(this, arguments)) return;
    var oe = N.currentTarget, Pe = De(this, Te, true).event(N), $e = St(N.view).on("mousemove.zoom", ut, true).on("mouseup.zoom", Gt, true), Be = un(N, oe), Ye = N.clientX, nt = N.clientY;
    tc(N.view), qo(N), Pe.mouse = [Be, this.__zoom.invert(Be)], Fi(this), Pe.start();
    function ut(bt) {
      if (Lr(bt), !Pe.moved) {
        var Lt = bt.clientX - Ye, $t = bt.clientY - nt;
        Pe.moved = Lt * Lt + $t * $t > we;
      }
      Pe.event(bt).zoom("mouse", n(je(Pe.that.__zoom, Pe.mouse[0] = un(bt, oe), Pe.mouse[1]), Pe.extent, f));
    }
    function Gt(bt) {
      $e.on("mousemove.zoom mouseup.zoom", null), nc(bt.view, Pe.moved), Lr(bt), Pe.event(bt).end();
    }
  }
  function rt(N, ...Te) {
    if (e3.apply(this, arguments)) {
      var oe = this.__zoom, Pe = un(N.changedTouches ? N.changedTouches[0] : N, this), $e = oe.invert(Pe), Be = oe.k * (N.shiftKey ? 0.5 : 2), Ye = n(je(Ne(oe, Be), Pe, $e), t.apply(this, Te), f);
      Lr(N), s > 0 ? St(this).transition().duration(s).call(pe, Ye, Pe, N) : St(this).call(ae.transform, Ye, Pe, N);
    }
  }
  function ze(N, ...Te) {
    if (e3.apply(this, arguments)) {
      var oe = N.touches, Pe = oe.length, $e = De(this, Te, N.changedTouches.length === Pe).event(N), Be, Ye, nt, ut;
      for (qo(N), Ye = 0; Ye < Pe; ++Ye)
        nt = oe[Ye], ut = un(nt, this), ut = [ut, this.__zoom.invert(ut), nt.identifier], $e.touch0 ? !$e.touch1 && $e.touch0[2] !== ut[2] && ($e.touch1 = ut, $e.taps = 0) : ($e.touch0 = ut, Be = true, $e.taps = 1 + !!v);
      v && (v = clearTimeout(v)), Be && ($e.taps < 2 && (b = ut[0], v = setTimeout(function() {
        v = null;
      }, M)), Fi(this), $e.start());
    }
  }
  function st(N, ...Te) {
    if (this.__zooming) {
      var oe = De(this, Te).event(N), Pe = N.changedTouches, $e = Pe.length, Be, Ye, nt, ut;
      for (Lr(N), Be = 0; Be < $e; ++Be)
        Ye = Pe[Be], nt = un(Ye, this), oe.touch0 && oe.touch0[2] === Ye.identifier ? oe.touch0[0] = nt : oe.touch1 && oe.touch1[2] === Ye.identifier && (oe.touch1[0] = nt);
      if (Ye = oe.that.__zoom, oe.touch1) {
        var Gt = oe.touch0[0], bt = oe.touch0[1], Lt = oe.touch1[0], $t = oe.touch1[1], zt = (zt = Lt[0] - Gt[0]) * zt + (zt = Lt[1] - Gt[1]) * zt, jt = (jt = $t[0] - bt[0]) * jt + (jt = $t[1] - bt[1]) * jt;
        Ye = Ne(Ye, Math.sqrt(zt / jt)), nt = [(Gt[0] + Lt[0]) / 2, (Gt[1] + Lt[1]) / 2], ut = [(bt[0] + $t[0]) / 2, (bt[1] + $t[1]) / 2];
      } else if (oe.touch0) nt = oe.touch0[0], ut = oe.touch0[1];
      else return;
      oe.zoom("touch", n(je(Ye, nt, ut), oe.extent, f));
    }
  }
  function tt(N, ...Te) {
    if (this.__zooming) {
      var oe = De(this, Te).event(N), Pe = N.changedTouches, $e = Pe.length, Be, Ye;
      for (qo(N), S && clearTimeout(S), S = setTimeout(function() {
        S = null;
      }, M), Be = 0; Be < $e; ++Be)
        Ye = Pe[Be], oe.touch0 && oe.touch0[2] === Ye.identifier ? delete oe.touch0 : oe.touch1 && oe.touch1[2] === Ye.identifier && delete oe.touch1;
      if (oe.touch1 && !oe.touch0 && (oe.touch0 = oe.touch1, delete oe.touch1), oe.touch0) oe.touch0[1] = this.__zoom.invert(oe.touch0[0]);
      else if (oe.end(), oe.taps === 2 && (Ye = un(Ye, this), Math.hypot(b[0] - Ye[0], b[1] - Ye[1]) < ke)) {
        var nt = St(this).on("dblclick.zoom");
        nt && nt.apply(this, arguments);
      }
    }
  }
  return ae.wheelDelta = function(N) {
    return arguments.length ? (r = typeof N == "function" ? N : Ei(+N), ae) : r;
  }, ae.filter = function(N) {
    return arguments.length ? (e3 = typeof N == "function" ? N : Ei(!!N), ae) : e3;
  }, ae.touchable = function(N) {
    return arguments.length ? (i = typeof N == "function" ? N : Ei(!!N), ae) : i;
  }, ae.extent = function(N) {
    return arguments.length ? (t = typeof N == "function" ? N : Ei([[+N[0][0], +N[0][1]], [+N[1][0], +N[1][1]]]), ae) : t;
  }, ae.scaleExtent = function(N) {
    return arguments.length ? (o[0] = +N[0], o[1] = +N[1], ae) : [o[0], o[1]];
  }, ae.translateExtent = function(N) {
    return arguments.length ? (f[0][0] = +N[0][0], f[1][0] = +N[1][0], f[0][1] = +N[0][1], f[1][1] = +N[1][1], ae) : [[f[0][0], f[0][1]], [f[1][0], f[1][1]]];
  }, ae.constrain = function(N) {
    return arguments.length ? (n = N, ae) : n;
  }, ae.duration = function(N) {
    return arguments.length ? (s = +N, ae) : s;
  }, ae.interpolate = function(N) {
    return arguments.length ? (u = N, ae) : u;
  }, ae.on = function() {
    var N = l.on.apply(l, arguments);
    return N === l ? ae : N;
  }, ae.clickDistance = function(N) {
    return arguments.length ? (we = (N = +N) * N, ae) : Math.sqrt(we);
  }, ae.tapDistance = function(N) {
    return arguments.length ? (ke = +N, ae) : ke;
  }, ae;
}
var Cx = class {
  constructor(t, n) {
    this.eventTransform = Rr, this.behavior = Px().scaleExtent([1e-3, 1 / 0]).on("start", (r) => {
      var o, f;
      this.isRunning = true;
      const i = !!r.sourceEvent;
      (f = (o = this.config) == null ? void 0 : o.onZoomStart) == null || f.call(o, r, i);
    }).on("zoom", (r) => {
      var S, M;
      this.eventTransform = r.transform;
      const { eventTransform: { x: i, y: o, k: f }, store: { transform: s, screenSize: u } } = this, l = u[0], v = u[1];
      Cg(s, l, v), fu(s, s, [i, o]), Ho(s, s, [f, f]), fu(s, s, [l / 2, v / 2]), Ho(s, s, [l / 2, v / 2]), Ho(s, s, [1, -1]);
      const b = !!r.sourceEvent;
      (M = (S = this.config) == null ? void 0 : S.onZoom) == null || M.call(S, r, b);
    }).on("end", (r) => {
      var o, f;
      this.isRunning = false;
      const i = !!r.sourceEvent;
      (f = (o = this.config) == null ? void 0 : o.onZoomEnd) == null || f.call(o, r, i);
    }), this.isRunning = false, this.store = t, this.config = n;
  }
  /**
   * Get the zoom transform that will fit the given point positions into the viewport
   *
   * @param positions An array of point positions in the form `[x, y]`
   * @param scale An optional scale factor to apply to the transform
   * @param padding Padding around the viewport in percentage
   */
  getTransform(t, n, r = 0.1) {
    if (t.length === 0) return this.eventTransform;
    const { store: { screenSize: i } } = this, o = i[0], f = i[1], s = Jf(t.map((ae) => ae[0])), u = Jf(t.map((ae) => ae[1]));
    s[0] = this.store.scaleX(s[0]), s[1] = this.store.scaleX(s[1]), u[0] = this.store.scaleY(u[0]), u[1] = this.store.scaleY(u[1]), s[0] === s[1] && (s[0] -= 0.5, s[1] += 0.5), u[0] === u[1] && (u[0] += 0.5, u[1] -= 0.5);
    const l = o * (1 - r * 2) / (s[1] - s[0]), v = f * (1 - r * 2) / (u[0] - u[1]), b = lv(n ?? Math.min(l, v), ...this.behavior.scaleExtent()), S = (s[1] + s[0]) / 2, M = (u[1] + u[0]) / 2, K = o / 2 - S * b, we = f / 2 - M * b;
    return Rr.translate(K, we).scale(b);
  }
  getDistanceToPoint(t) {
    const { x: n, y: r, k: i } = this.eventTransform, o = this.getTransform([t], i), f = n - o.x, s = r - o.y;
    return Math.sqrt(f * f + s * s);
  }
  getMiddlePointTransform(t) {
    const { store: { screenSize: n }, eventTransform: { x: r, y: i, k: o } } = this, f = n[0], s = n[1], u = (f / 2 - r) / o, l = (s / 2 - i) / o, v = this.store.scaleX(t[0]), b = this.store.scaleY(t[1]), S = (u + v) / 2, M = (l + b) / 2, K = 1, we = f / 2 - S * K, ke = s / 2 - M * K;
    return Rr.translate(we, ke).scale(K);
  }
  convertScreenToSpacePosition(t) {
    const { eventTransform: { x: n, y: r, k: i }, store: { screenSize: o } } = this, f = o[0], s = o[1], u = (t[0] - n) / i, l = (t[1] - r) / i, v = [u, s - l];
    return v[0] -= (f - this.store.adjustedSpaceSize) / 2, v[1] -= (s - this.store.adjustedSpaceSize) / 2, v;
  }
  convertSpaceToScreenPosition(t) {
    const n = this.eventTransform.applyX(this.store.scaleX(t[0])), r = this.eventTransform.applyY(this.store.scaleY(t[1]));
    return [n, r];
  }
  convertSpaceToScreenRadius(t) {
    const { config: { scalePointsOnZoom: n }, store: { maxPointSize: r }, eventTransform: { k: i } } = this;
    let o = t * 2;
    return n ? o *= i : o *= Math.min(5, Math.max(1, i * 0.01)), Math.min(o, r) / 2;
  }
};
var kx = class {
  constructor(t, n) {
    this.isActive = false, this.behavior = bx().subject((r) => this.store.hoveredPoint && !this.store.isSpaceKeyPressed ? { x: r.x, y: r.y } : void 0).on("start", (r) => {
      var i, o;
      this.store.hoveredPoint && (this.store.draggingPointIndex = this.store.hoveredPoint.index, this.isActive = true, (o = (i = this.config) == null ? void 0 : i.onDragStart) == null || o.call(i, r));
    }).on("drag", (r) => {
      var i, o;
      (o = (i = this.config) == null ? void 0 : i.onDrag) == null || o.call(i, r);
    }).on("end", (r) => {
      var i, o;
      this.isActive = false, this.store.draggingPointIndex = void 0, (o = (i = this.config) == null ? void 0 : i.onDragEnd) == null || o.call(i, r);
    }), this.store = t, this.config = n;
  }
};
var Fx = class {
  constructor(t, n) {
    this.config = new hv(), this.graph = new Rv(this.config), this.requestAnimationFrameId = 0, this.isRightClickMouse = false, this.store = new mx(), this.zoomInstance = new Cx(this.store, this.config), this.dragInstance = new kx(this.store, this.config), this._findHoveredPointExecutionCount = 0, this._isMouseOnCanvas = false, this._isFirstRenderAfterInit = true, this._hasPointPositionsChanged = false, this._hasPointColorsChanged = false, this._hasPointSizesChanged = false, this._hasLinksChanged = false, this._hasLinkColorsChanged = false, this._hasLinkWidthsChanged = false, this._hasLinkArrowsChanged = false, this._hasPointClustersChanged = false, this._hasClusterPositionsChanged = false, this._hasPointClusterForceChanged = false, n && this.config.init(n);
    const r = t.clientWidth, i = t.clientHeight;
    t.width = r * this.config.pixelRatio, t.height = i * this.config.pixelRatio, t.style.width === "" && t.style.height === "" && St(t).style("width", "100%").style("height", "100%"), this.canvas = t, this.canvasD3Selection = St(t), this.canvasD3Selection.on("mouseenter.cosmos", () => {
      this._isMouseOnCanvas = true;
    }).on("mousemove.cosmos", () => {
      this._isMouseOnCanvas = true;
    }).on("mouseleave.cosmos", () => {
      this._isMouseOnCanvas = false;
    }), St(document).on("keydown.cosmos", (o) => {
      o.code === "Space" && (this.store.isSpaceKeyPressed = true);
    }).on("keyup.cosmos", (o) => {
      o.code === "Space" && (this.store.isSpaceKeyPressed = false);
    }), this.zoomInstance.behavior.on("start.detect", (o) => {
      this.currentEvent = o;
    }).on("zoom.detect", (o) => {
      !!o.sourceEvent && this.updateMousePosition(o.sourceEvent), this.currentEvent = o;
    }).on("end.detect", (o) => {
      this.currentEvent = o;
    }), this.dragInstance.behavior.on("start.detect", (o) => {
      this.currentEvent = o, this.updateCanvasCursor();
    }).on("drag.detect", (o) => {
      this.dragInstance.isActive && this.updateMousePosition(o), this.currentEvent = o;
    }).on("end.detect", (o) => {
      this.currentEvent = o, this.updateCanvasCursor();
    }), this.canvasD3Selection.call(this.dragInstance.behavior).call(this.zoomInstance.behavior).on("click", this.onClick.bind(this)).on("mousemove", this.onMouseMove.bind(this)).on("contextmenu", this.onRightClickMouse.bind(this)), (this.config.disableZoom || !this.config.enableDrag) && this.updateZoomDragBehaviors(), this.setZoomLevel(this.config.initialZoomLevel ?? 1), this.reglInstance = Q0({
      canvas: this.canvas,
      attributes: {
        antialias: false,
        preserveDrawingBuffer: true
      },
      extensions: ["OES_texture_float", "ANGLE_instanced_arrays"]
    }), this.store.maxPointSize = (this.reglInstance.limits.pointSizeDims[1] ?? ca) / this.config.pixelRatio, this.store.adjustSpaceSize(this.config.spaceSize, this.reglInstance.limits.maxTextureSize), this.store.updateScreenSize(r, i), this.points = new Eg(this.reglInstance, this.config, this.store, this.graph), this.lines = new dg(this.reglInstance, this.config, this.store, this.graph, this.points), this.config.disableSimulation || (this.forceGravity = new xv(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceCenter = new vv(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceManyBody = this.config.useQuadtree ? new Tv(this.reglInstance, this.config, this.store, this.graph, this.points) : new Sv(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceLinkIncoming = new Qf(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceLinkOutgoing = new Qf(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceMouse = new Ev(this.reglInstance, this.config, this.store, this.graph, this.points), this.clusters = new Fv(this.reglInstance, this.config, this.store, this.graph, this.points)), this.store.backgroundColor = ur(this.config.backgroundColor), this.config.hoveredPointRingColor && this.store.setHoveredPointRingColor(this.config.hoveredPointRingColor), this.config.focusedPointRingColor && this.store.setFocusedPointRingColor(this.config.focusedPointRingColor), this.config.focusedPointIndex !== void 0 && this.store.setFocusedPoint(this.config.focusedPointIndex), this.config.showFPSMonitor && (this.fpsMonitor = new Kf(this.canvas)), this.config.randomSeed !== void 0 && this.store.addRandomSeed(this.config.randomSeed);
  }
  /**
   * Returns the current simulation progress
   */
  get progress() {
    return this.store.simulationProgress;
  }
  /**
   * A value that gives information about the running simulation status.
   */
  get isSimulationRunning() {
    return this.store.isSimulationRunning;
  }
  /**
   * The maximum point size.
   * This value is the maximum size of the `gl.POINTS` primitive that WebGL can render on the user's hardware.
   */
  get maxPointSize() {
    return this.store.maxPointSize;
  }
  /**
   * Set or update Cosmos configuration. The changes will be applied in real time.
   * @param config Cosmos configuration object.
   */
  setConfig(t) {
    var r;
    const n = { ...this.config };
    this.config.init(t), n.pointColor !== this.config.pointColor && (this.graph.updatePointColor(), this.points.updateColor()), n.pointSize !== this.config.pointSize && (this.graph.updatePointSize(), this.points.updateSize()), n.linkColor !== this.config.linkColor && (this.graph.updateLinkColor(), this.lines.updateColor()), n.linkWidth !== this.config.linkWidth && (this.graph.updateLinkWidth(), this.lines.updateWidth()), n.linkArrows !== this.config.linkArrows && (this.graph.updateArrows(), this.lines.updateArrow()), (n.curvedLinkSegments !== this.config.curvedLinkSegments || n.curvedLinks !== this.config.curvedLinks) && this.lines.updateCurveLineGeometry(), n.backgroundColor !== this.config.backgroundColor && (this.store.backgroundColor = ur(this.config.backgroundColor)), n.hoveredPointRingColor !== this.config.hoveredPointRingColor && this.store.setHoveredPointRingColor(this.config.hoveredPointRingColor), n.focusedPointRingColor !== this.config.focusedPointRingColor && this.store.setFocusedPointRingColor(this.config.focusedPointRingColor), n.focusedPointIndex !== this.config.focusedPointIndex && this.store.setFocusedPoint(this.config.focusedPointIndex), (n.spaceSize !== this.config.spaceSize || n.simulationRepulsionQuadtreeLevels !== this.config.simulationRepulsionQuadtreeLevels) && (this.store.adjustSpaceSize(this.config.spaceSize, this.reglInstance.limits.maxTextureSize), this.resizeCanvas(true), this.update(this.store.isSimulationRunning ? this.store.alpha : 0)), n.showFPSMonitor !== this.config.showFPSMonitor && (this.config.showFPSMonitor ? this.fpsMonitor = new Kf(this.canvas) : ((r = this.fpsMonitor) == null || r.destroy(), this.fpsMonitor = void 0)), n.pixelRatio !== this.config.pixelRatio && (this.store.maxPointSize = (this.reglInstance.limits.pointSizeDims[1] ?? ca) / this.config.pixelRatio), (n.disableZoom !== this.config.disableZoom || n.enableDrag !== this.config.enableDrag) && this.updateZoomDragBehaviors();
  }
  /**
   * Sets the positions for the graph points.
   *
   * @param {Float32Array} pointPositions - A Float32Array representing the positions of points in the format [x1, y1, x2, y2, ..., xn, yn],
   * where `n` is the index of the point.
   * Example: `new Float32Array([1, 2, 3, 4, 5, 6])` sets the first point to (1, 2), the second point to (3, 4), and so on.
   */
  setPointPositions(t) {
    this.graph.inputPointPositions = t, this._hasPointPositionsChanged = true;
  }
  /**
   * Sets the colors for the graph points.
   *
   * @param {Float32Array} pointColors - A Float32Array representing the colors of points in the format [r1, g1, b1, a1, r2, g2, b2, a2, ..., rn, gn, bn, an],
   * where each color is represented in RGBA format.
   * Example: `new Float32Array([255, 0, 0, 1, 0, 255, 0, 1])` sets the first point to red and the second point to green.
  */
  setPointColors(t) {
    this.graph.inputPointColors = t, this._hasPointColorsChanged = true;
  }
  /**
   * Sets the sizes for the graph points.
   *
   * @param {Float32Array} pointSizes - A Float32Array representing the sizes of points in the format [size1, size2, ..., sizen],
   * where `n` is the index of the point.
   * Example: `new Float32Array([10, 20, 30])` sets the first point to size 10, the second point to size 20, and the third point to size 30.
   */
  setPointSizes(t) {
    this.graph.inputPointSizes = t, this._hasPointSizesChanged = true;
  }
  /**
   * Sets the links for the graph.
   *
   * @param {Float32Array} links - A Float32Array representing the links between points
   * in the format [source1, target1, source2, target2, ..., sourcen, targetn],
   * where `source` and `target` are the indices of the points being linked.
   * Example: `new Float32Array([0, 1, 1, 2])` creates a link from point 0 to point 1 and another link from point 1 to point 2.
   */
  setLinks(t) {
    this.graph.inputLinks = t, this._hasLinksChanged = true;
  }
  /**
   * Sets the colors for the graph links.
   *
   * @param {Float32Array} linkColors - A Float32Array representing the colors of links in the format [r1, g1, b1, a1, r2, g2, b2, a2, ..., rn, gn, bn, an],
   * where each color is in RGBA format.
   * Example: `new Float32Array([255, 0, 0, 1, 0, 255, 0, 1])` sets the first link to red and the second link to green.
   */
  setLinkColors(t) {
    this.graph.inputLinkColors = t, this._hasLinkColorsChanged = true;
  }
  /**
   * Sets the widths for the graph links.
   *
   * @param {Float32Array} linkWidths - A Float32Array representing the widths of links in the format [width1, width2, ..., widthn],
   * where `n` is the index of the link.
   * Example: `new Float32Array([1, 2, 3])` sets the first link to width 1, the second link to width 2, and the third link to width 3.
   */
  setLinkWidths(t) {
    this.graph.inputLinkWidths = t, this._hasLinkWidthsChanged = true;
  }
  /**
   * Sets the arrows for the graph links.
   *
   * @param {boolean[]} linkArrows - An array of booleans indicating whether each link should have an arrow,
   * in the format [arrow1, arrow2, ..., arrown], where `n` is the index of the link.
   * Example: `[true, false, true]` sets arrows on the first and third links, but not on the second link.
   */
  setLinkArrows(t) {
    this.graph.linkArrowsBoolean = t, this._hasLinkArrowsChanged = true;
  }
  /**
   * Sets the strength for the graph links.
   *
   * @param {Float32Array} linkStrength - A Float32Array representing the strength of each link in the format [strength1, strength2, ..., strengthn],
   * where `n` is the index of the link.
   * Example: `new Float32Array([1, 2, 3])` sets the first link to strength 1, the second link to strength 2, and the third link to strength 3.
   */
  setLinkStrength(t) {
    this.graph.inputLinkStrength = t;
  }
  /**
   * Sets the point clusters for the graph.
   *
   * @param {(number | undefined)[]} pointClusters - Array of cluster indices for each point in the graph.
   *   - Index: Each index corresponds to a point.
   *   - Values: Integers starting from 0; `undefined` indicates that a point does not belong to any cluster and will not be affected by cluster forces.
   * @example
   *   `[0, 1, 0, 2, undefined, 1]` maps points to clusters: point 0 and 2 to cluster 0, point 1 to cluster 1, and point 3 to cluster 2.
   * Points 4 is unclustered.
   * @note Clusters without specified positions via `setClusterPositions` will be positioned at their centermass by default.
   */
  setPointClusters(t) {
    this.graph.inputPointClusters = t, this._hasPointClustersChanged = true;
  }
  /**
   * Sets the positions of the point clusters for the graph.
   *
   * @param {(number | undefined)[]} clusterPositions - Array of cluster positions.
   *   - Every two elements represent the x and y coordinates for a cluster position.
   *   - `undefined` means the cluster's position is not defined and will use centermass positioning instead.
   * @example
   *   `[10, 20, 30, 40, undefined, undefined]` places the first cluster at (10, 20) and the second at (30, 40);
   * the third cluster will be positioned at its centermass automatically.
   */
  setClusterPositions(t) {
    this.graph.inputClusterPositions = t, this._hasClusterPositionsChanged = true;
  }
  /**
   * Sets the force strength coefficients for clustering points in the graph.
   *
   * This method allows you to customize the forces acting on individual points during the clustering process.
   * The force coefficients determine the strength of the forces applied to each point.
   *
   * @param {Float32Array} clusterStrength - A Float32Array of force strength coefficients for each point in the format [coeff1, coeff2, ..., coeffn],
   * where `n` is the index of the point.
   * Example: `new Float32Array([1, 0.4, 0.3])` sets the force coefficient for point 0 to 1, point 1 to 0.4, and point 2 to 0.3.
   */
  setPointClusterStrength(t) {
    this.graph.inputClusterStrength = t, this._hasPointClusterForceChanged = true;
  }
  /**
   * Renders the graph.
   *
   * @param {number} [simulationAlpha] - Optional value between 0 and 1
   * that controls the initial energy of the simulation.The higher the value,
   * the more initial energy the simulation will get. Zero value stops the simulation.
   */
  render(t) {
    this.graph.update();
    const { fitViewOnInit: n, fitViewDelay: r, fitViewPadding: i, fitViewDuration: o, fitViewByPointsInRect: f, initialZoomLevel: s } = this.config;
    if (!this.graph.pointsNumber && !this.graph.linksNumber) {
      this.stopFrames(), St(this.canvas).style("cursor", null), this.reglInstance.clear({
        color: this.store.backgroundColor,
        depth: 1,
        stencil: 0
      });
      return;
    }
    this._isFirstRenderAfterInit && n && s === void 0 && (this._fitViewOnInitTimeoutID = window.setTimeout(() => {
      f ? this.setZoomTransformByPointPositions(f, o, void 0, i) : this.fitView(o, i);
    }, r)), this._isFirstRenderAfterInit = false, this.update(t);
  }
  /**
   * Center the view on a point and zoom in, by point index.
   * @param index The index of the point in the array of points.
   * @param duration Duration of the animation transition in milliseconds (`700` by default).
   * @param scale Scale value to zoom in or out (`3` by default).
   * @param canZoomOut Set to `false` to prevent zooming out from the point (`true` by default).
   */
  zoomToPointByIndex(t, n = 700, r = sv, i = true) {
    const { store: { screenSize: o } } = this, f = _n(this.reglInstance, this.points.currentPositionFbo);
    if (t === void 0) return;
    const s = f[t * 4 + 0], u = f[t * 4 + 1];
    if (s === void 0 || u === void 0) return;
    const l = this.zoomInstance.getDistanceToPoint([s, u]), v = i ? r : Math.max(this.getZoomLevel(), r);
    if (l < Math.min(o[0], o[1]))
      this.setZoomTransformByPointPositions([s, u], n, v);
    else {
      const b = this.zoomInstance.getTransform([[s, u]], v), S = this.zoomInstance.getMiddlePointTransform([s, u]);
      this.canvasD3Selection.transition().ease($0).duration(n / 2).call(this.zoomInstance.behavior.transform, S).transition().ease(j0).duration(n / 2).call(this.zoomInstance.behavior.transform, b);
    }
  }
  /**
   * Zoom the view in or out to the specified zoom level.
   * @param value Zoom level
   * @param duration Duration of the zoom in/out transition.
   */
  zoom(t, n = 0) {
    this.setZoomLevel(t, n);
  }
  /**
   * Zoom the view in or out to the specified zoom level.
   * @param value Zoom level
   * @param duration Duration of the zoom in/out transition.
   */
  setZoomLevel(t, n = 0) {
    n === 0 ? this.canvasD3Selection.call(this.zoomInstance.behavior.scaleTo, t) : this.canvasD3Selection.transition().duration(n).call(this.zoomInstance.behavior.scaleTo, t);
  }
  /**
   * Get zoom level.
   * @returns Zoom level value of the view.
   */
  getZoomLevel() {
    return this.zoomInstance.eventTransform.k;
  }
  /**
   * Get current X and Y coordinates of the points.
   * @returns Array of point positions.
   */
  getPointPositions() {
    if (this.graph.pointsNumber === void 0) return [];
    const t = [], n = _n(this.reglInstance, this.points.currentPositionFbo);
    t.length = this.graph.pointsNumber * 2;
    for (let r = 0; r < this.graph.pointsNumber; r += 1) {
      const i = n[r * 4 + 0], o = n[r * 4 + 1];
      i !== void 0 && o !== void 0 && (t[r * 2] = i, t[r * 2 + 1] = o);
    }
    return t;
  }
  /**
   * Get current X and Y coordinates of the clusters.
   * @returns Array of point cluster.
   */
  getClusterPositions() {
    if (this.graph.pointClusters === void 0 || this.clusters === void 0) return [];
    const t = [], n = _n(this.reglInstance, this.clusters.centermassFbo);
    t.length = n.length / 2;
    for (let r = 0; r < t.length / 2; r += 1) {
      const i = n[r * 4 + 0], o = n[r * 4 + 1], f = n[r * 4 + 2];
      i !== void 0 && o !== void 0 && f !== void 0 && (t[r * 2] = i / f, t[r * 2 + 1] = o / f);
    }
    return t;
  }
  /**
   * Center and zoom in/out the view to fit all points in the scene.
   * @param duration Duration of the center and zoom in/out animation in milliseconds (`250` by default).
   * @param padding Padding around the viewport in percentage (`0.1` by default).
   */
  fitView(t = 250, n = 0.1) {
    this.setZoomTransformByPointPositions(this.getPointPositions(), t, void 0, n);
  }
  /**
   * Center and zoom in/out the view to fit points by their indices in the scene.
   * @param duration Duration of the center and zoom in/out animation in milliseconds (`250` by default).
   * @param padding Padding around the viewport in percentage
   */
  fitViewByPointIndices(t, n = 250, r = 0.1) {
    const i = this.getPointPositions(), o = new Array(t.length * 2);
    for (const [f, s] of t.entries())
      o[f * 2] = i[s * 2], o[f * 2 + 1] = i[s * 2 + 1];
    this.setZoomTransformByPointPositions(o, n, void 0, r);
  }
  /**
   * Center and zoom in/out the view to fit points by their positions in the scene.
   * @param duration Duration of the center and zoom in/out animation in milliseconds (`250` by default).
   * @param padding Padding around the viewport in percentage
   */
  fitViewByPointPositions(t, n = 250, r = 0.1) {
    this.setZoomTransformByPointPositions(t, n, void 0, r);
  }
  /**
   * Get points indices inside a rectangular area.
   * @param selection - Array of two corner points `[[left, top], [right, bottom]]`.
   * The `left` and `right` coordinates should be from 0 to the width of the canvas.
   * The `top` and `bottom` coordinates should be from 0 to the height of the canvas.
   * @returns A Float32Array containing the indices of points inside a rectangular area.
   */
  getPointsInRange(t) {
    const n = this.store.screenSize[1];
    return this.store.selectedArea = [[t[0][0], n - t[1][1]], [t[1][0], n - t[0][1]]], this.points.findPointsOnAreaSelection(), _n(this.reglInstance, this.points.selectedFbo).map((i, o) => o % 4 === 0 && i !== 0 ? o / 4 : -1).filter((i) => i !== -1);
  }
  /** Select points inside a rectangular area.
   * @param selection - Array of two corner points `[[left, top], [right, bottom]]`.
   * The `left` and `right` coordinates should be from 0 to the width of the canvas.
   * The `top` and `bottom` coordinates should be from 0 to the height of the canvas. */
  selectPointsInRange(t) {
    if (t) {
      const n = this.store.screenSize[1];
      this.store.selectedArea = [[t[0][0], n - t[1][1]], [t[1][0], n - t[0][1]]], this.points.findPointsOnAreaSelection();
      const r = _n(this.reglInstance, this.points.selectedFbo);
      this.store.selectedIndices = r.map((i, o) => o % 4 === 0 && i !== 0 ? o / 4 : -1).filter((i) => i !== -1);
    } else
      this.store.selectedIndices = null;
    this.points.updateGreyoutStatus();
  }
  /**
   * Select a point by index. If you want the adjacent points to get selected too, provide `true` as the second argument.
   * @param index The index of the point in the array of points.
   * @param selectAdjacentPoints When set to `true`, selects adjacent points (`false` by default).
   */
  selectPointByIndex(t, n = false) {
    if (n) {
      const r = this.graph.getAdjacentIndices(t) ?? [];
      this.selectPointsByIndices([t, ...r]);
    } else this.selectPointsByIndices([t]);
  }
  /**
   * Select multiples points by their indices.
   * @param indices Array of points indices.
   */
  selectPointsByIndices(t) {
    t ? t.length === 0 ? this.store.selectedIndices = new Float32Array() : this.store.selectedIndices = new Float32Array(t.filter((n) => n !== void 0)) : this.store.selectedIndices = null, this.points.updateGreyoutStatus();
  }
  /**
   * Unselect all points.
   */
  unselectPoints() {
    this.store.selectedIndices = null, this.points.updateGreyoutStatus();
  }
  /**
   * Get indices of points that are currently selected.
   * @returns Array of selected indices of points.
   */
  getSelectedIndices() {
    const { selectedIndices: t } = this.store;
    return t ? Array.from(t) : null;
  }
  /**
   * Get indices that are adjacent to a specific point by its index.
   * @param index Index of the point.
   * @returns Array of adjacent indices.
   */
  getAdjacentIndices(t) {
    return this.graph.getAdjacentIndices(t);
  }
  /**
   * Set focus on a point by index. A ring will be highlighted around the focused point.
   * If no index is specified, the focus will be reset.
   * If `focusedPointIndex` is specified in the config, this method will have no effect.
   * @param index The index of the point in the array of points.
   */
  setFocusedPointByIndex(t) {
    this.config.focusedPointIndex === void 0 && (t === void 0 ? this.store.setFocusedPoint() : this.store.setFocusedPoint(t));
  }
  /**
   * Converts the X and Y point coordinates from the space coordinate system to the screen coordinate system.
   * @param spacePosition Array of x and y coordinates in the space coordinate system.
   * @returns Array of x and y coordinates in the screen coordinate system.
   */
  spaceToScreenPosition(t) {
    return this.zoomInstance.convertSpaceToScreenPosition(t);
  }
  /**
   * Converts the X and Y point coordinates from the screen coordinate system to the space coordinate system.
   * @param screenPosition Array of x and y coordinates in the screen coordinate system.
   * @returns Array of x and y coordinates in the space coordinate system.
   */
  screenToSpacePosition(t) {
    return this.zoomInstance.convertScreenToSpacePosition(t);
  }
  /**
   * Converts the point radius value from the space coordinate system to the screen coordinate system.
   * @param spaceRadius Radius of point in the space coordinate system.
   * @returns Radius of point in the screen coordinate system.
   */
  spaceToScreenRadius(t) {
    return this.zoomInstance.convertSpaceToScreenRadius(t);
  }
  /**
   * Get point radius by its index.
   * @param index Index of the point.
   * @returns Radius of the point.
   */
  getPointRadiusByIndex(t) {
    var n;
    return (n = this.graph.pointSizes) == null ? void 0 : n[t];
  }
  /**
   * Track multiple point positions by their indices on each Cosmos tick.
   * @param indices Array of points indices.
   */
  trackPointPositionsByIndices(t) {
    this.points.trackPointsByIndices(t);
  }
  /**
   * Get current X and Y coordinates of the tracked points.
   * @returns A Map object where keys are the indices of the points and values are their corresponding X and Y coordinates in the [number, number] format.
   */
  getTrackedPointPositionsMap() {
    return this.points.getTrackedPositionsMap();
  }
  /**
   * For the points that are currently visible on the screen, get a sample of point indices with their coordinates.
   * The resulting number of points will depend on the `pointSamplingDistance` configuration property,
   * and the sampled points will be evenly distributed.
   * @returns A Map object where keys are the index of the points and values are their corresponding X and Y coordinates in the [number, number] format.
   */
  getSampledPointPositionsMap() {
    return this.points.getSampledPointPositionsMap();
  }
  /**
   * Start the simulation.
   * @param alpha Value from 0 to 1. The higher the value, the more initial energy the simulation will get.
   */
  start(t = 1) {
    var n, r;
    this.graph.pointsNumber && (this.store.isSimulationRunning = true, this.store.alpha = t, this.store.simulationProgress = 0, (r = (n = this.config).onSimulationStart) == null || r.call(n), this.stopFrames(), this.frame());
  }
  /**
   * Pause the simulation.
   */
  pause() {
    var t, n;
    this.store.isSimulationRunning = false, (n = (t = this.config).onSimulationPause) == null || n.call(t);
  }
  /**
   * Restart the simulation.
   */
  restart() {
    var t, n;
    this.store.isSimulationRunning = true, (n = (t = this.config).onSimulationRestart) == null || n.call(t);
  }
  /**
   * Render only one frame of the simulation (stops the simulation if it was running).
   */
  step() {
    this.store.isSimulationRunning = false, this.stopFrames(), this.frame();
  }
  /**
   * Destroy this Cosmos instance.
   */
  destroy() {
    var t, n;
    window.clearTimeout(this._fitViewOnInitTimeoutID), this.stopFrames(), this.reglInstance.destroy(), this.reglInstance.clear({
      color: this.store.backgroundColor,
      depth: 1,
      stencil: 0
    }), St(this.canvas).style("cursor", null), (t = this.fpsMonitor) == null || t.destroy(), (n = document.getElementById("gl-bench-style")) == null || n.remove();
  }
  /**
   * Create new Cosmos instance.
   */
  create() {
    var t, n, r, i, o;
    this._hasPointPositionsChanged && this.points.updatePositions(), this._hasPointColorsChanged && this.points.updateColor(), this._hasPointSizesChanged && this.points.updateSize(), (this._hasLinksChanged || this._hasPointPositionsChanged) && this.lines.updatePointsBuffer(), this._hasLinkColorsChanged && this.lines.updateColor(), this._hasLinkWidthsChanged && this.lines.updateWidth(), this._hasLinkArrowsChanged && this.lines.updateArrow(), this.lines.updateCurveLineGeometry(), (t = this.forceManyBody) == null || t.create(), (n = this.forceLinkIncoming) == null || n.create(na.INCOMING), (r = this.forceLinkOutgoing) == null || r.create(na.OUTGOING), (i = this.forceCenter) == null || i.create(), (this._hasPointClustersChanged || this._hasClusterPositionsChanged || this._hasPointClusterForceChanged) && ((o = this.clusters) == null || o.create()), this._hasPointPositionsChanged = false, this._hasPointColorsChanged = false, this._hasPointSizesChanged = false, this._hasLinksChanged = false, this._hasLinkColorsChanged = false, this._hasLinkWidthsChanged = false, this._hasLinkArrowsChanged = false, this._hasPointClustersChanged = false, this._hasClusterPositionsChanged = false, this._hasPointClusterForceChanged = false;
  }
  /**
   * Converts an array of tuple positions to a single array containing all coordinates sequentially
   * @param pointPositions An array of tuple positions
   * @returns A flatten array of coordinates
   */
  flatten(t) {
    return t.flat();
  }
  /**
   * Converts a flat array of point positions to a tuple pairs representing coordinates
   * @param pointPositions A flattened array of coordinates
   * @returns An array of tuple positions
   */
  pair(t) {
    const n = new Array(t.length / 2);
    for (let r = 0; r < t.length / 2; r++)
      n[r] = [t[r * 2], t[r * 2 + 1]];
    return n;
  }
  update(t = this.store.alpha) {
    const { graph: n } = this;
    this.store.pointsTextureSize = Math.ceil(Math.sqrt(n.pointsNumber ?? 0)), this.store.linksTextureSize = Math.ceil(Math.sqrt((n.linksNumber ?? 0) * 2)), this.create(), this.initPrograms(), this.points.trackPointsByIndices(), this.store.setFocusedPoint(this.config.focusedPointIndex), this.store.hoveredPoint = void 0, this.start(t);
  }
  initPrograms() {
    var t, n, r, i, o, f, s;
    this.points.initPrograms(), this.lines.initPrograms(), (t = this.forceGravity) == null || t.initPrograms(), (n = this.forceLinkIncoming) == null || n.initPrograms(), (r = this.forceLinkOutgoing) == null || r.initPrograms(), (i = this.forceMouse) == null || i.initPrograms(), (o = this.forceManyBody) == null || o.initPrograms(), (f = this.forceCenter) == null || f.initPrograms(), (s = this.clusters) == null || s.initPrograms();
  }
  frame() {
    const { config: { simulationGravity: t, simulationCenter: n, renderLinks: r, disableSimulation: i }, store: { alpha: o, isSimulationRunning: f } } = this;
    o < ua && f && this.end(), this.store.pointsTextureSize && (this.requestAnimationFrameId = window.requestAnimationFrame((s) => {
      var u, l, v, b, S, M, K, we, ke, ae, Ne, je, q;
      (u = this.fpsMonitor) == null || u.begin(), this.resizeCanvas(), this.dragInstance.isActive || this.findHoveredPoint(), i || (this.isRightClickMouse && (f || this.start(0.1), (l = this.forceMouse) == null || l.run(), this.points.updatePosition()), f && !this.zoomInstance.isRunning && (t && ((v = this.forceGravity) == null || v.run(), this.points.updatePosition()), n && ((b = this.forceCenter) == null || b.run(), this.points.updatePosition()), (S = this.forceManyBody) == null || S.run(), this.points.updatePosition(), this.store.linksTextureSize && ((M = this.forceLinkIncoming) == null || M.run(), this.points.updatePosition(), (K = this.forceLinkOutgoing) == null || K.run(), this.points.updatePosition()), (this.graph.pointClusters || this.graph.clusterPositions) && ((we = this.clusters) == null || we.run(), this.points.updatePosition()), this.store.alpha += this.store.addAlpha(this.config.simulationDecay ?? We.simulation.decay), this.isRightClickMouse && (this.store.alpha = Math.max(this.store.alpha, 0.1)), this.store.simulationProgress = Math.sqrt(Math.min(1, ua / this.store.alpha)), (je = (Ne = this.config).onSimulationTick) == null || je.call(
        Ne,
        this.store.alpha,
        (ke = this.store.hoveredPoint) == null ? void 0 : ke.index,
        (ae = this.store.hoveredPoint) == null ? void 0 : ae.position
      )), this.points.trackPoints()), this.reglInstance.clear({
        color: this.store.backgroundColor,
        depth: 1,
        stencil: 0
      }), r && this.store.linksTextureSize && this.lines.draw(), this.points.draw(), this.dragInstance.isActive && (this.points.drag(), this.points.drag()), (q = this.fpsMonitor) == null || q.end(s), this.currentEvent = void 0, this.frame();
    }));
  }
  stopFrames() {
    this.requestAnimationFrameId && window.cancelAnimationFrame(this.requestAnimationFrameId);
  }
  end() {
    var t, n;
    this.store.isSimulationRunning = false, this.store.simulationProgress = 1, (n = (t = this.config).onSimulationEnd) == null || n.call(t);
  }
  onClick(t) {
    var n, r, i, o;
    (o = (i = this.config).onClick) == null || o.call(
      i,
      (n = this.store.hoveredPoint) == null ? void 0 : n.index,
      (r = this.store.hoveredPoint) == null ? void 0 : r.position,
      t
    );
  }
  updateMousePosition(t) {
    if (!t) return;
    const n = t.offsetX ?? t.x, r = t.offsetY ?? t.y;
    n === void 0 || r === void 0 || (this.store.mousePosition = this.zoomInstance.convertScreenToSpacePosition([n, r]), this.store.screenMousePosition = [n, this.store.screenSize[1] - r]);
  }
  onMouseMove(t) {
    var n, r, i, o;
    this.currentEvent = t, this.updateMousePosition(t), this.isRightClickMouse = t.which === 3, (o = (i = this.config).onMouseMove) == null || o.call(
      i,
      (n = this.store.hoveredPoint) == null ? void 0 : n.index,
      (r = this.store.hoveredPoint) == null ? void 0 : r.position,
      this.currentEvent
    );
  }
  onRightClickMouse(t) {
    t.preventDefault();
  }
  resizeCanvas(t = false) {
    const n = this.canvas.width, r = this.canvas.height, i = this.canvas.clientWidth, o = this.canvas.clientHeight;
    if (t || n !== i * this.config.pixelRatio || r !== o * this.config.pixelRatio) {
      const [f, s] = this.store.screenSize, { k: u } = this.zoomInstance.eventTransform, l = this.zoomInstance.convertScreenToSpacePosition([f / 2, s / 2]);
      this.store.updateScreenSize(i, o), this.canvas.width = i * this.config.pixelRatio, this.canvas.height = o * this.config.pixelRatio, this.reglInstance.poll(), this.canvasD3Selection.call(this.zoomInstance.behavior.transform, this.zoomInstance.getTransform([l], u)), this.points.updateSampledPointsGrid();
    }
  }
  setZoomTransformByPointPositions(t, n = 250, r, i) {
    this.resizeCanvas();
    const o = this.zoomInstance.getTransform(this.pair(t), r, i);
    this.canvasD3Selection.transition().ease(U0).duration(n).call(this.zoomInstance.behavior.transform, o);
  }
  updateZoomDragBehaviors() {
    this.config.enableDrag ? this.canvasD3Selection.call(this.dragInstance.behavior) : this.canvasD3Selection.call(this.dragInstance.behavior).on(".drag", null), this.config.disableZoom ? this.canvasD3Selection.call(this.zoomInstance.behavior).on("wheel.zoom", null) : this.canvasD3Selection.call(this.zoomInstance.behavior);
  }
  findHoveredPoint() {
    var o, f, s, u, l;
    if (!this._isMouseOnCanvas) return;
    if (this._findHoveredPointExecutionCount < 2) {
      this._findHoveredPointExecutionCount += 1;
      return;
    }
    this._findHoveredPointExecutionCount = 0, this.points.findHoveredPoint();
    let t = false, n = false;
    const r = _n(this.reglInstance, this.points.hoveredFbo);
    if (r[1]) {
      const v = r[0];
      ((o = this.store.hoveredPoint) == null ? void 0 : o.index) !== v && (t = true);
      const b = r[2], S = r[3];
      this.store.hoveredPoint = {
        index: v,
        position: [b, S]
      };
    } else
      this.store.hoveredPoint && (n = true), this.store.hoveredPoint = void 0;
    t && this.store.hoveredPoint && ((s = (f = this.config).onPointMouseOver) == null || s.call(
      f,
      this.store.hoveredPoint.index,
      this.store.hoveredPoint.position,
      this.currentEvent
    )), n && ((l = (u = this.config).onPointMouseOut) == null || l.call(u, this.currentEvent)), this.updateCanvasCursor();
  }
  updateCanvasCursor() {
    const { hoveredPointCursor: t } = this.config;
    this.dragInstance.isActive ? St(this.canvas).style("cursor", "grabbing") : this.store.hoveredPoint ? !this.config.enableDrag || this.store.isSpaceKeyPressed ? St(this.canvas).style("cursor", t) : St(this.canvas).style("cursor", "grab") : St(this.canvas).style("cursor", null);
  }
};
export {
  Fx as Graph
};
//# sourceMappingURL=@cosmograph_cosmos.js.map
